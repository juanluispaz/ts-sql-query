import type { IExecutableSelectQuery, RemapIValueSourceType, ValueSourceValueType, AnyValueSource, ValueSourceOf, ValueSourceValueTypeForResult, RemapIValueSourceTypeWithOptionalType, IExecutableInsertQuery, IAnyBooleanValueSource, IStringValueSource } from "./values"
import type { HasSource, IRawFragment, OfDB, ResolvedShape } from "../utils/ITableOrView"
import type { from, source, using } from "../utils/symbols"
import type { WritableDBColumnWithDefaultValue } from "../utils/Column"
import type { RawFragment } from "../utils/RawFragment"
import type { Default } from "./Default"
import type { AutogeneratedPrimaryKeyColumnsTypesOf, ColumnsForSetOf, ColumnsForSetOfWithShape, ColumnsKeyOf, OptionalColumnsForSetOf, OptionalColumnsForSetOfWithShape, RequiredColumnsForSetOf, RequiredColumnsForSetOfWithShape, ResolveShape } from "../utils/tableOrViewUtils"
import type { MandatoryPropertiesOf } from "../utils/resultUtils"
import type { NNoTableOrViewRequiredFrom, NSource, NValuesForInsertFrom } from "../utils/sourceName"
import type { DataToProject } from "../complexProjections/dataToProject"
import type { ResultObjectValuesProjectedAsNullable } from "../complexProjections/resultWithOptionalsAsNull"
import type { ResultObjectValues } from "../complexProjections/resultWithOptionalsAsUndefined"

export interface InsertCustomization</*in|out*/ _TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> {
    afterInsertKeyword?: IRawFragment<USING[typeof source]>
    beforeQuery?: IRawFragment<USING[typeof source]>
    afterQuery?: IRawFragment<USING[typeof source]>
    queryExecutionName?: string
    queryExecutionMetadata?: any
}

export interface InsertExpressionBase</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> {
    [from]: TABLE
    [using]: USING
}

export interface ExecutableInsert</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> extends InsertExpressionBase<TABLE, USING>, IExecutableInsertQuery<NNoTableOrViewRequiredFrom<TABLE[typeof source]>, number> {
    executeInsert(min?: number, max?: number): Promise<number>
    query(): string
    params(): any[]
}

export interface ExecutableInsertReturningLastInsertedId</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, RESULT> extends InsertExpressionBase<TABLE, USING>, IExecutableInsertQuery<NNoTableOrViewRequiredFrom<TABLE[typeof source]>, RESULT> {
    executeInsert(min?: number, max?: number): Promise<RESULT>
    query(): string
    params(): any[]
}

export interface CustomizableExecutableInsert</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> extends ExecutableInsert<TABLE, USING> {
    customizeQuery(customization: InsertCustomization<TABLE, USING>): ExecutableInsert<TABLE, USING>
}

export interface CustomizableExecutableInsertReturningLastInsertedId</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ RESULT> extends ExecutableInsertReturningLastInsertedId<TABLE, USING, RESULT> {
    customizeQuery(customization: InsertCustomization<TABLE, USING>): ExecutableInsertReturningLastInsertedId<TABLE, USING, RESULT>
}

export interface CustomizableExecutableInsertFromSelectOnConflict</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> extends CustomizableExecutableInsert<TABLE, USING> {
    returningLastInsertedId: ReturningLastInsertedIdFromSelectType<TABLE, USING>
    returning: ReturningFromSelectFnType<TABLE, USING>
    returningOneColumn: ReturningOneColumnFromSelectFnType<TABLE, USING>
}

export interface CustomizableExecutableInsertFromSelectOnConflictOptional</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> extends CustomizableExecutableInsert<TABLE, USING> {
    returningLastInsertedId: ReturningLastInsertedIdFromSelectOptionalType<TABLE, USING>
    returning: ReturningFromSelectOptionalFnType<TABLE, USING>
    returningOneColumn: ReturningOneColumnFromSelectOptionalFnType<TABLE, USING>
}

export interface CustomizableExecutableInsertFromSelect</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE> extends CustomizableExecutableInsert<TABLE, USING> {
    returningLastInsertedId: ReturningLastInsertedIdFromSelectType<TABLE, USING>
    returning: ReturningFromSelectFnType<TABLE, USING>
    returningOneColumn: ReturningOneColumnFromSelectFnType<TABLE, USING>
    onConflictDoNothing: OnConflictDoNothingFnType<TABLE, USING, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE, USING>>
    onConflictDoUpdateDynamicSet: OnConflictDoUpdateDynamicSetFnType<TABLE, USING, SHAPE, CustomizableExecutableInsertFromSelectOnConflict<TABLE, USING>, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE, USING>>
    onConflictDoUpdateSet: OnConflictDoUpdateSetFnType<TABLE, USING, SHAPE, CustomizableExecutableInsertFromSelectOnConflict<TABLE, USING>, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE, USING>>
    onConflictDoUpdateSetIfValue: OnConflictDoUpdateSetFnType<TABLE, USING, SHAPE, CustomizableExecutableInsertFromSelectOnConflict<TABLE, USING>, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE, USING>>
    onConflictOn: OnConflictOnColumnFnType<TABLE, USING, OnConflictDoInsertFromSelect<TABLE, USING, SHAPE>>
    onConflictOnConstraint: OnConflictOnConstraintFnType<TABLE, USING, OnConflictDoInsertFromSelect<TABLE, USING, SHAPE>>
}

export interface OnConflictDoInsertFromSelect</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE> {
    doNothing: OnConflictDoNothingFnType<TABLE, USING, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE, USING>>
    doUpdateDynamicSet: OnConflictDoUpdateDynamicSetFnType<TABLE, USING, SHAPE, CustomizableExecutableInsertFromSelectOnConflict<TABLE, USING>, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE, USING>>
    doUpdateSet: OnConflictDoUpdateSetFnType<TABLE, USING, SHAPE, CustomizableExecutableInsertFromSelectOnConflict<TABLE, USING>, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE, USING>>
    doUpdateSetIfValue: OnConflictDoUpdateSetFnType<TABLE, USING, SHAPE, CustomizableExecutableInsertFromSelectOnConflict<TABLE, USING>, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE, USING>>
}

export interface CustomizableExecutableSimpleInsertOnConflict</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> extends CustomizableExecutableInsert<TABLE, USING> {
    returningLastInsertedId: OnConflictReturningLastInsertedIdType<TABLE, USING>
    returning: ReturningFnType<TABLE, USING>
    returningOneColumn: ReturningOneColumnFnType<TABLE, USING>
}

export interface CustomizableExecutableSimpleInsertOnConflictOptional</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> extends CustomizableExecutableInsert<TABLE, USING> {
    returningLastInsertedId: OnConflictReturningLastInsertedIdOptionalType<TABLE, USING>
    returning: ReturningOptionalFnType<TABLE, USING>
    returningOneColumn: ReturningOneColumnOptionalFnType<TABLE, USING>
}

export interface CustomizableExecutableSimpleInsert</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE> extends CustomizableExecutableInsert<TABLE, USING> {
    returningLastInsertedId: ReturningLastInsertedIdType<TABLE, USING>
    returning: ReturningFnType<TABLE, USING>
    returningOneColumn: ReturningOneColumnFnType<TABLE, USING>
    onConflictDoNothing: OnConflictDoNothingFnType<TABLE, USING, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE, USING>>
    onConflictDoUpdateDynamicSet: OnConflictDoUpdateDynamicSetFnType<TABLE, USING, SHAPE, CustomizableExecutableSimpleInsertOnConflict<TABLE, USING>, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE, USING>>
    onConflictDoUpdateSet: OnConflictDoUpdateSetFnType<TABLE, USING, SHAPE, CustomizableExecutableSimpleInsertOnConflict<TABLE, USING>, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE, USING>>
    onConflictDoUpdateSetIfValue: OnConflictDoUpdateSetFnType<TABLE, USING, SHAPE, CustomizableExecutableSimpleInsertOnConflict<TABLE, USING>, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE, USING>>
    onConflictOn: OnConflictOnColumnFnType<TABLE, USING, OnConflictDoSimpleInsert<TABLE, USING, SHAPE>>
    onConflictOnConstraint: OnConflictOnConstraintFnType<TABLE, USING, OnConflictDoSimpleInsert<TABLE, USING, SHAPE>>
}

export interface OnConflictDoSimpleInsert</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE> {
    doNothing: OnConflictDoNothingFnType<TABLE, USING, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE, USING>>
    doUpdateDynamicSet: OnConflictDoUpdateDynamicSetFnType<TABLE, USING, SHAPE, CustomizableExecutableSimpleInsertOnConflict<TABLE, USING>, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE, USING>>
    doUpdateSet: OnConflictDoUpdateSetFnType<TABLE, USING, SHAPE, CustomizableExecutableSimpleInsertOnConflict<TABLE, USING>, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE, USING>>
    doUpdateSetIfValue: OnConflictDoUpdateSetFnType<TABLE, USING, SHAPE, CustomizableExecutableSimpleInsertOnConflict<TABLE, USING>, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE, USING>>
}

export interface CustomizableExecutableMultipleInsertOnConfict</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> extends CustomizableExecutableInsert<TABLE, USING> {
    returningLastInsertedId: ReturningMultipleLastInsertedIdType<TABLE, USING>
    returning: ReturningFnType<TABLE, USING>
    returningOneColumn: ReturningOneColumnFnType<TABLE, USING>
}

export interface CustomizableExecutableMultipleInsertOnConfictOptional</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> extends CustomizableExecutableInsert<TABLE, USING> {
    returningLastInsertedId: ReturningMultipleLastInsertedIdOptionalType<TABLE, USING>
    returning: ReturningOptionalFnType<TABLE, USING>
    returningOneColumn: ReturningOneColumnOptionalFnType<TABLE, USING>
}

export interface CustomizableExecutableMultipleInsert</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE> extends CustomizableExecutableInsert<TABLE, USING> {
    returningLastInsertedId: ReturningMultipleLastInsertedIdType<TABLE, USING>
    returning: ReturningFnType<TABLE, USING>
    returningOneColumn: ReturningOneColumnFnType<TABLE, USING>
    onConflictDoNothing: OnConflictDoNothingFnType<TABLE, USING, CustomizableExecutableMultipleInsertOnConfict<TABLE, USING>>
    onConflictDoUpdateDynamicSet: OnConflictDoUpdateDynamicSetFnType<TABLE, USING, SHAPE, CustomizableExecutableMultipleInsertOnConfict<TABLE, USING>, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE, USING>>
    onConflictDoUpdateSet: OnConflictDoUpdateSetFnType<TABLE, USING, SHAPE, CustomizableExecutableMultipleInsertOnConfict<TABLE, USING>, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE, USING>>
    onConflictDoUpdateSetIfValue: OnConflictDoUpdateSetFnType<TABLE, USING, SHAPE, CustomizableExecutableMultipleInsertOnConfict<TABLE, USING>, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE, USING>>
    onConflictOn: OnConflictOnColumnFnType<TABLE, USING, OnConflictDoMultipleInsert<TABLE, USING, SHAPE>>
    onConflictOnConstraint: OnConflictOnConstraintFnType<TABLE, USING, OnConflictDoMultipleInsert<TABLE, USING, SHAPE>>
}

export interface OnConflictDoMultipleInsert</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE> {
    doNothing: OnConflictDoNothingFnType<TABLE, USING, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE, USING>>
    doUpdateDynamicSet: OnConflictDoUpdateDynamicSetFnType<TABLE, USING, SHAPE, CustomizableExecutableMultipleInsertOnConfict<TABLE, USING>, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE, USING>>
    doUpdateSet: OnConflictDoUpdateSetFnType<TABLE, USING, SHAPE, CustomizableExecutableMultipleInsertOnConfict<TABLE, USING>, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE, USING>>
    doUpdateSetIfValue: OnConflictDoUpdateSetFnType<TABLE, USING, SHAPE, CustomizableExecutableMultipleInsertOnConfict<TABLE, USING>, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE, USING>>
}

export interface ExecutableInsertExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> extends CustomizableExecutableSimpleInsert<TABLE, USING, undefined> {
    set(columns: InsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfValue(columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfSet(columns: InsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfSetIfValue(columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfNotSet(columns: InsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfNotSetIfValue(columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    ignoreIfSet<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MaybeExecutableInsertExpression<TABLE, USING, COLUMNS & RequiredColumnsForSetOf<TABLE>>
    keepOnly<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MaybeExecutableInsertExpression<TABLE, USING, Exclude<RequiredColumnsForSetOf<TABLE>, COLUMNS>>

    setIfHasValue(columns: InsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfHasValueIfValue(columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfHasNoValue(columns: InsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfHasNoValueIfValue(columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    ignoreAnySetWithNoValue(): ExecutableInsertExpression<TABLE, USING>

    disallowIfSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfNotSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfNotSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfValue(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfValue(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfNoValue(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfNoValue(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowAnyOtherSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowAnyOtherSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    
    setWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfSetWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfNotSetWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfNotSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    ignoreIfSetWhen<COLUMNS extends ColumnsForSetOf<TABLE>>(when: boolean, ...columns: COLUMNS[]): MaybeExecutableInsertExpression<TABLE, USING, COLUMNS & RequiredColumnsForSetOf<TABLE>>
    keepOnlyWhen<COLUMNS extends ColumnsForSetOf<TABLE>>(when: boolean, ...columns: COLUMNS[]): MaybeExecutableInsertExpression<TABLE, USING, Exclude<RequiredColumnsForSetOf<TABLE>, COLUMNS>>

    setIfHasValueWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfHasValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfHasNoValueWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfHasNoValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    ignoreIfHasValueWhen(when: boolean, ...columns: OptionalColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    ignoreIfHasNoValueWhen(when: boolean, ...columns: OptionalColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    ignoreAnySetWithNoValueWhen(when: boolean): ExecutableInsertExpression<TABLE, USING>

    disallowIfSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfNotSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfNotSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfNoValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowIfNoValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowAnyOtherSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
    disallowAnyOtherSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE, USING>
}

export interface ShapedExecutableInsertExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE> extends CustomizableExecutableSimpleInsert<TABLE, USING, SHAPE> {
    extendShape<EXTEND_SHAPE extends InsertShape<TABLE, USING>>(shape: EXTEND_SHAPE): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE & ResolveShape<TABLE, EXTEND_SHAPE>, keyof EXTEND_SHAPE, never>
    set(columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfValue(columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfSet(columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfSetIfValue(columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfNotSet(columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfNotSetIfValue(columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    ignoreIfSet<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, COLUMNS & RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, never>
    keepOnly<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, COLUMNS>, never>

    setIfHasValue(columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfHasValueIfValue(columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfHasNoValue(columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfHasNoValueIfValue(columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    ignoreAnySetWithNoValue(): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>

    disallowIfSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfNotSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfNotSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfValue(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfValue(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfNoValue(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfNoValue(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowAnyOtherSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowAnyOtherSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>

    setWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfSetWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfNotSetWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfNotSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    ignoreIfSetWhen<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(when: boolean, ...columns: COLUMNS[]): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, COLUMNS & RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, never>
    keepOnlyWhen<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(when: boolean, ...columns: COLUMNS[]): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, COLUMNS>, never>

    setIfHasValueWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfHasValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfHasNoValueWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    setIfHasNoValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    ignoreIfHasValueWhen(when: boolean, ...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    ignoreIfHasNoValueWhen(when: boolean, ...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    ignoreAnySetWithNoValueWhen(when: boolean): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>

    disallowIfSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfNotSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfNotSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfNoValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowIfNoValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowAnyOtherSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
    disallowAnyOtherSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
}

export interface MissingKeysInsertExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ MISSING_KEYS> extends InsertExpressionBase<TABLE, USING> {
    set<COLUMNS extends InsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setIfSet<COLUMNS extends InsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setIfSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setIfNotSet<COLUMNS extends InsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setIfNotSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    ignoreIfSet<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MissingKeysInsertExpression<TABLE, USING, (COLUMNS & RequiredColumnsForSetOf<TABLE>) | MISSING_KEYS>
    keepOnly<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MissingKeysInsertExpression<TABLE, USING, Exclude<RequiredColumnsForSetOf<TABLE>, COLUMNS> | MISSING_KEYS>
    
    setIfHasValue<COLUMNS extends InsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setIfHasValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setIfHasNoValue<COLUMNS extends InsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setIfHasNoValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    ignoreAnySetWithNoValue(): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>

    disallowIfSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNotSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNotSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfValue(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfValue(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNoValue<COLUMNS extends ColumnsForSetOf<TABLE>>(errorMessage: string, ...columns: COLUMNS[]): MissingKeysInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, COLUMNS>>
    disallowIfNoValue<COLUMNS extends ColumnsForSetOf<TABLE>>(error: Error, ...columns:COLUMNS[]): MissingKeysInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, COLUMNS>>
    disallowAnyOtherSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowAnyOtherSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>

    setWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    setIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    setIfSetWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    setIfSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    setIfNotSetWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    setIfNotSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    ignoreIfSetWhen<COLUMNS extends ColumnsForSetOf<TABLE>>(when: boolean, ...columns: COLUMNS[]): MissingKeysInsertExpression<TABLE, USING, (COLUMNS & RequiredColumnsForSetOf<TABLE>) | MISSING_KEYS>
    keepOnlyWhen<COLUMNS extends ColumnsForSetOf<TABLE>>(when: boolean, ...columns: COLUMNS[]): MissingKeysInsertExpression<TABLE, USING, Exclude<RequiredColumnsForSetOf<TABLE> | MISSING_KEYS, COLUMNS>>

    setIfHasValueWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    setIfHasValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    setIfHasNoValueWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    setIfHasNoValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    ignoreIfHasValueWhen(when: boolean, ...columns: OptionalColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    ignoreIfHasNoValueWhen(when: boolean, ...columns: OptionalColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    ignoreAnySetWithNoValueWhen(when: boolean): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>

    disallowIfSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNotSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNotSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNoValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNoValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowAnyOtherSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowAnyOtherSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>
}

export interface ShapedMissingKeysInsertExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE, /*in|out*/ MISSING_KEYS, /*in|out*/ MISSING_KEYS_IN_SHAPE> extends InsertExpressionBase<TABLE, USING> {
    extendShape<EXTEND_SHAPE extends InsertShape<TABLE, USING>>(shape: EXTEND_SHAPE): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE & ResolveShape<TABLE, EXTEND_SHAPE>, MISSING_KEYS | keyof EXTEND_SHAPE, Exclude<MISSING_KEYS_IN_SHAPE, EXTEND_SHAPE[keyof EXTEND_SHAPE]>>
    set<COLUMNS extends InsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setIfSet<COLUMNS extends InsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setIfSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setIfNotSet<COLUMNS extends InsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setIfNotSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    ignoreIfSet<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, (COLUMNS & RequiredColumnsForSetOfWithShape<TABLE, SHAPE>) | MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    keepOnly<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, COLUMNS> | MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    
    setIfHasValue<COLUMNS extends InsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setIfHasValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setIfHasNoValue<COLUMNS extends InsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setIfHasNoValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreAnySetWithNoValue(): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>

    disallowIfSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNotSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNotSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfValue(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfValue(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNoValue<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(errorMessage: string, ...columns: COLUMNS[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, COLUMNS>, MISSING_KEYS_IN_SHAPE>
    disallowIfNoValue<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(error: Error, ...columns: COLUMNS[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, COLUMNS>, MISSING_KEYS_IN_SHAPE>
    disallowAnyOtherSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowAnyOtherSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>

    setWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setIfSetWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setIfSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setIfNotSetWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setIfNotSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreIfSetWhen<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(when: boolean, ...columns: COLUMNS[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, (COLUMNS & RequiredColumnsForSetOfWithShape<TABLE, SHAPE>) | MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    keepOnlyWhen<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(when: boolean, ...columns: COLUMNS[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE> | MISSING_KEYS, COLUMNS>, MISSING_KEYS_IN_SHAPE>

    setIfHasValueWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setIfHasValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setIfHasNoValueWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setIfHasNoValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreIfHasValueWhen(when: boolean, ...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreIfHasNoValueWhen(when: boolean, ...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreAnySetWithNoValueWhen(when: boolean): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>

    disallowIfSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNotSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNotSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNoValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNoValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowAnyOtherSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowAnyOtherSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
}

export interface ExecutableMultipleInsertExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> extends CustomizableExecutableMultipleInsert<TABLE, USING, undefined> {
    setForAll(columns: InsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfValue(columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfSet(columns: InsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfSetIfValue(columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfNotSet(columns: InsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfNotSetIfValue(columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    ignoreIfSet<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MaybeExecutableMultipleInsertExpression<TABLE, USING, COLUMNS & RequiredColumnsForSetOf<TABLE>>
    keepOnly<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<RequiredColumnsForSetOf<TABLE>, COLUMNS>>

    setForAllIfHasValue(columns: InsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfHasValueIfValue(columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfHasNoValue(columns: InsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfHasNoValueIfValue(columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    ignoreAnySetWithNoValue(): ExecutableMultipleInsertExpression<TABLE, USING>

    disallowIfSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfNotSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfNotSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfValue(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfValue(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfNoValue(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfNoValue(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowAnyOtherSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowAnyOtherSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>

    setForAllWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfSetWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfNotSetWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfNotSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    ignoreIfSetWhen<COLUMNS extends ColumnsForSetOf<TABLE>>(when: boolean, ...columns: COLUMNS[]): MaybeExecutableMultipleInsertExpression<TABLE, USING, COLUMNS & RequiredColumnsForSetOf<TABLE>>
    keepOnlyWhen<COLUMNS extends ColumnsForSetOf<TABLE>>(when: boolean, ...columns: COLUMNS[]): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<RequiredColumnsForSetOf<TABLE>, COLUMNS>>

    setForAllIfHasValueWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfHasValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfHasNoValueWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    setForAllIfHasNoValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): ExecutableMultipleInsertExpression<TABLE, USING>
    ignoreIfHasValueWhen(when: boolean, ...columns: OptionalColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    ignoreIfHasNoValueWhen(when: boolean, ...columns: OptionalColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    ignoreAnySetWithNoValueWhen(when: boolean): ExecutableMultipleInsertExpression<TABLE, USING>

    disallowIfSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfNotSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfNotSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfNoValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowIfNoValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowAnyOtherSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
    disallowAnyOtherSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE, USING>
}

export interface ShapedExecutableMultipleInsertExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE> extends CustomizableExecutableMultipleInsert<TABLE, USING, SHAPE> {
    extendShape<EXTEND_SHAPE extends InsertShape<TABLE, USING>>(shape: EXTEND_SHAPE): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE & ResolveShape<TABLE, EXTEND_SHAPE>, keyof EXTEND_SHAPE, never>
    setForAll(columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfValue(columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfSet(columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfSetIfValue(columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfNotSet(columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfNotSetIfValue(columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    ignoreIfSet<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, COLUMNS & RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, never>
    keepOnly<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, COLUMNS>, never>

    setForAllIfHasValue(columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfHasValueIfValue(columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfHasNoValue(columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfHasNoValueIfValue(columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    ignoreAnySetWithNoValue(): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>

    disallowIfSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfNotSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfNotSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfValue(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfValue(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfNoValue(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfNoValue(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowAnyOtherSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowAnyOtherSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>

    setForAllWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfSetWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfNotSetWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfNotSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    ignoreIfSetWhen<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(when: boolean, ...columns: COLUMNS[]): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, COLUMNS & RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, never>
    keepOnlyWhen<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(when: boolean, ...columns: COLUMNS[]): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, COLUMNS>, never>

    setForAllIfHasValueWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfHasValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfHasNoValueWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    setForAllIfHasNoValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    ignoreIfHasValueWhen(when: boolean, ...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    ignoreIfHasNoValueWhen(when: boolean, ...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    ignoreAnySetWithNoValueWhen(when: boolean): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>

    disallowIfSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfNotSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfNotSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfNoValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowIfNoValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowAnyOtherSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
    disallowAnyOtherSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE>
}

export interface MissingKeysMultipleInsertExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ MISSING_KEYS> extends InsertExpressionBase<TABLE, USING> {
    setForAll<COLUMNS extends InsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setForAllIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setForAllIfSet<COLUMNS extends InsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setForAllIfSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setForAllIfNotSet<COLUMNS extends InsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setForAllIfNotSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    ignoreIfSet<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MissingKeysMultipleInsertExpression<TABLE, USING, (COLUMNS & RequiredColumnsForSetOf<TABLE>) | MISSING_KEYS>
    keepOnly<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MissingKeysMultipleInsertExpression<TABLE, USING, Exclude<RequiredColumnsForSetOf<TABLE>, COLUMNS> | MISSING_KEYS>
    
    setForAllIfHasValue<COLUMNS extends InsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setForAllIfHasValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setForAllIfHasNoValue<COLUMNS extends InsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    setForAllIfHasNoValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    ignoreAnySetWithNoValue(): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>

    disallowIfSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNotSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNotSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfValue(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfValue(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNoValue<COLUMNS extends ColumnsForSetOf<TABLE>>(errorMessage: string, ...columns: COLUMNS[]): MissingKeysMultipleInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, COLUMNS>>
    disallowIfNoValue<COLUMNS extends ColumnsForSetOf<TABLE>>(error: Error, ...columns: COLUMNS[]): MissingKeysMultipleInsertExpression<TABLE, USING, Exclude<MISSING_KEYS, COLUMNS>>
    disallowAnyOtherSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowAnyOtherSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>

    setForAllWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    setForAllIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    setForAllIfSetWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    setForAllIfSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    setForAllIfNotSetWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    setForAllIfNotSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    ignoreIfSetWhen<COLUMNS extends ColumnsForSetOf<TABLE>>(when: boolean, ...columns: COLUMNS[]): MissingKeysMultipleInsertExpression<TABLE, USING, (COLUMNS & RequiredColumnsForSetOf<TABLE>) | MISSING_KEYS>
    keepOnlyWhen<COLUMNS extends ColumnsForSetOf<TABLE>>(when: boolean, ...columns: COLUMNS[]): MissingKeysMultipleInsertExpression<TABLE, USING, Exclude<RequiredColumnsForSetOf<TABLE>, COLUMNS> | MISSING_KEYS>

    setForAllIfHasValueWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    setForAllIfHasValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    setForAllIfHasNoValueWhen(when: boolean, columns: InsertSets<TABLE, USING, undefined>): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    setForAllIfHasNoValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, undefined>): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    ignoreIfHasValueWhen(when: boolean, ...columns: OptionalColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    ignoreIfHasNoValueWhen(when: boolean, ...columns: OptionalColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    ignoreAnySetWithNoValueWhen(when: boolean): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>

    disallowIfSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNotSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNotSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNoValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowIfNoValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowAnyOtherSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
    disallowAnyOtherSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>
}

export interface ShapedMissingKeysMultipleInsertExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE, /*in|out*/ MISSING_KEYS, /*in|out*/ MISSING_KEYS_IN_SHAPE> extends InsertExpressionBase<TABLE, USING> {
    extendShape<EXTEND_SHAPE extends InsertShape<TABLE, USING>>(shape: EXTEND_SHAPE): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE & ResolveShape<TABLE, EXTEND_SHAPE>, MISSING_KEYS | keyof EXTEND_SHAPE, Exclude<MISSING_KEYS_IN_SHAPE, EXTEND_SHAPE[keyof EXTEND_SHAPE]>>
    setForAll<COLUMNS extends InsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setForAllIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setForAllIfSet<COLUMNS extends InsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setForAllIfSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setForAllIfNotSet<COLUMNS extends InsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setForAllIfNotSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    ignoreIfSet<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, (COLUMNS & RequiredColumnsForSetOfWithShape<TABLE, SHAPE>) | MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    keepOnly<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, COLUMNS> | MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    
    setForAllIfHasValue<COLUMNS extends InsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setForAllIfHasValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setForAllIfHasNoValue<COLUMNS extends InsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setForAllIfHasNoValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreAnySetWithNoValue(): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>

    disallowIfSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNotSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNotSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfValue(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfValue(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNoValue<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(errorMessage: string, ...columns: COLUMNS[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, COLUMNS>, MISSING_KEYS_IN_SHAPE>
    disallowIfNoValue<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(error: Error, ...columns: COLUMNS[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<MISSING_KEYS, COLUMNS>, MISSING_KEYS_IN_SHAPE>
    disallowAnyOtherSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowAnyOtherSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>

    setForAllWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setForAllIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setForAllIfSetWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setForAllIfSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setForAllIfNotSetWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setForAllIfNotSetIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreIfSetWhen<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(when: boolean, ...columns: COLUMNS[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, (COLUMNS & RequiredColumnsForSetOfWithShape<TABLE, SHAPE>) | MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    keepOnlyWhen<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(when: boolean, ...columns: COLUMNS[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, COLUMNS> | MISSING_KEYS, MISSING_KEYS_IN_SHAPE>

    setForAllIfHasValueWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setForAllIfHasValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setForAllIfHasNoValueWhen(when: boolean, columns: InsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    setForAllIfHasNoValueIfValueWhen(when: boolean, columns: OptionalInsertSets<TABLE, USING, SHAPE>): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreIfHasValueWhen(when: boolean, ...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreIfHasNoValueWhen(when: boolean, ...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreAnySetWithNoValueWhen(when: boolean): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>

    disallowIfSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNotSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNotSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNoValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowIfNoValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowAnyOtherSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    disallowAnyOtherSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
}

export interface InsertExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>> extends InsertExpressionBase<TABLE, USING> {
    shapedAs<SHAPE extends InsertShape<TABLE, USING>>(shape: SHAPE): ShapedInsertExpression<TABLE, USING, ResolveShape<TABLE, SHAPE>, Exclude<RequiredColumnsForSetOf<TABLE>, SHAPE[keyof SHAPE]>>
    dynamicSet(): MissingKeysInsertExpression<TABLE, USING, RequiredColumnsForSetOf<TABLE>>
    dynamicSet<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, USING, Exclude<RequiredColumnsForSetOf<TABLE>, NonOptionalKeys<COLUMNS>>>
    set(columns: MandatoryInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    setIfValue(columns: MandatoryOptionalInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    values(columns: Array<MandatoryInsertSets<TABLE, USING, undefined>>): CustomizableExecutableMultipleInsert<TABLE, USING, undefined>
    values(columns: MandatoryInsertSets<TABLE, USING, undefined>): ExecutableInsertExpression<TABLE, USING>
    dynamicValues<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: Array<COLUMNS>): MaybeExecutableMultipleInsertExpression<TABLE, USING, Exclude<RequiredColumnsForSetOf<TABLE>, NonOptionalKeys<COLUMNS>>>
    dynamicValues<COLUMNS extends OptionalInsertSets<TABLE, USING, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, USING, Exclude<RequiredColumnsForSetOf<TABLE>, NonOptionalKeys<COLUMNS>>>
    defaultValues: DefaultValueType<TABLE, USING>
    from(select: IExecutableSelectQuery<USING[typeof source], SelectForInsertColumns<TABLE, USING>, SelectForInsertResultType<TABLE, USING>>): CustomizableExecutableInsertFromSelect<TABLE, USING, undefined>
}

export interface ShapedInsertExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE, /*in|out*/ MISSING_KEYS_IN_SHAPE> extends InsertExpressionBase<TABLE, USING> {
    extendShape<EXTEND_SHAPE extends InsertShape<TABLE, USING>>(shape: EXTEND_SHAPE): ShapedInsertExpression<TABLE, USING, SHAPE & ResolveShape<TABLE, EXTEND_SHAPE>, Exclude<MISSING_KEYS_IN_SHAPE, EXTEND_SHAPE[keyof EXTEND_SHAPE]>>
    dynamicSet(): ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, MISSING_KEYS_IN_SHAPE>
    dynamicSet<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    set<COLUMNS extends MandatoryInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    setIfValue<COLUMNS extends MandatoryInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    values<COLUMNS extends MandatoryInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    values<COLUMNS extends MandatoryInsertSets<TABLE, USING, SHAPE>>(columns: Array<COLUMNS>): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    dynamicValues<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: Array<COLUMNS>): MaybeShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
    dynamicValues<COLUMNS extends OptionalInsertSets<TABLE, USING, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, USING, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, NonOptionalKeys<COLUMNS>>, MISSING_KEYS_IN_SHAPE>
}




export interface ExecutableInsertReturning</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ COLUMNS, /*in|out*/ RESULT> extends InsertExpressionBase<TABLE, USING>, IExecutableInsertQuery<NNoTableOrViewRequiredFrom<TABLE[typeof source]>, RESULT> {
    executeInsertNoneOrOne(): Promise<( COLUMNS extends AnyValueSource ? RESULT : { [P in keyof RESULT]: RESULT[P] }) | null>
    executeInsertOne(): Promise<( COLUMNS extends AnyValueSource ? RESULT : { [P in keyof RESULT]: RESULT[P] })>
    executeInsertMany(min?: number, max?: number): Promise<( COLUMNS extends AnyValueSource ? RESULT : { [P in keyof RESULT]: RESULT[P] })[]>

    query(): string
    params(): any[]
}

export interface ComposableCustomizableExecutableInsert</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ COLUMNS, /*in|out*/ RESULT> extends ExecutableInsertReturning<TABLE, USING, COLUMNS, RESULT> {
    customizeQuery(customization: InsertCustomization<TABLE, USING>): ExecutableInsertReturning<TABLE, USING, COLUMNS, RESULT>
}

export interface ComposableCustomizableExecutableInsertProjectableAsNullable</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ COLUMNS> extends ComposableCustomizableExecutableInsert<TABLE, USING, COLUMNS, ResultObjectValues<COLUMNS>> {
    projectingOptionalValuesAsNullable(): ComposableCustomizableExecutableInsert<TABLE, USING, COLUMNS, ResultObjectValuesProjectedAsNullable<COLUMNS>>
}









export interface ExecutableInsertReturningOptional</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ COLUMNS, /*in|out*/ RESULT> extends InsertExpressionBase<TABLE, USING>, IExecutableInsertQuery<NNoTableOrViewRequiredFrom<TABLE[typeof source]>, RESULT> {
    executeInsertNoneOrOne(): Promise<( COLUMNS extends AnyValueSource ? RESULT : { [P in keyof RESULT]: RESULT[P] }) | null>
    executeInsertMany(min?: number, max?: number): Promise<( COLUMNS extends AnyValueSource ? RESULT : { [P in keyof RESULT]: RESULT[P] })[]>

    query(): string
    params(): any[]
}

export interface ComposableCustomizableExecutableInsertOptional</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, COLUMNS, RESULT> extends ExecutableInsertReturningOptional<TABLE, USING, COLUMNS, RESULT> {
    customizeQuery(customization: InsertCustomization<TABLE, USING>): ExecutableInsertReturningOptional<TABLE, USING, COLUMNS, RESULT>
}

export interface ComposableCustomizableExecutableInsertOptionalProjectableAsNullable</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, COLUMNS> extends ComposableCustomizableExecutableInsertOptional<TABLE, USING, COLUMNS, ResultObjectValues<COLUMNS>> {
    projectingOptionalValuesAsNullable(): ComposableCustomizableExecutableInsertOptional<TABLE, USING, COLUMNS, ResultObjectValuesProjectedAsNullable<COLUMNS>>
}







type ReturningFnType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlServer' | 'sqlite' | 'mariaDB' | 'oracle'>
    ? <COLUMNS extends InsertReturningColumns<USING[typeof source]>>(columns: COLUMNS) => ComposableCustomizableExecutableInsertProjectableAsNullable<TABLE, USING, COLUMNS>
    : never

type ReturningOneColumnFnType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlServer' | 'sqlite' | 'mariaDB' | 'oracle'>
    ? <COLUMN extends ValueSourceOf<USING[typeof source]>>(column: COLUMN) => ComposableCustomizableExecutableInsert<TABLE, USING, COLUMN, ValueSourceValueTypeForResult<COLUMN>>
    : never

type ReturningFromSelectFnType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlServer' | 'sqlite' | 'mariaDB'>
    ? <COLUMNS extends InsertReturningColumns<USING[typeof source]>>(columns: COLUMNS) => ComposableCustomizableExecutableInsertProjectableAsNullable<TABLE, USING, COLUMNS>
    : never

type ReturningOneColumnFromSelectFnType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlServer' | 'sqlite' | 'mariaDB'>
    ? <COLUMN extends ValueSourceOf<USING[typeof source]>>(column: COLUMN) => ComposableCustomizableExecutableInsert<TABLE, USING, COLUMN, ValueSourceValueTypeForResult<COLUMN>>
    : never

type ReturningMultipleLastInsertedIdType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlServer' | 'sqlite' | 'mariaDB' | 'oracle'>
    ? [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () => CustomizableExecutableInsertReturningLastInsertedId<TABLE, USING, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>[]>
    : never

type ReturningLastInsertedIdType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, USING, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>>

type OnConflictReturningLastInsertedIdType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' /*| 'sqlServer' | 'oracle' not suported yet*/ | 'sqlite' | 'mariaDB'>
    ? [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, USING, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>>
    : never

type ReturningLastInsertedIdFromSelectType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlServer' | 'sqlite' | 'mariaDB'>
    ? [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, USING, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>[]>
    : never




type ReturningOptionalFnType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlServer' | 'sqlite' | 'mariaDB' | 'oracle'>
    ? <COLUMNS extends InsertReturningColumns<USING[typeof source]>>(columns: COLUMNS) => ComposableCustomizableExecutableInsertOptionalProjectableAsNullable<TABLE, USING, COLUMNS>
    : never

type ReturningOneColumnOptionalFnType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlServer' | 'sqlite' | 'mariaDB' | 'oracle'>
    ? <COLUMN extends ValueSourceOf<USING[typeof source]>>(column: COLUMN) => ComposableCustomizableExecutableInsertOptional<TABLE, USING, COLUMN, ValueSourceValueTypeForResult<COLUMN>>
    : never

type ReturningFromSelectOptionalFnType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlServer' | 'sqlite' | 'mariaDB'>
    ? <COLUMNS extends InsertReturningColumns<USING[typeof source]>>(columns: COLUMNS) => ComposableCustomizableExecutableInsertOptionalProjectableAsNullable<TABLE, USING, COLUMNS>
    : never

type ReturningOneColumnFromSelectOptionalFnType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlServer' | 'sqlite' | 'mariaDB'>
    ? <COLUMN extends ValueSourceOf<USING[typeof source]>>(column: COLUMN) => ComposableCustomizableExecutableInsertOptional<TABLE, USING, COLUMN, ValueSourceValueTypeForResult<COLUMN>>
    : never

type ReturningMultipleLastInsertedIdOptionalType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlServer' | 'sqlite' | 'mariaDB' | 'oracle'>
    ? [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, USING, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>[]>
    : never

type OnConflictReturningLastInsertedIdOptionalType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' /*| 'sqlServer' | 'oracle' not suported yet*/ | 'sqlite' | 'mariaDB'>
    ? [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, USING, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE> | null>
    : never

type ReturningLastInsertedIdFromSelectOptionalType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlServer' | 'sqlite' | 'mariaDB'>
    ? [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, USING, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>[]>
    : never





export interface InsertOnConflictSetsExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ NEXT, /*in|out*/ NEXT_WHERE> {
    set(columns: OnConflictUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfSet(columns: OnConflictUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfSetIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfNotSet(columns: OnConflictUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfNotSetIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    ignoreIfSet(...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    keepOnly(...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT

    setIfHasValue(columns: OnConflictUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfHasValueIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfHasNoValue(columns: OnConflictUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfHasNoValueIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    ignoreIfHasValue(...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    ignoreIfHasNoValue(...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    ignoreAnySetWithNoValue(): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT

    disallowIfSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfNotSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfNotSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfValue(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfValue(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfNoValue(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfNoValue(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowAnyOtherSet(errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowAnyOtherSet(error: Error, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT

    setWhen(when: boolean, columns: OnConflictUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfValueWhen(when: boolean, olumns: OnConflictOptionalUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfSetWhen(when: boolean, columns: OnConflictUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfSetIfValueWhen(when: boolean, columns: OnConflictOptionalUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfNotSetWhen(when: boolean, columns: OnConflictUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfNotSetIfValueWhen(when: boolean, columns: OnConflictOptionalUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    ignoreIfSetWhen(when: boolean, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    keepOnlyWhen(when: boolean, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT

    setIfHasValueWhen(when: boolean, columns: OnConflictUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfHasValueIfValueWhen(when: boolean, columns: OnConflictOptionalUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfHasNoValueWhen(when: boolean, columns: OnConflictUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    setIfHasNoValueIfValueWhen(when: boolean, columns: OnConflictOptionalUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    ignoreIfHasValueWhen(when: boolean, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    ignoreIfHasNoValueWhen(when: boolean, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    ignoreAnySetWithNoValueWhen(when: boolean): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT

    disallowIfSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfNotSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfNotSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfNoValueWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowIfNoValueWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowAnyOtherSetWhen(when: boolean, errorMessage: string, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    disallowAnyOtherSetWhen(when: boolean, error: Error, ...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT

    dynamicWhere: OnConflictDoUpdateDynamicWhereFnType<TABLE, USING, NEXT_WHERE>
    where: OnConflictDoUpdateWhereFnType<TABLE, USING, NEXT_WHERE>
}

export interface ShapedInsertOnConflictSetsExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE, NEXT, /*in|out*/ NEXT_WHERE> {
    extendShape<EXTEND_SHAPE extends InsertShape<TABLE, USING>>(shape: EXTEND_SHAPE): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE & ResolveShape<TABLE, EXTEND_SHAPE>, NEXT, NEXT_WHERE>
    set(columns: OnConflictUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfSet(columns: OnConflictUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfSetIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfNotSet(columns: OnConflictUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfNotSetIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    ignoreIfSet(...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    keepOnly(...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT

    setIfHasValue(columns: OnConflictUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfHasValueIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfHasNoValue(columns: OnConflictUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfHasNoValueIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    ignoreIfHasValue(...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    ignoreIfHasNoValue(...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    ignoreAnySetWithNoValue(): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT

    disallowIfSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfNotSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfNotSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfValue(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfValue(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfNoValue(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfNoValue(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowAnyOtherSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowAnyOtherSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT

    set(columns: OnConflictUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfSet(columns: OnConflictUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfSetIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfNotSet(columns: OnConflictUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfNotSetIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    ignoreIfSet(...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    keepOnly(...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT

    setIfHasValue(columns: OnConflictUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfHasValueIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfHasNoValue(columns: OnConflictUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfHasNoValueIfValue(columns: OnConflictOptionalUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    ignoreIfHasValue(...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    ignoreIfHasNoValue(...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    ignoreAnySetWithNoValue(): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT

    disallowIfSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfNotSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfNotSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfValue(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfValue(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfNoValue(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowIfNoValue(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowAnyOtherSet(errorMessage: string, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    disallowAnyOtherSet(error: Error, ...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT

    dynamicWhere: OnConflictDoUpdateDynamicWhereFnType<TABLE, USING, NEXT_WHERE>
    where: OnConflictDoUpdateWhereFnType<TABLE, USING, NEXT_WHERE>
}

export interface DynamicOnConflictWhereExpression</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, NEXT> {
    and(condition: IAnyBooleanValueSource<USING[typeof source], any>): DynamicOnConflictWhereExpression<TABLE, USING,  NEXT> & NEXT
    or(condition: IAnyBooleanValueSource<USING[typeof source], any>): DynamicOnConflictWhereExpression<TABLE, USING,  NEXT> & NEXT
}

export interface OnConflictOnColumnWhere</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, NEXT> {
    dynamicWhere() : DynamicOnConflictWhereExpression<TABLE, USING,  NEXT> & NEXT
    where(condition: IAnyBooleanValueSource<USING[typeof source], any>): DynamicOnConflictWhereExpression<TABLE, USING,  NEXT> & NEXT
}

type OnConflictDoNothingFnType<TABLE extends HasSource<any>, _USING extends HasSource<any>, NEXT> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlite' | 'mariaDB' | 'mySql'>
    ? () => NEXT
    : never

type OnConflictDoUpdateDynamicSetFn</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ NEXT, /*in|out*/ NEXT_WHERE> = {
    (): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    (columns: OnConflictUpdateSets<TABLE, USING, undefined>): InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
}

type ShapedOnConflictDoUpdateDynamicSetFn</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ SHAPE, /*in|out*/ NEXT, /*in|out*/ NEXT_WHERE> = {
    (): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
    (columns: OnConflictUpdateSets<TABLE, USING, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, USING, SHAPE, NEXT, NEXT_WHERE> & NEXT
}

type OnConflictDoUpdateDynamicSetFnType<TABLE extends HasSource<any>, USING extends HasSource<any>, SHAPE, NEXT, NEXT_WHERE> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlite' | 'mariaDB' | 'mySql'>
    ? (
        SHAPE extends ResolvedShape<any>
        ? ShapedOnConflictDoUpdateDynamicSetFn<TABLE, USING, SHAPE, NEXT, NEXT_WHERE>
        : OnConflictDoUpdateDynamicSetFn<TABLE, USING, NEXT, NEXT_WHERE>
    )
    : never

type OnConflictDoUpdateSetFnType<TABLE extends HasSource<any>, USING extends HasSource<any>, SHAPE, NEXT, NEXT_WHERE> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlite' | 'mariaDB' | 'mySql'>
    ? (columns: OnConflictUpdateSets<TABLE, USING, SHAPE>) => InsertOnConflictSetsExpression<TABLE, USING, NEXT, NEXT_WHERE> & NEXT
    : never

type OnConflictDoUpdateDynamicWhereFnType<TABLE extends HasSource<any>, USING extends HasSource<any>, NEXT> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlite'>
    ? () => DynamicOnConflictWhereExpression<TABLE, USING,  NEXT> & NEXT
    : never

type OnConflictDoUpdateWhereFnType<TABLE extends HasSource<any>, USING extends HasSource<any>, NEXT> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlite'>
    ? OnConflictDoUpdateWhereFnTypeInterface<TABLE, USING, NEXT>
    : never

interface OnConflictDoUpdateWhereFnTypeInterface</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ USING extends HasSource<any>, /*in|out*/ NEXT> {
    (condition: IAnyBooleanValueSource<USING[typeof source], any>): DynamicOnConflictWhereExpression<TABLE, USING,  NEXT> & NEXT
}

type OnConflictOnColumnFnType<TABLE extends HasSource<any>, USING extends HasSource<any>, NEXT> =
    TABLE extends OfDB<'noopDB' | 'postgreSql' | 'sqlite'>
    ? (column: ValueSourceOf<USING[typeof source]>, ...columns: ValueSourceOf<USING[typeof source]>[]) => NEXT & OnConflictOnColumnWhere<TABLE, USING, NEXT>
    : never

type OnConflictOnConstraintFnType<TABLE extends HasSource<any>, USING extends HasSource<any>, NEXT> =
    TABLE extends OfDB<'noopDB' | 'postgreSql'>
    ? OnConflictOnConstraintFnTypeInterface<TABLE, USING, NEXT>
    : never

interface OnConflictOnConstraintFnTypeInterface</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ _USING extends HasSource<any>, NEXT> {
    (constraint: string): NEXT
    (constraint: IStringValueSource<NNoTableOrViewRequiredFrom<TABLE[typeof source]>, 'required'>): NEXT
    (constraint: RawFragment<NNoTableOrViewRequiredFrom<TABLE[typeof source]>>): NEXT
}







export type InsertReturningColumns</*in|out*/ SOURCE extends NSource> = DataToProject<SOURCE>







type DefaultValueType<TABLE extends HasSource<any>, USING extends HasSource<any>> =
    unknown extends TABLE ? () => CustomizableExecutableSimpleInsertOnConflict<TABLE, USING> : // this is the case when TABLE is any
    [RequiredColumnsForSetOf<TABLE>] extends [never] ? () => CustomizableExecutableSimpleInsertOnConflict<TABLE, USING> : never

type MaybeExecutableInsertExpression<TABLE extends HasSource<any>, USING extends HasSource<any>, MISSING_KEYS> =
    [MISSING_KEYS] extends [never] ? ExecutableInsertExpression<TABLE, USING> :  MissingKeysInsertExpression<TABLE, USING, MISSING_KEYS>

type MaybeShapedExecutableInsertExpression<TABLE extends HasSource<any>, USING extends HasSource<any>, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE> =
    [MISSING_KEYS] extends [never] 
    ? (
        [MISSING_KEYS_IN_SHAPE] extends [never] 
        ? ShapedExecutableInsertExpression<TABLE, USING, SHAPE>
        : ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ) : ShapedMissingKeysInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>

type MaybeExecutableMultipleInsertExpression<TABLE extends HasSource<any>, USING extends HasSource<any>, MISSING_KEYS> =
    [MISSING_KEYS] extends [never] ? ExecutableMultipleInsertExpression<TABLE, USING> :  MissingKeysMultipleInsertExpression<TABLE, USING, MISSING_KEYS>

type MaybeShapedExecutableMultipleInsertExpression<TABLE extends HasSource<any>, USING extends HasSource<any>, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE> =
    [MISSING_KEYS] extends [never] 
    ? (
        [MISSING_KEYS_IN_SHAPE] extends [never] 
        ? ShapedExecutableMultipleInsertExpression<TABLE, USING, SHAPE> 
        : ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ) : ShapedMissingKeysMultipleInsertExpression<TABLE, USING, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>

type SelectForInsertResultType<TABLE extends HasSource<any>, _USING extends HasSource<any>> = {
    [P in RequiredColumnsForSetOf<TABLE>]: ValueSourceValueType<TABLE[P]>
} & {
    [P in OptionalColumnsForSetOf<TABLE>]?: ValueSourceValueType<TABLE[P]>
}

type SelectForInsertColumns<TABLE extends HasSource<any>, _USING extends HasSource<any>> = {
    [P in RequiredColumnsForSetOf<TABLE>]: RemapIValueSourceType<any, TABLE[P]>
} & {
    [P in OptionalColumnsForSetOf<TABLE>]?: RemapIValueSourceTypeWithOptionalType<any, TABLE[P], any>
}

export type InsertShape</*in|out*/ TABLE extends HasSource<any>, /*in|out*/ _USING extends HasSource<any>> = {
    [key: string]: ColumnsForSetOf<TABLE>
}
export type InsertShapeContent</*in|out*/ TABLE extends HasSource<any>> = {
    [key: string]: ColumnsForSetOf<TABLE>
}

type NonOptionalKeys<T> = MandatoryPropertiesOf<T>

export type InsertSets<TABLE extends HasSource<any>, _USING extends HasSource<any>, SHAPE> = InsertSetsContent<TABLE, NNoTableOrViewRequiredFrom<TABLE[typeof source]>, SHAPE>
type InsertSetsContent<TABLE extends HasSource<any>, ALLOWING extends NSource, SHAPE> = 
    SHAPE extends ResolvedShape<any>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]?: InputTypeOfColumn<SHAPE, P, ALLOWING>
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: InputTypeOfOptionalColumn<SHAPE, P, ALLOWING>
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<TABLE>]?: InputTypeOfColumn<TABLE, P, ALLOWING>
        } & {
            [P in OptionalColumnsForSetOf<TABLE>]?: InputTypeOfOptionalColumn<TABLE, P, ALLOWING>
        }
    )

export type OptionalInsertSets<TABLE extends HasSource<any>, _USING extends HasSource<any>, SHAPE> = OptionalInsertSetsContent<TABLE, NNoTableOrViewRequiredFrom<TABLE[typeof source]>, SHAPE>
type OptionalInsertSetsContent<TABLE extends HasSource<any>, ALLOWING extends NSource, SHAPE> = 
    SHAPE extends ResolvedShape<any>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]?: InputTypeOfColumn<SHAPE, P, ALLOWING> | null | undefined
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: InputTypeOfOptionalColumn<SHAPE, P, ALLOWING> | null | undefined
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<TABLE>]?: InputTypeOfColumn<TABLE, P, ALLOWING> | null | undefined
        } & {
            [P in OptionalColumnsForSetOf<TABLE>]?: InputTypeOfOptionalColumn<TABLE, P, ALLOWING> | null | undefined
        }
    )

export type MandatoryInsertSets<TABLE extends HasSource<any>, _USING extends HasSource<any>, SHAPE> = MandatoryInsertSetsContent<TABLE, NNoTableOrViewRequiredFrom<TABLE[typeof source]>, SHAPE>
export type MandatoryInsertSetsContent<CONTAINER, ALLOWING extends NSource, SHAPE> = 
    SHAPE extends ResolvedShape<any>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]: InputTypeOfColumn<SHAPE, P, ALLOWING>
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: InputTypeOfOptionalColumn<SHAPE, P, ALLOWING>
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<CONTAINER>]: InputTypeOfColumn<CONTAINER, P, ALLOWING>
        } & {
            [P in OptionalColumnsForSetOf<CONTAINER>]?: InputTypeOfOptionalColumn<CONTAINER, P, ALLOWING>
        }
    )

export type MandatoryInsertValues<CONTAINER, SHAPE> = 
    SHAPE extends ResolvedShape<any>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]: ValueSourceValueType<SHAPE[P]>
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: ValueSourceValueType<SHAPE[P]>
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<CONTAINER>]: ValueSourceValueType<CONTAINER[P]>
        } & {
            [P in OptionalColumnsForSetOf<CONTAINER>]?: ValueSourceValueType<CONTAINER[P]>
        }
    )

type MandatoryOptionalInsertSets<TABLE extends HasSource<any>, _USING extends HasSource<any>, SHAPE> = MandatoryOptionalInsertSetsContent<TABLE, NNoTableOrViewRequiredFrom<TABLE[typeof source]>, SHAPE>
type MandatoryOptionalInsertSetsContent<TABLE extends HasSource<any>, ALLOWING extends NSource, SHAPE> = 
    SHAPE extends ResolvedShape<any>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]: InputTypeOfColumn<SHAPE, P, ALLOWING>
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: InputTypeOfOptionalColumn<SHAPE, P, ALLOWING> | null | undefined
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<TABLE>]: InputTypeOfColumn<TABLE, P, ALLOWING>
        } & {
            [P in OptionalColumnsForSetOf<TABLE>]?: InputTypeOfOptionalColumn<TABLE, P, ALLOWING> | null | undefined
        }
    )

type InputTypeOfColumn<CONTAINER, K extends ColumnsKeyOf<CONTAINER>, ALLOWING extends NSource> =
    CONTAINER[K] extends AnyValueSource ?
    (CONTAINER[K] extends WritableDBColumnWithDefaultValue ? (
        ValueSourceValueType<CONTAINER[K]> | RemapIValueSourceType<ALLOWING, CONTAINER[K]> | Default
    ) : (
        ValueSourceValueType<CONTAINER[K]> | RemapIValueSourceType<ALLOWING, CONTAINER[K]>
    ))
    : never

type InputTypeOfOptionalColumn<CONTAINER, K extends ColumnsKeyOf<CONTAINER>, ALLOWING extends NSource> =
    CONTAINER[K] extends AnyValueSource ?
    (CONTAINER[K] extends WritableDBColumnWithDefaultValue ? (
        ValueSourceValueType<CONTAINER[K]> | RemapIValueSourceTypeWithOptionalType<ALLOWING, CONTAINER[K], any> | Default
    ) : (
        ValueSourceValueType<CONTAINER[K]> | RemapIValueSourceTypeWithOptionalType<ALLOWING, CONTAINER[K], any>
    ))
    : never

export type OnConflictUpdateSets<TABLE extends HasSource<any>, USING extends HasSource<any>, SHAPE> = OnConflictUpdateSetsContent<TABLE, USING[typeof source] | NValuesForInsertFrom<TABLE[typeof source]>, SHAPE>
export type OnConflictUpdateSetsContent<CONTAINER, ALLOWING extends NSource, SHAPE> = 
    SHAPE extends ResolvedShape<any>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]?: OnConflictInputTypeOfColumn<SHAPE, P, ALLOWING>
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: OnConflictInputTypeOfOptionalColumn<SHAPE, P, ALLOWING>
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<CONTAINER>]?: OnConflictInputTypeOfColumn<CONTAINER, P, ALLOWING>
        } & {
            [P in OptionalColumnsForSetOf<CONTAINER>]?: OnConflictInputTypeOfOptionalColumn<CONTAINER, P, ALLOWING>
        }
    )

export type OnConflictUpdateValues<CONTAINER, SHAPE> = 
    SHAPE extends ResolvedShape<any>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]?: ValueSourceValueType<SHAPE[P]>
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: ValueSourceValueType<SHAPE[P]>
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<CONTAINER>]?: ValueSourceValueType<CONTAINER[P]>
        } & {
            [P in OptionalColumnsForSetOf<CONTAINER>]?: ValueSourceValueType<CONTAINER[P]>
        }
    )

type OnConflictOptionalUpdateSets<TABLE extends HasSource<any>, USING extends HasSource<any>, SHAPE> = OnConflictOptionalUpdateSetsContent<TABLE, USING[typeof source] | NValuesForInsertFrom<TABLE[typeof source]>, SHAPE>
type OnConflictOptionalUpdateSetsContent<TABLE extends HasSource<any>, ALLOWING extends NSource, SHAPE> = 
    SHAPE extends ResolvedShape<any>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]?: OnConflictInputTypeOfColumn<SHAPE, P, ALLOWING> | null | undefined
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: OnConflictInputTypeOfOptionalColumn<SHAPE, P, ALLOWING> | null | undefined
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<TABLE>]?: OnConflictInputTypeOfColumn<TABLE, P, ALLOWING> | null | undefined
        } & {
            [P in OptionalColumnsForSetOf<TABLE>]?: OnConflictInputTypeOfOptionalColumn<TABLE, P, ALLOWING> | null | undefined
        }
    )

type OnConflictInputTypeOfColumn<CONTAINER, K extends ColumnsKeyOf<CONTAINER>, ALLOWING extends NSource> =
    CONTAINER[K] extends AnyValueSource ?
    (CONTAINER[K] extends WritableDBColumnWithDefaultValue ? (
        ValueSourceValueType<CONTAINER[K]> | RemapIValueSourceType<ALLOWING, CONTAINER[K]> | Default
    ) : (
        ValueSourceValueType<CONTAINER[K]> | RemapIValueSourceType<ALLOWING, CONTAINER[K]>
    ))
    : never

type OnConflictInputTypeOfOptionalColumn<CONTAINER, K extends ColumnsKeyOf<CONTAINER>, ALLOWING extends NSource> =
    CONTAINER[K] extends AnyValueSource ?
    (CONTAINER[K] extends WritableDBColumnWithDefaultValue ? (
        ValueSourceValueType<CONTAINER[K]> | RemapIValueSourceTypeWithOptionalType<ALLOWING, CONTAINER[K], any> | Default
    ) : (
        ValueSourceValueType<CONTAINER[K]> | RemapIValueSourceTypeWithOptionalType<ALLOWING, CONTAINER[K], any>
    ))
    : never
