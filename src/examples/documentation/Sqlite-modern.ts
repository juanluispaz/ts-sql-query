import { SqliteConnection } from "../../connections/SqliteConnection"
import { DynamicCondition, dynamicPick } from "../../dynamicCondition"
import { extractColumnNamesFrom, extractColumnsFrom, extractWritableColumnNamesFrom, extractWritableColumnsFrom, mapForGuidedSplit, mergeType, prefixCapitalized, prefixDotted, prefixMapForGuidedSplitCapitalized, prefixMapForGuidedSplitDotted, prefixMapForSplitCapitalized, prefixMapForSplitDotted } from "../../extras/utils"
import { ConsoleLogQueryRunner } from "../../queryRunners/ConsoleLogQueryRunner"
import { MockQueryRunner } from "../../queryRunners/MockQueryRunner"
import { Table } from "../../Table"
import { CustomBooleanTypeAdapter } from "../../TypeAdapter"
import { Values } from "../../Values"
import { View } from "../../View"
import { assertEquals } from "../assertEquals"

class DBConnection extends SqliteConnection<'DBConnection'> {
    compatibilityMode = false
    // insesitiveCollation = 'acs'

    protected getDateTimeFormat() {
        return 'UTC as text using T separator and Z timezone' as const
    }

    bitwiseShiftLeft = this.buildFragmentWithArgs(
        this.arg('int', 'required'),
        this.arg('int', 'required')
    ).as((left, right) => {
        // The fragment here is: ${left} << ${right}
        // Could be another fragment like a function call: myFunction(${left}, ${right})
        return this.fragmentWithType('int', 'required').sql`${left} << ${right}`
    })

    valuePlusOneEqualsIfValue = this.buildFragmentWithArgsIfValue(
        this.arg('int', 'required'),
        this.valueArg('int', 'optional')
    ).as((left, right) => {
        // The fragment here is: ${left} + 1 = ${right}
        // Could be another fragment like a function call: myFunction(${left}, ${right})
        return this.fragmentWithType('boolean', 'required').sql`${left} + 1 = ${right}`
    })

    forSystemTimeBetween = this.createTableOrViewCustomization<Date, Date>((table, alias, fromDate, toDate) => {
        const from = this.const(fromDate, 'localDateTime')
        const to = this.const(toDate, 'localDateTime')
        return this.rawFragment`${table} for system_time between ${from} and ${to} ${alias}`
    })
}

const tCompany = new class TCompany extends Table<DBConnection, 'TCompany'> {
    id = this.autogeneratedPrimaryKey('id', 'int')
    name = this.column('name', 'string')
    parentId = this.optionalColumn('parent_id', 'int')
    favouriteCustomerId = this.optionalColumn('parent_id', 'int')
    ubicationLatitude = this.optionalColumn('ubication_latitude', 'string')
    ubicationLongitude = this.optionalColumn('ubication_longitude', 'string')
    ubicationComment = this.optionalColumn('ubication_comment', 'string')
    constructor() {
        super('company'); // table name in the database
    }
}()

const tCustomer = new class TCustomer extends Table<DBConnection, 'TCustomer'> {
    id = this.autogeneratedPrimaryKey('id', 'int')
    firstName = this.column('first_name', 'string')
    lastName = this.column('last_name', 'string')
    birthday = this.optionalColumn('birthday', 'localDate')
    companyId = this.column('company_id', 'int')
    name = this.firstName.concat(' ').concat(this.lastName)
    age = this.optionalVirtualColumnFromFragment('int', (fragment) => {
        return fragment.sql`calculateAge(${this.birthday})`
    })
    constructor() {
        super('customer'); // table name in the database
    }
}()

const vCustomerAndCompany = new class VCustomerAndCompany extends View<DBConnection, 'VCustomerAndCompany'> {
    companyId = this.column('company_id', 'int')
    companyName = this.column('company_name', 'string')
    customerId = this.column('customer_id', 'int')
    customerFirstName = this.column('customer_first_name', 'string')
    customerLastName = this.column('customer_last_name', 'string')
    customerBirthday = this.optionalColumn('customer_birthday', 'localDate')
    constructor() {
        super('customer_company')
    }
}()
vCustomerAndCompany.as('testView')

const tCustomCompany = new class TCustomCompany extends Table<DBConnection, 'TCustomCompany'> {
    id = this.autogeneratedPrimaryKey('id', 'int');
    name = this.column('name', 'string');
    isBig = this.column('is_big', 'boolean', new CustomBooleanTypeAdapter('Y', 'N'));
    constructor() {
        super('custom_company'); // table name in the database
    }
}()

const tRecord = new class TRecord extends Table<DBConnection, 'TRecord'> {
    id = this.primaryKey('id', 'uuid');
    title = this.column('title', 'string');
    constructor() {
        super('record'); // table name in the database
    }
}()

async function main() {
    let result: any
    const expectedResult: any[] = []
    const expectedQuery: string[] = []
    const expectedParams: string[] = []
    const expectedType: string[] = []
    const mockQueryRunner = new MockQueryRunner(
        (type, query, params, index) => {
            assertEquals(query, expectedQuery[index])
            assertEquals(JSON.stringify(params), expectedParams[index])
            assertEquals(type, expectedType[index])
            return expectedResult[index]
        }
    )

    const connection = new DBConnection(new ConsoleLogQueryRunner(mockQueryRunner))

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, parent_id as parentId, ubication_latitude as "ubication.latitude", ubication_longitude as "ubication.longitude", ubication_comment as "ubication.comment" from company`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const companies = await connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId,
            ubication: {
                latitude: tCompany.ubicationLatitude.asRequiredInOptionalObject(),
                longitude: tCompany.ubicationLongitude.asRequiredInOptionalObject(),
                comment: tCompany.ubicationComment
            }
        })
        .executeSelectMany()
    
    assertEquals(companies, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const customerId = 10
    
    let customerWithId = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .executeSelectOne()
    
    assertEquals(customerWithId, result)

    let typeValidation: {
        id: number;
        firstName: string;
        lastName: string;
        birthday?: Date | undefined;
    } = null as any

    customerWithId = typeValidation
    typeValidation = customerWithId

    /* *** Preparation ************************************************************/

    result = [{
        id: 1,
        name: {
            firstName: 'First Name',
            lastName: 'Last Name'
        }
    }]
    expectedResult.push([{
        id: 1,
        'name.firstName': 'First Name',
        'name.lastName': 'Last Name'
    }])
    expectedQuery.push(`select id as id, first_name as "name.firstName", last_name as "name.lastName", birthday as birthday from customer where company_id = ? order by "name.firstName", "name.lastName"`)
    expectedParams.push(`[24]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const companyId = 24

    const customersOfCompany = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.equals(companyId))
        .select({
            id: tCustomer.id,
            name: {
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
            },
            birthday: tCustomer.birthday
        })
        .orderBy('name.firstName')
        .orderBy('name.lastName')
        .executeSelectMany()
    
    assertEquals(customersOfCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || ? || last_name as name, birthday as birthday from customer where first_name like ('%' || ? || '%') escape '\\' order by lower(name), birthday asc nulls last`)
    expectedParams.push(`[" ","ohn"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const firstNameContains = 'ohn'
    const lastNameContains = null
    const birthdayIs = null
    const searchOrderBy = 'name insensitive, birthday asc nulls last'
    
    const searchedCustomers = await connection.selectFrom(tCustomer)
        .where(
                    tCustomer.firstName.containsIfValue(firstNameContains)
                .or(tCustomer.lastName.containsIfValue(lastNameContains))
            ).and(
                tCustomer.birthday.equalsIfValue(birthdayIs)
            )
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            birthday: tCustomer.birthday
        })
        .orderByFromString(searchOrderBy)
        .executeSelectMany()
    
    assertEquals(searchedCustomers, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || ? || last_name as name, birthday as birthday from customer where first_name like ('%' || ? || '%') escape '\\' order by lower(name), birthday asc nulls last`)
    expectedParams.push(`[" ","ohn"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    let searchedCustomersWhere = connection.dynamicBooleanExpressionUsing(tCustomer)
    if (firstNameContains) {
        searchedCustomersWhere = searchedCustomersWhere.and(tCustomer.firstName.contains(firstNameContains))
    }
    if (lastNameContains) {
        searchedCustomersWhere = searchedCustomersWhere.or(tCustomer.lastName.contains(lastNameContains))
    }
    if (birthdayIs) {
        searchedCustomersWhere = searchedCustomersWhere.and(tCustomer.birthday.equals(birthdayIs))
    }
    
    const searchedCustomers2 = await connection.selectFrom(tCustomer)
        .where(searchedCustomersWhere)
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            birthday: tCustomer.birthday
        })
        .orderByFromString(searchOrderBy)
        .executeSelectMany()
    
    assertEquals(searchedCustomers2, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || ? || last_name as name, birthday as birthday from customer where first_name like ('%' || ? || '%') escape '\\' order by lower(name), birthday asc nulls last`)
    expectedParams.push(`[" ","ohn"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const hideId = false

    let searchedCustomersWhere3
    if (firstNameContains) {
        searchedCustomersWhere3 = tCustomer.firstName.contains(firstNameContains)
    } else {
        searchedCustomersWhere3 = connection.noValueBoolean()
    }
    if (lastNameContains) {
        searchedCustomersWhere3 = mergeType(searchedCustomersWhere3).or(tCustomer.lastName.contains(lastNameContains))
    }
    if (birthdayIs) {
        searchedCustomersWhere3 = mergeType(searchedCustomersWhere3).and(tCustomer.birthday.equals(birthdayIs))
    }
    searchedCustomersWhere3 = mergeType(searchedCustomersWhere3)
    
    let idColumn
    if (hideId) {
        idColumn = connection.optionalConst(null, 'int')
    } else {
        idColumn = tCustomer.id
    }
    idColumn = mergeType(idColumn)
    
    const searchedCustomers3 = await connection.selectFrom(tCustomer)
        .where(searchedCustomersWhere3)
        .select({
            id: idColumn,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            birthday: tCustomer.birthday
        })
        .orderByFromString(searchOrderBy)
        .executeSelectMany()
    
    assertEquals(searchedCustomers3, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, comp.name as companyName from customer inner join company as comp on customer.company_id = comp.id where lower(customer.first_name) like lower(? || '%') escape '\\' order by lower(firstName), lower(lastName) asc`)
    expectedParams.push(`["John"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const firstName = 'John'
    const lastName = null
    
    const company = tCompany.as('comp')
    const customersWithCompanyName = await connection.selectFrom(tCustomer)
        .innerJoin(company).on(tCustomer.companyId.equals(company.id))
        .where(tCustomer.firstName.startsWithInsensitive(firstName))
            .and(tCustomer.lastName.startsWithInsensitiveIfValue(lastName))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday,
            companyName: company.name
        })
        .orderBy('firstName', 'insensitive')
        .orderBy('lastName', 'asc insensitive')
        .executeSelectMany()
    
    assertEquals(customersWithCompanyName, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as customerId, first_name as customerFirstName, last_name as customerLastName from customer where company_id in (select id as result from company where name like ('%' || ? || '%') escape '\\') order by customerFirstName asc nulls first, customerLastName`)
    expectedParams.push(`["Cia."]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const orderBy = 'customerFirstName asc nulls first, customerLastName'
    const customerWithSelectedCompanies = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.in(
            connection.selectFrom(tCompany)
                .where(tCompany.name.contains('Cia.'))
                .selectOneColumn(tCompany.id)
        )).select({
            customerId: tCustomer.id,
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        }).orderByFromString(orderBy)
        .executeSelectMany()
    
    assertEquals(customerWithSelectedCompanies, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select company.id as companyId, company.name as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.name`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompany = await connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        }).groupBy('companyId', 'companyName')
        .executeSelectMany()
    
    assertEquals(customerCountPerCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select company.id as companyId, company.name as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.name`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompany2 = await connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .groupBy(tCompany.id, tCompany.name)
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        })
        .executeSelectMany()
    
    assertEquals(customerCountPerCompany2, result)
    
    /* *** Preparation ************************************************************/

    result = {
        data: [],
        count: 0
    }
    expectedResult.push([])
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName from customer where lower(first_name) like lower(? || '%') escape '\\' or lower(last_name) like lower(? || '%') escape '\\' order by firstName, lastName limit ? offset ?`)
    expectedParams.push(`["Smi","Smi",10,20]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push(0)
    expectedQuery.push(`select count(*) from customer where lower(first_name) like lower(? || '%') escape '\\' or lower(last_name) like lower(? || '%') escape '\\'`)
    expectedParams.push(`["Smi","Smi"]`)
    expectedType.push(`selectOneColumnOneRow`)
    
    /* *** Example ****************************************************************/

    const customerName = 'Smi'
    const customerPageWithName = await connection.selectFrom(tCustomer)
        .where(
            tCustomer.firstName.startsWithInsensitive(customerName)
        ).or(
            tCustomer.lastName.startsWithInsensitive(customerName)
        ).select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .orderBy('firstName')
        .orderBy('lastName')
        .limit(10)
        .offset(20)
        .executeSelectPage()
    
    assertEquals(customerPageWithName, result)
    
    /* *** Preparation ************************************************************/

    result = null
    expectedResult.push(result)
    expectedQuery.push(`select id::varchar as idAsString, first_name || ? || last_name as name from customer where !!id = !!?`)
    expectedParams.push(`[" ",10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const id = 10
    const customersUsingCustomFragment = await connection.selectFrom(tCustomer)
        .where(connection.fragmentWithType('boolean', 'required').sql`!!${tCustomer.id} = !!${connection.const(id, 'int')}`)
        .select({
            idAsString: connection.fragmentWithType('string', 'required').sql`${tCustomer.id}::varchar`,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName)
        })
        .executeSelectNoneOrOne()
    
    assertEquals(customersUsingCustomFragment, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, id << ? as idMultiplyBy2 from company where (id * ?) = (id << ?)`)
    expectedParams.push(`[1,2,1]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const bitwiseMovements = 1
    const multiplier = 2
    const companiesUsingCustomFunctionFragment = await connection.selectFrom(tCompany)
        .where(tCompany.id.multiply(multiplier).equals(connection.bitwiseShiftLeft(tCompany.id, bitwiseMovements)))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            idMultiplyBy2: connection.bitwiseShiftLeft(tCompany.id, bitwiseMovements)
        })
        .executeSelectMany()
    
    assertEquals(companiesUsingCustomFunctionFragment, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name from company where id + 1 = ?`)
    expectedParams.push(`[2]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const noValue = null
    const withValue = 2
    const companiesUsingCustomFunctionFragmentIfValue = await connection.selectFrom(tCompany)
        .where(connection.valuePlusOneEqualsIfValue(tCompany.id, noValue))
            .or(connection.valuePlusOneEqualsIfValue(tCompany.id, withValue))
        .select({
            id: tCompany.id,
            name: tCompany.name,
        })
        .executeSelectMany()
    
    assertEquals(companiesUsingCustomFunctionFragmentIfValue, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id, birthday) values (?, ?, ?, ?) returning id`)
    expectedParams.push(`["John","Smith",1,"2000-03-01"]`)
    expectedType.push(`insertReturningLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const insertCustomer = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }).setIfNotSet({
            birthday: new Date('2000-03-01')
        }).returningLastInsertedId()
        .executeInsert()
    
    assertEquals(insertCustomer, result)
    
    /* *** Preparation ************************************************************/

    result = [2, 3]
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values (?, ?, ?), (?, ?, ?) returning id`)
    expectedParams.push(`["John","Smith",1,"Other","Person",1]`)
    expectedType.push(`insertReturningMultipleLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const valuesToInsert = [
        {
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        },
        {
            firstName: 'Other',
            lastName: 'Person',
            companyId: 1
        }
    ]
    
    const insertMultipleCustomers = await connection.insertInto(tCustomer)
        .values(valuesToInsert)
        .returningLastInsertedId()
        .executeInsert();
    
    assertEquals(insertMultipleCustomers, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) select first_name as firstName, last_name as lastName, company_id as companyId from customer where company_id = ?`)
    expectedParams.push(`[1]`)
    expectedType.push(`insert`)
    
    /* *** Example ****************************************************************/

    const insertCustomersFromSelect = await connection.insertInto(tCustomer)
        .from(
            connection.selectFrom(tCustomer)
            .where(
                tCustomer.companyId.equals(1)
            )
            .select({
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                companyId: tCustomer.companyId
            })
        )
        .executeInsert();
    
    assertEquals(insertCustomersFromSelect, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update customer set first_name = ?, last_name = ? where id = ?`)
    expectedParams.push(`["John","Smith",10]`)
    expectedType.push(`update`)
    
    /* *** Example ****************************************************************/

    let updateCustomer = await connection.update(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('2000-03-01')
        }).ignoreIfSet('birthday')
        .where(tCustomer.id.equals(10))
        .executeUpdate()
    
    assertEquals(updateCustomer, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`delete from customer where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`delete`)
    
    /* *** Example ****************************************************************/

    let deleteCustomer = await connection.deleteFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .executeDelete()
    
    assertEquals(deleteCustomer, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with customerCountPerCompany as (select company.id as companyId, company.name as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.name) select companyId as acmeCompanyId, companyName as acmeCompanyName, customerCount as acmeCustomerCount from customerCountPerCompany where lower(companyName) like lower('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompanyWith = connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        }).groupBy('companyId', 'companyName')
        .forUseInQueryAs('customerCountPerCompany')
    
    const customerCountPerAcmeCompanies = await connection.selectFrom(customerCountPerCompanyWith)
        .where(customerCountPerCompanyWith.companyName.containsInsensitive('ACME'))
        .select({
            acmeCompanyId: customerCountPerCompanyWith.companyId,
            acmeCompanyName: customerCountPerCompanyWith.companyName,
            acmeCustomerCount: customerCountPerCompanyWith.customerCount
        })
        .executeSelectMany()
    
    assertEquals(customerCountPerAcmeCompanies, result)
    
    /* *** Preparation ************************************************************/
    
    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into custom_company (name, is_big) values (?, case when ? then 'Y' else 'N' end) returning id`)
    expectedParams.push(`["My Big Company",true]`)
    expectedType.push(`insertReturningLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const insertCustomCompany = await connection.insertInto(tCustomCompany).set({
            name: 'My Big Company',
            isBig: true
        }).returningLastInsertedId()
        .executeInsert()
    
    assertEquals(insertCustomCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (is_big = 'Y') as isBig from custom_company where is_big = 'Y'`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const selectAllBigCompanies = await connection.selectFrom(tCustomCompany)
        .where(tCustomCompany.isBig)
        .select({
            id: tCustomCompany.id,
            name: tCustomCompany.name,
            isBig: tCustomCompany.isBig
        }).executeSelectMany()
    
    assertEquals(selectAllBigCompanies, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, company.name as companyName from customer inner join company on customer.company_id = company.id where (lower(customer.first_name) like lower(? || '%') escape '\\' or (lower(customer.last_name) like lower(? || '%') escape '\\' and customer.last_name like ('%' || ?) escape '\\')) and company.name = ? order by lower(firstName), lower(lastName) asc`)
    expectedParams.push(`["John","Smi","th","ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    type FilterType = DynamicCondition<{
        id: 'int',
        firstName: 'string',
        lastName: 'string',
        birthday: 'localDate',
        companyName: 'string'
    }>
    
    const filter: FilterType = {
        or: [
            { firstName: { startsWithInsensitive: 'John' } },
            { lastName: { startsWithInsensitiveIfValue: 'Smi', endsWith: 'th' } }
        ],
        companyName: {equals: 'ACME'}
    }
    
    const selectFields = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyName: tCompany.name
    }
    
    const dynamicWhere = connection.dynamicConditionFor(selectFields).withValues(filter)
    
    const customersWithDynamicCondition = await connection.selectFrom(tCustomer)
        .innerJoin(tCompany).on(tCustomer.companyId.equals(tCompany.id))
        .where(dynamicWhere)
        .select(selectFields)
        .orderBy('firstName', 'insensitive')
        .orderBy('lastName', 'asc insensitive')
        .executeSelectMany()
    
    assertEquals(customersWithDynamicCondition, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as "name.firstName", customer.last_name as "name.lastName", customer.birthday as birthday, company.id as "company.id", company.name as "company.name" from customer inner join company on customer.company_id = company.id where (lower(customer.first_name) like lower(? || '%') escape '\\' or (lower(customer.last_name) like lower(? || '%') escape '\\' and customer.last_name like ('%' || ?) escape '\\')) and company.name = ? order by lower("name.firstName"), lower("name.lastName") asc`)
    expectedParams.push(`["John","Smi","th","ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    type FilterType2 = DynamicCondition<{
        id: 'int',
        name: {
            firstName: 'string',
            lastName: 'string',
        }
        birthday: 'localDate',
        company: {
            id: 'int'
            name: 'string'
        }
    }>

    const filter2: FilterType2 = {
        or: [
            { name: { firstName: { startsWithInsensitive: 'John' } } },
            { name: { lastName: { startsWithInsensitiveIfValue: 'Smi', endsWith: 'th' } } }
        ],
        company: {
            name: { equals: 'ACME' }
        }
    }
    
    const selectFields2 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday,
        company: {
            id: tCompany.id,
            name: tCompany.name
        }
    }
    
    const dynamicWhere2 = connection.dynamicConditionFor(selectFields2).withValues(filter2)
    
    const customersWithDynamicCondition2 = await connection.selectFrom(tCustomer)
        .innerJoin(tCompany).on(tCustomer.companyId.equals(tCompany.id))
        .where(dynamicWhere2)
        .select(selectFields2)
        .orderBy('name.firstName', 'insensitive')
        .orderBy('name.lastName', 'asc insensitive')
        .executeSelectMany()
    
    assertEquals(customersWithDynamicCondition2, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || ? || last_name as name, ? as type from customer union all select id as id, name as name, ? as type from company`)
    expectedParams.push(`[" ","customer","company"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const allDataWithName = await connection.selectFrom(tCustomer)
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            type: connection.const<'customer' | 'company'>('customer', 'enum', 'customerOrCompany')
        }).unionAll(
            connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name,
                type: connection.const<'customer' | 'company'>('company', 'enum', 'customerOrCompany')
            })
        ).executeSelectMany()
    
    assertEquals(allDataWithName, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 10,
        name: 'ACME Inc.',
        customers: [{
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14Z')
        }, {
            id: 13,
            firstName: 'Jorge',
            lastName: 'Justo',
            birthday: new Date('1991/2/16Z')
        }]
    }, {
        id: 11,
        name: 'ACME Corp.',
        customers: [{
            id: 14,
            firstName: 'Maria',
            lastName: 'Rodriguez',
            birthday: new Date('1992/3/18Z')
        }]
    }]
    expectedResult.push([{
        id: 10,
        name: 'ACME Inc.'
    }, {
        id: 11,
        name: 'ACME Corp.'
    }])
    expectedQuery.push(`select id as id, name as name from company where lower(name) like lower('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push([{
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14Z'),
        companyId: 10
    }, {
        id: 13,
        firstName: 'Jorge',
        lastName: 'Justo',
        birthday: new Date('1991/2/16Z'),
        companyId: 10
    }, {
        id: 14,
        firstName: 'Maria',
        lastName: 'Rodriguez',
        birthday: new Date('1992/3/18Z'),
        companyId: 11
    }])
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where company_id in (?, ?)`)
    expectedParams.push(`[10,11]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const companiesWithCustomers = await connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name
            }).where(
                tCompany.name.containsInsensitive('ACME')
            ).composeDeletingInternalProperty({
                externalProperty: 'id',
                internalProperty: 'companyId',
                propertyName: 'customers'
            }).withMany((ids) => {
                return connection.selectFrom(tCustomer)
                    .select({
                        id: tCustomer.id,
                        firstName: tCustomer.firstName,
                        lastName: tCustomer.lastName,
                        birthday: tCustomer.birthday,
                        companyId: tCustomer.companyId
                    }).where(
                        tCustomer.companyId.in(ids)
                    ).executeSelectMany()
            }).executeSelectMany()
    
    assertEquals(companiesWithCustomers, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 10,
        name: 'ACME Inc.',
        customers: [{
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14Z')
        }, {
            id: 13,
            firstName: 'Jorge',
            lastName: 'Justo',
            birthday: new Date('1991/2/16Z')
        }]
    }, {
        id: 11,
        name: 'ACME Corp.'
    }]
    expectedResult.push([{
        id: 10,
        name: 'ACME Inc.'
    }, {
        id: 11,
        name: 'ACME Corp.'
    }])
    expectedQuery.push(`select id as id, name as name from company where lower(name) like lower('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push([{
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14Z'),
        companyId: 10
    }, {
        id: 13,
        firstName: 'Jorge',
        lastName: 'Justo',
        birthday: new Date('1991/2/16Z'),
        companyId: 10
    }])
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where company_id in (?, ?)`)
    expectedParams.push(`[10,11]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const companiesWithCustomers2 = await connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name
            }).where(
                tCompany.name.containsInsensitive('ACME')
            ).composeDeletingInternalProperty({
                externalProperty: 'id',
                internalProperty: 'companyId',
                propertyName: 'customers'
            }).withOptionalMany((ids) => {
                return connection.selectFrom(tCustomer)
                    .select({
                        id: tCustomer.id,
                        firstName: tCustomer.firstName,
                        lastName: tCustomer.lastName,
                        birthday: tCustomer.birthday,
                        companyId: tCustomer.companyId
                    }).where(
                        tCustomer.companyId.in(ids)
                    ).executeSelectMany()
            }).executeSelectMany()
    
    assertEquals(companiesWithCustomers2, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 10,
        name: 'ACME Inc.',
        customers: [{
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14Z')
        }, {
            id: 13,
            firstName: 'Jorge',
            lastName: 'Justo',
            birthday: new Date('1991/2/16Z')
        }]
    }, {
        id: 11,
        name: 'ACME Corp.',
        customers: []
    }]
    expectedResult.push([{
        id: 10,
        name: 'ACME Inc.'
    }, {
        id: 11,
        name: 'ACME Corp.'
    }])
    expectedQuery.push(`select id as id, name as name from company where lower(name) like lower('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push([{
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14Z'),
        companyId: 10
    }, {
        id: 13,
        firstName: 'Jorge',
        lastName: 'Justo',
        birthday: new Date('1991/2/16Z'),
        companyId: 10
    }])
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where company_id in (?, ?)`)
    expectedParams.push(`[10,11]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const companiesWithCustomers3 = await connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name
            }).where(
                tCompany.name.containsInsensitive('ACME')
            ).composeDeletingInternalProperty({
                externalProperty: 'id',
                internalProperty: 'companyId',
                propertyName: 'customers'
            }).withMany((ids) => {
                return connection.selectFrom(tCustomer)
                    .select({
                        id: tCustomer.id,
                        firstName: tCustomer.firstName,
                        lastName: tCustomer.lastName,
                        birthday: tCustomer.birthday,
                        companyId: tCustomer.companyId
                    }).where(
                        tCustomer.companyId.in(ids)
                    ).executeSelectMany()
            }).executeSelectMany()
    
    assertEquals(companiesWithCustomers3, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        companyId: 10
    })
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    expectedResult.push([{
        id: 10,
        name: 'ACME Inc.'
    }])
    expectedQuery.push(`select id as id, name as name from company where id in (?)`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerWithCompany = await connection.selectFrom(tCustomer)
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                birthday: tCustomer.birthday,
                companyId: tCustomer.companyId
            }).where(
                tCustomer.id .equals(12)
            ).composeDeletingExternalProperty({
                externalProperty: 'companyId',
                internalProperty: 'id',
                propertyName: 'company'
            }).withOne((ids) => {
                return connection.selectFrom(tCompany)
                    .select({
                        id: tCompany.id,
                        name: tCompany.name
                    }).where(
                        tCompany.id.in(ids)
                    ).executeSelectMany()
            }).executeSelectOne()
    
    assertEquals(customerWithCompany, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        companyId: 10,
        companyName: 'ACME Inc.'
    })
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, company.id as companyId, company.name as companyName from customer inner join company on company.id = customer.company_id where customer.id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customerWithCompanyInOneQuery = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                birthday: tCustomer.birthday,
                companyId: tCompany.id,
                companyName: tCompany.name
            }).where(
                tCustomer.id .equals(12)
            ).split('company', {
                id: 'companyId',
                name: 'companyName'
            }).executeSelectOne()

    assertEquals(customerWithCompanyInOneQuery, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        'company.id': 10,
        'company.name': 'ACME Inc.'
    })
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, company.id as "company.id", company.name as "company.name" from customer inner join company on company.id = customer.company_id where customer.id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customerWithCompanyInOneQuery2 = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                birthday: tCustomer.birthday,
                company: {
                    id: tCompany.id,
                    name: tCompany.name
                }
            }).where(
                tCustomer.id .equals(12)
            ).executeSelectOne()

    assertEquals(customerWithCompanyInOneQuery2, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        'company.id': 10,
        'company.name': 'ACME Inc.'
    })
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, company.id as "company.id", company.name as "company.name" from customer inner join company on company.id = customer.company_id where company.name = ? and (lower(customer.first_name) like lower('%' || ? || '%') escape '\\' or lower(customer.last_name) like lower('%' || ? || '%') escape '\\') order by lower("company.name") asc, birthday desc`)
    expectedParams.push(`["ACME","John","Smi"]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    type QueryFilterType = DynamicCondition<{
        id: 'int',
        firstName: 'string',
        lastName: 'string',
        birthday: 'localDate',
        'company.id': 'int',
        'company.name': 'string'
    }>
    
    const queryFilter: QueryFilterType = {
        'company.name': {equals: 'ACME'},
        or: [
            { firstName: { containsInsensitive: 'John' } },
            { lastName: { containsInsensitive: 'Smi' } }
        ]
    }
    
    const queryOrderBy = 'company.name asc insensitive, birthday desc'
    
    const querySelectFields = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        'company.id': tCompany.id,
        'company.name': tCompany.name
    }
    
    const queryDynamicWhere = connection.dynamicConditionFor(querySelectFields).withValues(queryFilter)
    
    const customerWithCompanyObject = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select(querySelectFields)
            .where(queryDynamicWhere)
            .orderByFromString(queryOrderBy)
            .split('company', {
                id: 'company.id',
                name: 'company.name'
            }).executeSelectOne()
    
    assertEquals(customerWithCompanyObject, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        name: {
            firstName: 'John',
            lastName: 'Smith',
        },
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        'name.firstName': 'John',
        'name.lastName': 'Smith',
        birthday: new Date('1990/1/14'),
        'company.id': 10,
        'company.name': 'ACME Inc.'
    })
    expectedQuery.push(`select customer.id as id, customer.first_name as "name.firstName", customer.last_name as "name.lastName", customer.birthday as birthday, company.id as "company.id", company.name as "company.name" from customer inner join company on company.id = customer.company_id where company.name = ? and (lower(customer.first_name) like lower('%' || ? || '%') escape '\\' or lower(customer.last_name) like lower('%' || ? || '%') escape '\\') order by lower("company.name") asc, birthday desc`)
    expectedParams.push(`["ACME","John","Smi"]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    type QueryFilterType2 = DynamicCondition<{
        id: 'int',
        name: {
            firstName: 'string',
            lastName: 'string',
        },
        birthday: 'localDate',
        company: {
            id: 'int',
            name: 'string'
        }
    }>
    
    const queryFilter2: QueryFilterType2 = {
        company: { name: {equals: 'ACME'} },
        name: {
            or: [
                { firstName: { containsInsensitive: 'John' } },
                { lastName: { containsInsensitive: 'Smi' } }
            ]
        }
    }
    
    const queryOrderBy2 = 'company.name asc insensitive, birthday desc'
    
    const querySelectFields2 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday,
        company: {
            id: tCompany.id,
            name: tCompany.name
        }
    }
    
    const queryDynamicWhere2 = connection.dynamicConditionFor(querySelectFields2).withValues(queryFilter2)
    
    const customerWithCompanyObject2 = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select(querySelectFields2)
            .where(queryDynamicWhere2)
            .orderByFromString(queryOrderBy2)
            .executeSelectOne()
    
    assertEquals(customerWithCompanyObject2, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = ? union select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.parentId = company.id) select id as id, name as name, parentId as parentId from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const recursiveParentCompany = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(10))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        }).recursiveUnion((child) => {
            return connection.selectFrom(tCompany)
            .join(child).on(child.parentId.equals(tCompany.id))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                parentId: tCompany.parentId
            })
        }).executeSelectMany()
    
    assertEquals(recursiveParentCompany, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = ? union select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.parentId = company.id) select id as id, name as name, parentId as parentId from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const recursiveOnParentCompany = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(10))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        }).recursiveUnionOn((child) => {
            return child.parentId.equals(tCompany.id)
        }).executeSelectMany()
    
    assertEquals(recursiveOnParentCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = ? union all select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.id = company.parent_id) select id as id, name as name, parentId as parentId from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const recursiveChildrenCompany = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(10))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        }).recursiveUnionAll((parent) => {
            return connection.selectFrom(tCompany)
            .join(parent).on(parent.id.equals(tCompany.parentId))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                parentId: tCompany.parentId
            })
        }).executeSelectMany()
    
    assertEquals(recursiveChildrenCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = ? union all select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.id = company.parent_id) select id as id, name as name, parentId as parentId from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const recursiveOnChildrenCompany = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(10))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        }).recursiveUnionAllOn((parent) => {
            return parent.id.equals(tCompany.parentId)
        }).executeSelectMany()
    
    assertEquals(recursiveOnChildrenCompany, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parentId: 18,
        parentName: 'name'
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as parentId, parent.name as parentName from company left join company as parent on company.parent_id = parent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parent = tCompany.forUseInLeftJoinAs('parent')
    
    const leftJoinCompany = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: parent.id,
            parentName: parent.name
        }).guidedSplitOptional('parent', {
            id: 'parentId!',
            name: 'parentName!'
        }).executeSelectMany()
    
    assertEquals(leftJoinCompany, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        'parent.id': 18,
        'parent.name': 'name'
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as "parent.id", parent.name as "parent.name" from company left join company as parent on company.parent_id = parent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    //const parent = tCompany.forUseInLeftJoinAs('parent')
    
    const leftJoinCompany2 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parent: {
                id: parent.id,
                name: parent.name
            }
        }).executeSelectMany()
    
    assertEquals(leftJoinCompany2, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName from customer`)
    expectedParams.push(`[]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const availableFields = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday
    }
    
    const fieldsToPick = {
        firstName: true,
        lastName: true
    }
    
    // include allways id field as required
    const pickedFields = dynamicPick(availableFields, fieldsToPick, ['id'])
    
    const customerWithIdPeaking = await connection.selectFrom(tCustomer)
        .select(pickedFields)
        .executeSelectOne()
    
    assertEquals(customerWithIdPeaking, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName from customer where id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields2 = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyId: tCompany.id,
        companyName: tCompany.name
    }
    
    const fieldsToPick2 = {
        firstName: true,
        lastName: true
    }
    
    // include allways id field as required
    const pickedFields2 = dynamicPick(availableFields2, fieldsToPick2, ['id'])
    
    const customerWithOptionalCompany = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields2)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, company.name as companyName from customer inner join company on company.id = customer.company_id where customer.id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields3 = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyId: tCompany.id,
        companyName: tCompany.name
    }
    
    const fieldsToPick3 = {
        firstName: true,
        lastName: true,
        companyName: true
    }
    
    // include allways id field as required
    const pickedFields3 = dynamicPick(availableFields3, fieldsToPick3, ['id'])
    
    const customerWithOptionalCompany3 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields3)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany3, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: {
            firstName: 'First Name',
            lastName: 'Last Name'
        }
    }
    expectedResult.push({
        id: 1,
        'name.firstName': 'First Name',
        'name.lastName': 'Last Name'
    })
    expectedQuery.push(`select id as id, first_name as "name.firstName", last_name as "name.lastName" from customer`)
    expectedParams.push(`[]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const availableFields4 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday
    }
    
    const fieldsToPick4 = {
        name: {
            firstName: true,
            lastName: true
        }
    }
    
    // include allways id field as required
    const pickedFields4 = dynamicPick(availableFields4, fieldsToPick4, ['id'])
    
    const customerWithIdPeaking4 = await connection.selectFrom(tCustomer)
        .select(pickedFields4)
        .executeSelectOne()
    
    assertEquals(customerWithIdPeaking4, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "name.firstName", last_name as "name.lastName" from customer where id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields5 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday,
        company: {
            id: tCompany.id,
            name: tCompany.name
        }
    }
    
    const fieldsToPick5 = {
        name: {
            firstName: true,
            lastName: true
        }
    }
    
    // include allways id field as required
    const pickedFields5 = dynamicPick(availableFields5, fieldsToPick5, ['id'])
    
    const customerWithOptionalCompany5 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields5)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany5, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as "name.firstName", customer.last_name as "name.lastName", company.name as "company.name" from customer inner join company on company.id = customer.company_id where customer.id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields6 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday,
        company: {
            id: tCompany.id,
            name: tCompany.name
        }
    }
    
    const fieldsToPick6 = {
        name: {
            firstName: true,
            lastName: true,
        },
        company: {
            name: true
        }
    }
    
    // include allways id field as required
    const pickedFields6 = dynamicPick(availableFields6, fieldsToPick6, ['id'])
    
    const customerWithOptionalCompany6 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields6)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany6, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer for system_time between ? and ?  where id = ?`)
    expectedParams.push(`["2019-01-01T00:00:00Z","2020-01-01T00:00:00Z",10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerIn2019 = connection.forSystemTimeBetween(tCustomer, 'customerIn2019', new Date('2019-01-01'), new Date('2020-01-01'))
    
    const customerInSystemTime = await connection.selectFrom(customerIn2019)
        .where(customerIn2019.id.equals(10))
        .select({
            id: customerIn2019.id,
            firstName: customerIn2019.firstName,
            lastName: customerIn2019.lastName,
            birthday: customerIn2019.birthday
        })
        .executeSelectMany()
    
    assertEquals(customerInSystemTime, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    let customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by my_column, my_id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            beforeOrderByItems: connection.rawFragment`my_column`,
            afterOrderByItems: connection.rawFragment`my_id`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by my_column for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            beforeOrderByItems: connection.rawFragment`my_column`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by my_id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            afterOrderByItems: connection.rawFragment`my_id`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .orderBy('id')
        .customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by my_column, id, my_id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .orderBy('id')
        .customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            beforeOrderByItems: connection.rawFragment`my_column`,
            afterOrderByItems: connection.rawFragment`my_id`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by my_column, id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .orderBy('id')
        .customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            beforeOrderByItems: connection.rawFragment`my_column`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by id, my_id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .orderBy('id')
        .customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            afterOrderByItems: connection.rawFragment`my_id`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update /*+ some hints */ customer set first_name = ?, last_name = ? where id = ? keep plan`)
    expectedParams.push(`["John","Smith",10]`)
    expectedType.push(`update`)
    
    /* *** Example ****************************************************************/

    const customizedUpdate = await connection.update(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith'
        }).where(tCustomer.id.equals(10))
        .customizeQuery({
            afterUpdateKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`keep plan`,
        })
        .executeUpdate()
    
    assertEquals(customizedUpdate, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`delete /*+ some hints */ from customer where id = ? keep plan`)
    expectedParams.push(`[10]`)
    expectedType.push(`delete`)
    
    /* *** Example ****************************************************************/

    const customizedDelete = await connection.deleteFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .customizeQuery({
            afterDeleteKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`keep plan`,
        })
        .executeDelete()
    
    assertEquals(customizedDelete, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert /*+ some hints */ into customer (first_name, last_name, company_id) values (?, ?, ?) log errors reject limit unlimited`)
    expectedParams.push(`["John","Smith",1]`)
    expectedType.push(`insert`)
    
    /* *** Example ****************************************************************/

    const customizedInsert = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }).customizeQuery({
            afterInsertKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`log errors reject limit unlimited`
        }).executeInsert()

    assertEquals(customizedInsert, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 9,
        firstName: 'First Name',
        lastName: 'Last Name',
        companyId: 7
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where id = ?`)
    expectedParams.push(`[9]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const selectAll = await connection.selectFrom(tCustomer)
        .select(extractWritableColumnsFrom(tCustomer))
        .where(tCustomer.id.equals(9))
        .executeSelectOne()
    
    assertEquals(selectAll, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 9,
        firstName: 'First Name',
        lastName: 'Last Name',
        name: 'First Name Last Name',
        companyId: 7
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId, first_name || ? || last_name as name, calculateAge(birthday) as age from customer where id = ?`)
    expectedParams.push(`[" ",9]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const selectAll2 = await connection.selectFrom(tCustomer)
        .select(extractColumnsFrom(tCustomer))
        .where(tCustomer.id.equals(9))
        .executeSelectOne()
    
    assertEquals(selectAll2, result)
    
    /* *** Preparation ************************************************************/

    result = {
        customer: {
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14'),
        },
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        'customer.id': 12,
        'customer.firstName': 'John',
        'customer.lastName': 'Smith',
        'customer.birthday': new Date('1990/1/14'),
        'company.id': 10,
        'company.name': 'ACME Inc.'
    })
    expectedQuery.push(`select customer.id as "customer.id", customer.first_name as "customer.firstName", customer.last_name as "customer.lastName", customer.birthday as "customer.birthday", company.id as "company.id", company.name as "company.name" from customer inner join company on company.id = customer.company_id where customer.id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customerColumns = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday
    }
    
    const companyColumns = {
        id: tCompany.id,
        name: tCompany.name
    }
    
    const customerWithCompanyPrefixed = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select({
                ...prefixDotted(customerColumns, 'customer'),
                ...prefixDotted(companyColumns, 'company')
            }).where(
                tCustomer.id.equals(12)
            )
            .split('customer', prefixMapForSplitDotted(customerColumns, 'customer'))
            .split('company', prefixMapForSplitDotted(companyColumns, 'company'))
            .executeSelectOne()
    
    assertEquals(customerWithCompanyPrefixed, result)
    
    /* *** Preparation ************************************************************/

    result = {
        customer: {
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14'),
        },
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        customerId: 12,
        customerFirstName: 'John',
        customerLastName: 'Smith',
        customerBirthday: new Date('1990/1/14'),
        companyId: 10,
        companyName: 'ACME Inc.'
    })
    expectedQuery.push(`select customer.id as customerId, customer.first_name as customerFirstName, customer.last_name as customerLastName, customer.birthday as customerBirthday, company.id as companyId, company.name as companyName from customer inner join company on company.id = customer.company_id where customer.id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customerWithCompanyPrefixed2 = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select({
                ...prefixCapitalized(customerColumns, 'customer'),
                ...prefixCapitalized(companyColumns, 'company')
            }).where(
                tCustomer.id.equals(12)
            )
            .split('customer', prefixMapForSplitCapitalized(customerColumns, 'customer'))
            .split('company', prefixMapForSplitCapitalized(companyColumns, 'company'))
            .executeSelectOne()
    
    assertEquals(customerWithCompanyPrefixed2, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parentId: 18,
        parentName: 'name',
        parentParentId: null
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as parentId, parent.name as parentName, parent.parent_id as parentParentId from company left join company as parent on company.parent_id = parent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parentCompany = tCompany.forUseInLeftJoinAs('parent')
    
    const companyFields = {
        id: tCompany.id,
        name: tCompany.name
    }
    
    const parentCompanyFields = {
        id: parentCompany.id,
        name: parentCompany.name,
        parentId: parentCompany.parentId
    }
    
    const companyPrefixed = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            ...companyFields,
            ...prefixCapitalized(parentCompanyFields, 'parent')
        }).guidedSplitOptional('parent', prefixMapForGuidedSplitCapitalized(parentCompanyFields, tCompany, 'parent'))
        .executeSelectMany()
    
    assertEquals(companyPrefixed, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name',
            parentId: 8
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        'parent.id': 18,
        'parent.name': 'name',
        'parent.parentId': 8
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as "parent.id", parent.name as "parent.name", parent.parent_id as "parent.parentId" from company left join company as parent on company.parent_id = parent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const companyPrefixed2 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            ...companyFields,
            ...prefixDotted(parentCompanyFields, 'parent')
        }).guidedSplitOptional('parent', prefixMapForGuidedSplitDotted(parentCompanyFields, tCompany, 'parent'))
        .executeSelectMany()
    
    assertEquals(companyPrefixed2, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            parentId: 18,
            parentName: 'name'
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parentId: 18,
        parentName: 'name'
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as parentId, parent.name as parentName, parent.parent_id as parentParentId from company left join company as parent on company.parent_id = parent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parentFields = {
        parentId: parentCompany.id,
        parentName: parentCompany.name,
        parentParentId: parentCompany.parentId
    }
    
    const companyPrefixed3 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            ...parentFields
        }).guidedSplitOptional('parent', mapForGuidedSplit(parentFields, {
            parentId: tCompany.id,
            parentName: tCompany.name,
            parentParentId: tCompany.parentId
        }))
        .executeSelectMany()
    
    assertEquals(companyPrefixed3, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name',
            parentId: 8
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        'parent.id': 18,
        'parent.name': 'name',
        'parent.parentId': 8
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as "parent.id", parent.name as "parent.name", parent.parent_id as "parent.parentId" from company left join company as parent on company.parent_id = parent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const companyPrefixed4 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parent: {
                id: parentCompany.id,
                name: parentCompany.name,
                parentId: parentCompany.parentId
            }
        }).executeSelectMany()
    
    assertEquals(companyPrefixed4, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }, {
        id: 20,
        name: 'name3',
        parent: {
            id: 19,
            name: 'name2',
            parent: {
                id: 18,
                name: 'name',
                parentId: 17
            }
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parentId: 18,
        parentName: 'name'
    }, {
        id: 20,
        name: 'name3',
        parentId: 19,
        parentName: 'name2',
        parentParentId: 18,
        parentParentName: 'name',
        parentParentParentId: 17
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as parentId, parent.name as parentName, parentParent.id as parentParentId, parentParent.name as parentParentName, parentParent.parent_id as parentParentParentId from company left join company as parent on company.parent_id = parent.id left join company as parentParent on parent.parent_id = parentParent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parentParent = tCompany.forUseInLeftJoinAs('parentParent')
    
    const companyMultiSplit = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .leftJoin(parentParent).on(parent.parentId.equals(parentParent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: parent.id,
            parentName: parent.name,
            parentParentId: parentParent.id,
            parentParentName: parentParent.name,
            parentParentParentId: parentParent.parentId,
        }).guidedSplitOptional('parentParent', {
            id: 'parentParentId!',
            name: 'parentParentName!',
            parentId: 'parentParentParentId'
        }).guidedSplitOptional('parent', {
            id: 'parentId!',
            name: 'parentName!',
            parent: 'parentParent'
        })
        .executeSelectMany()

    assertEquals(companyMultiSplit, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }, {
        id: 20,
        name: 'name3',
        parent: {
            id: 19,
            name: 'name2',
            parent: {
                id: 18,
                name: 'name',
                parentId: 17
            }
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        'parent.id': 18,
        'parent.name': 'name'
    }, {
        id: 20,
        name: 'name3',
        'parent.id': 19,
        'parent.name': 'name2',
        'parent.parent.id': 18,
        'parent.parent.name': 'name',
        'parent.parent.parentId': 17
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as "parent.id", parent.name as "parent.name", parentParent.id as "parent.parent.id", parentParent.name as "parent.parent.name", parentParent.parent_id as "parent.parent.parentId" from company left join company as parent on company.parent_id = parent.id left join company as parentParent on parent.parent_id = parentParent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    //const parentParent = tCompany.forUseInLeftJoinAs('parentParent')
    
    const companyMultiSplit2 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .leftJoin(parentParent).on(parent.parentId.equals(parentParent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parent: {
                id: parent.id,
                name: parent.name,
                parent: {
                    id: parentParent.id,
                    name: parentParent.name,
                    parentId: parentParent.parentId,
                }
            }
        })
        .executeSelectMany()

    assertEquals(companyMultiSplit2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || ? || last_name as name from customer where company_id = (select id as result from company where name = ?)`)
    expectedParams.push(`[" ","ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const acmeId = connection.selectFrom(tCompany)
        .where(tCompany.name.equals('ACME'))
        .selectOneColumn(tCompany.id)
        .forUseAsInlineQueryValue()

    const acmeCustomers = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.equals(acmeId))
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName)
        })
        .executeSelectMany()

    assertEquals(acmeCustomers, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 10,
        name: 'ACME'
    }
    expectedResult.push(result)
    expectedQuery.push(`delete from company where name = ? returning id as id, name as name`)
    expectedParams.push(`["ACME"]`)
    expectedType.push(`deleteReturningOneRow`)
    
    /* *** Example ****************************************************************/

    const deletedAcmeCompany = await connection.deleteFrom(tCompany)
        .where(tCompany.name.equals('ACME'))
        .returning({
            id: tCompany.id,
            name: tCompany.name
        })
        .executeDeleteOne()

    assertEquals(deletedAcmeCompany, result)

    /* *** Preparation ************************************************************/

    result = 'Ron'
    expectedResult.push(result)
    expectedQuery.push(`update customer set first_name = ? where id = ? returning first_name as result`)
    expectedParams.push(`["Ron",1]`)
    expectedType.push(`updateReturningOneColumnOneRow`)

    /* *** Example ****************************************************************/

    const updatedSmithFirstName = await connection.update(tCustomer)
        .set({
            firstName: 'Ron'
        })
        .where(tCustomer.id.equals(1))
        .returningOneColumn(tCustomer.firstName)
        .executeUpdateOne()

    assertEquals(updatedSmithFirstName, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'John',
        lastName: 'Smith',
    }
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values (?, ?, ?) returning id as id, first_name as firstName, last_name as lastName`)
    expectedParams.push(`["John","Smith",1]`)
    expectedType.push(`insertReturningOneRow`)

    /* *** Example ****************************************************************/

    const insertReturningCustomerData = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }).returning({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .executeInsertOne()

    assertEquals(insertReturningCustomerData, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'John',
        lastName: 'Smith',
    }
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values (?, ?, ?) on conflict do nothing returning id as id, first_name as firstName, last_name as lastName`)
    expectedParams.push(`["John","Smith",1]`)
    expectedType.push(`insertReturningOneRow`)

    /* *** Example ****************************************************************/

    const insertReturningCustomerData2 = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        })
        .onConflictDoNothing()
        .returning({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .executeInsertNoneOrOne()

    assertEquals(insertReturningCustomerData2, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'John',
        lastName: 'Smith',
    }
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values (?, ?, ?) on conflict do update set company_id = ? returning id as id, first_name as firstName, last_name as lastName`)
    expectedParams.push(`["John","Smith",1,1]`)
    expectedType.push(`insertReturningOneRow`)

    /* *** Example ****************************************************************/

    const insertReturningCustomerData3 = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        })
        .onConflictDoUpdateSet({
            companyId: 1
        })
        .returning({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .executeInsertOne()

    assertEquals(insertReturningCustomerData3, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update customer set last_name = customer.last_name || ? || company.name from company where customer.company_id = company.id and lower(company.name) like lower('%' || ? || '%') escape '\\'`)
    expectedParams.push(`[" - ","ACME"]`)
    expectedType.push(`update`)

    /* *** Example ****************************************************************/

    const addACMECompanyNameToLastName = await connection.update(tCustomer)
        .from(tCompany)
        .set({
            lastName: tCustomer.lastName.concat(' - ').concat(tCompany.name)
        })
        .where(tCustomer.companyId.equals(tCompany.id))
        .and(tCompany.name.containsInsensitive('ACME'))
        .executeUpdate()

    assertEquals(addACMECompanyNameToLastName, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_group_array(json_object('id', id, 'firstName', first_name, 'lastName', last_name)) as result from customer where company_id = company.id) as customers from company where id = ?`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(connection.aggregateAsArray({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        }))
        .forUseAsInlineQueryValue()

    const acmeCompanyWithCustomers = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme
        })
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select company.id as id, company.name as name, json_group_array(json_object('id', customer.id, 'firstName', customer.first_name, 'lastName', customer.last_name)) as customers from company left join customer on customer.company_id = company.id where company.id = ? group by company.id`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const tCustomerLeftJoin = tCustomer.forUseInLeftJoin()
    const acmeCompanyWithCustomers2 = await connection.selectFrom(tCompany).leftJoin(tCustomerLeftJoin).on(tCustomerLeftJoin.companyId.equals(tCompany.id))
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: connection.aggregateAsArray({
                id: tCustomerLeftJoin.id,
                firstName: tCustomerLeftJoin.firstName,
                lastName: tCustomerLeftJoin.lastName
            }).asOptionalNonEmptyArray()
        })
        .groupBy('id')
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers2, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_group_array(first_name || ? || last_name) as result from customer where company_id = company.id) as customers from company where id = ?`)
    expectedParams.push(`[" ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme3 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(connection.aggregateAsArrayOfOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName)))
        .forUseAsInlineQueryValue()

    const acmeCompanyWithCustomers3 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme3.useEmptyArrayForNoValue()
        })
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers3, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select company.id as id, company.name as name, json_group_array(customer.first_name || ? || customer.last_name) as customers from company left join customer on customer.company_id = company.id where company.id = ? group by company.id`)
    expectedParams.push(`[" ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    // const tCustomerLeftJoin = tCustomer.forUseInLeftJoin()
    const acmeCompanyWithCustomers3_1 = await connection.selectFrom(tCompany).leftJoin(tCustomerLeftJoin).on(tCustomerLeftJoin.companyId.equals(tCompany.id))
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: connection.aggregateAsArrayOfOneColumn(tCustomerLeftJoin.firstName.concat(' ').concat(tCustomerLeftJoin.lastName))
        })
        .groupBy('id')
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers3_1, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as customerId, first_name as customerFirstName, last_name as customerLastName from customer where company_id in (with inner2 as (select id as id, name as name from custom_company where id = customer.company_id) select inner2.id as result from company inner join inner2 on company.id = inner2.id where company.name like ('%' || ? || '%') escape '\\')`)
    expectedParams.push(`["Cia."]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const inner2 = connection.subSelectUsing(tCustomer).from(tCustomCompany).where(tCustomCompany.id.equals(tCustomer.companyId)).select({id: tCustomCompany.id, name: tCustomCompany.name}).forUseInQueryAs('inner2')
    
    const customerWithSelectedCompanies2 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.in(
            connection.selectFrom(tCompany).innerJoin(inner2).on(tCompany.id.equals(inner2.id))
                .where(tCompany.name.contains('Cia.'))
                .selectOneColumn(inner2.id)
        )).select({
            customerId: tCustomer.id,
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        })
        .executeSelectMany()
    
    assertEquals(customerWithSelectedCompanies2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with inner3 as (select id as id, name as name from custom_company) select id as customerId, first_name as customerFirstName, last_name as customerLastName from customer where company_id in (select inner3.id as result from company inner join inner3 on company.id = inner3.id where company.name like ('%' || ? || '%') escape '\\')`)
    expectedParams.push(`["Cia."]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const inner3 = connection.selectFrom(tCustomCompany).select({id: tCustomCompany.id, name: tCustomCompany.name}).forUseInQueryAs('inner3')
    
    const customerWithSelectedCompanies3 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.in(
            connection.selectFrom(tCompany).innerJoin(inner3).on(tCompany.id.equals(inner3.id))
                .where(tCompany.name.contains('Cia.'))
                .selectOneColumn(inner3.id)
        )).select({
            customerId: tCustomer.id,
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        })
        .executeSelectMany()
    
    assertEquals(customerWithSelectedCompanies3, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with innerInner4 as (select id as id, name as name from custom_company), inner4 as (select id as id, name as name from innerInner4) select id as customerId, first_name as customerFirstName, last_name as customerLastName from customer where company_id in (select inner4.id as result from company inner join inner4 on company.id = inner4.id where company.name like ('%' || ? || '%') escape '\\')`)
    expectedParams.push(`["Cia."]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const innerInner4 = connection.selectFrom(tCustomCompany).select({id: tCustomCompany.id, name: tCustomCompany.name}).forUseInQueryAs('innerInner4')
    const inner4 = connection.selectFrom(innerInner4).select({id: innerInner4.id, name: innerInner4.name}).forUseInQueryAs('inner4')
    
    const customerWithSelectedCompanies4 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.in(
            connection.selectFrom(tCompany).innerJoin(inner4).on(tCompany.id.equals(inner4.id))
                .where(tCompany.name.contains('Cia.'))
                .selectOneColumn(inner4.id)
        )).select({
            customerId: tCustomer.id,
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        })
        .executeSelectMany()
    
    assertEquals(customerWithSelectedCompanies4, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_group_array(json_object('id', id, 'firstName', first_name, 'lastName', last_name)) from customer where company_id = company.id) as customers from company where id = ?`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme4 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers4 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme4
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers4, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_group_array(json_object('id', a_1_.id, 'firstName', a_1_.firstName, 'lastName', a_1_.lastName)) from (select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id order by id) as a_1_) as customers from company where id = ?`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme5 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .orderBy('id')
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers5 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme5
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers5, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_group_array(first_name || ? || last_name) from customer where company_id = company.id) as customers from company where id = ?`)
    expectedParams.push(`[" ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme6 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers6 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme6.useEmptyArrayForNoValue()
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers6, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_group_array(a_1_.result) from (select first_name || ? || last_name as result from customer where company_id = company.id order by result) as a_1_) as customers from company where id = ?`)
    expectedParams.push(`[" ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme7 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        .orderBy('result')
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers7 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme7.useEmptyArrayForNoValue()
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers7, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_group_array(json_object('id', a_1_.id, 'firstName', a_1_.firstName, 'lastName', a_1_.lastName)) from (select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id union select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id) as a_1_) as customers from company where id = ?`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme8 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        }).union(
            connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            })
        )
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers8 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme8
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers8, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_group_array(json_object('id', a_1_.id, 'firstName', a_1_.firstName, 'lastName', a_1_.lastName)) from (select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id union select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id order by id) as a_1_) as customers from company where id = ?`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme9 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        }).union(
            connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            })
        ).orderBy('id')
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers9 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme9
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers9, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_group_array(a_1_.result) from (select first_name || ? || last_name as result from customer where company_id = company.id union select first_name || ? || last_name as result from customer where company_id = company.id) as a_1_) as customers from company where id = ?`)
    expectedParams.push(`[" "," ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme10 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        .union(
            connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        )
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers10 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme10.useEmptyArrayForNoValue()
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers10, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_group_array(a_1_.result) from (select first_name || ? || last_name as result from customer where company_id = company.id union select first_name || ? || last_name as result from customer where company_id = company.id order by result) as a_1_) as customers from company where id = ?`)
    expectedParams.push(`[" "," ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme11 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        .union(
            connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        ).orderBy('result')
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers11 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme11.useEmptyArrayForNoValue()
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers11, result)

    /* *** Preparation ************************************************************/

    result = { 
        id: 10, 
        name: 'Low Company', 
        parentId: 9, 
        parents: [
            { id: 9, name: 'Mic Company', parentId: 8 }, 
            { id: 8, name: 'Top Company' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, parent_id as parentId, (with recursive recursive_select_1 as (select parentCompany.id as id, parentCompany.name as name, parentCompany.parent_id as parentId from company as parentCompany where parentCompany.id = company.parent_id union all select parentCompany.id as id, parentCompany.name as name, parentCompany.parent_id as parentId from company as parentCompany join recursive_select_1 on recursive_select_1.parentId = parentCompany.id) select json_group_array(json_object('id', id, 'name', name, 'parentId', parentId)) from recursive_select_1) as parents from company where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const parentCompany2 = tCompany.as('parentCompany')

    const parentCompanies = connection.subSelectUsing(tCompany)
        .from(parentCompany2)
        .select({
            id: parentCompany2.id,
            name: parentCompany2.name,
            parentId: parentCompany2.parentId
        })
        .where(parentCompany2.id.equals(tCompany.parentId))
        .recursiveUnionAllOn((child) => {
            return child.parentId.equals(parentCompany2.id)
        })
        .forUseAsInlineAggregatedArrayValue()

    const lowCompany = await connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId,
            parents: parentCompanies
        })
        .where(tCompany.id.equals(10))
        .executeSelectOne()
    
    assertEquals(lowCompany, result)

    /* *** Preparation ************************************************************/

    result = { 
        id: 10, 
        name: 'Low Company', 
        parentId: 9, 
        parents: [
            { id: 9, name: 'Mic Company', parentId: 8 }, 
            { id: 8, name: 'Top Company' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select parentCompany.id as id, parentCompany.name as name, parentCompany.parent_id as parentId from company as parentCompany where parentCompany.id = ? union all select parentCompany.id as id, parentCompany.name as name, parentCompany.parent_id as parentId from company as parentCompany join recursive_select_1 on recursive_select_1.parentId = parentCompany.id) select id as id, name as name, parent_id as parentId, (select json_group_array(json_object('id', id, 'name', name, 'parentId', parentId)) from recursive_select_1) as parents from company where id = ?`)
    expectedParams.push(`[9,10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const parentCompanies2 = connection.selectFrom(parentCompany2)
        .select({
            id: parentCompany2.id,
            name: parentCompany2.name,
            parentId: parentCompany2.parentId
        })
        .where(parentCompany2.id.equals(9))
        .recursiveUnionAllOn((child) => {
            return child.parentId.equals(parentCompany2.id)
        })
        .forUseAsInlineAggregatedArrayValue()

    const lowCompany2 = await connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId,
            parents: parentCompanies2
        })
        .where(tCompany.id.equals(10))
        .executeSelectOne()
    
    assertEquals(lowCompany2, result)

    /* *** Preparation ************************************************************/

    result = { 
        id: 10, 
        name: 'Low Company', 
        parentId: 9, 
        parents: [
            { id: 9, name: 'Mic Company', parentId: 8 }, 
            { id: 8, name: 'Top Company' }
        ]
    }
    expectedResult.push({ id: 10, name: 'Low Company', parentId: 9 })
    expectedQuery.push(`select id as id, name as name, parent_id as parentId from company where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    expectedResult.push([{ startId: 9, id: 9, name: 'Mic Company', parentId: 8 }, { startId: 9, id: 8, name: 'Top Company' }])
    expectedQuery.push(`with recursive recursive_select_1 as (select parentCompany.id as id, parentCompany.name as name, parentCompany.parent_id as parentId, parentCompany.id as startId from company as parentCompany where parentCompany.id in (?) union all select parentCompany.id as id, parentCompany.name as name, parentCompany.parent_id as parentId, recursive_select_1.startId as startId from company as parentCompany join recursive_select_1 on recursive_select_1.parentId = parentCompany.id) select id as id, name as name, parentId as parentId, startId as startId from recursive_select_1`)
    expectedParams.push(`[9]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const lowCompany3 = await connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        })
        .where(tCompany.id.equals(10))
        .composeDeletingInternalProperty({
            externalProperty: 'parentId',
            internalProperty: 'startId',
            propertyName: 'parents'
        }).withMany((ids) => {
            return connection.selectFrom(parentCompany2)
                .select({
                    id: parentCompany2.id,
                    name: parentCompany2.name,
                    parentId: parentCompany2.parentId,
                    startId: parentCompany2.id
                })
                .where(parentCompany2.id.in(ids))
                .recursiveUnionAll((child) => {
                    return connection.selectFrom(parentCompany2)
                        .join(child).on(child.parentId.equals(parentCompany2.id))
                        .select({
                            id: parentCompany2.id,
                            name: parentCompany2.name,
                            parentId: parentCompany2.parentId,
                            startId: child.startId
                        })
                })
                .executeSelectMany()
        })
        .executeSelectOne()
    
    assertEquals(lowCompany3, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_blob(?), ?)`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    let insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        }).executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = { id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }
    expectedResult.push(result)
    expectedQuery.push(`select uuid_str(id) as id, title as title from record where uuid_str(id) like ('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const selectUuid = await connection.selectFrom(tRecord)
        .select({
            id: tRecord.id,
            title: tRecord.title
        })
        .where(tRecord.id.asString().contains('7002'))
        .executeSelectOne()

    assertEquals(selectUuid, result)

    /* *** Preparation ************************************************************/

    result = { id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }
    expectedResult.push(result)
    expectedQuery.push(`with with_uuit as (select id as id, title as title from record) select uuid_str(id) as id, title as title from with_uuit where uuid_str(id) like ('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const withSselectUuid = await connection.selectFrom(tRecord)
        .select({
            id: tRecord.id,
            title: tRecord.title
        })
        .forUseInQueryAs('with_uuit');

    const selectUuid2 = await connection.selectFrom(withSselectUuid)
        .select({
            id: withSselectUuid.id,
            title: withSselectUuid.title
        })
        .where(withSselectUuid.id.asString().contains('7002'))
        .executeSelectOne()

    assertEquals(selectUuid2, result)

    /* *** Preparation ************************************************************/

    result = { records: [{ id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }] }
    expectedResult.push(result)
    expectedQuery.push(`select (select json_group_array(json_object('id', uuid_str(id), 'title', title)) from record where uuid_str(id) like ('%' || ? || '%') escape '\\') as records`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedUuid = await connection.selectFrom(tRecord)
        .select({
            id: tRecord.id,
            title: tRecord.title
        })
        .where(tRecord.id.asString().contains('7002'))
        .forUseAsInlineAggregatedArrayValue()

    const selectUuid3 = await connection.selectFromNoTable()
        .select({
            records: aggregatedUuid,
        })
        .executeSelectOne()

    assertEquals(selectUuid3, result)

    /* *** Preparation ************************************************************/

    result = { records: [{ id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }] }
    expectedResult.push(result)
    expectedQuery.push(`select (select json_group_array(json_object('id', uuid_str(a_1_.id), 'title', a_1_.title)) from (select id as id, title as title from record where uuid_str(id) like ('%' || ? || '%') escape '\\' order by id) as a_1_) as records`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedUuid2 = await connection.selectFrom(tRecord)
        .select({
            id: tRecord.id,
            title: tRecord.title
        })
        .where(tRecord.id.asString().contains('7002'))
        .orderBy('id')
        .forUseAsInlineAggregatedArrayValue()

    const selectUuid4 = await connection.selectFromNoTable()
        .select({
            records: aggregatedUuid2,
        })
        .executeSelectOne()

    assertEquals(selectUuid4, result)

    /* *** Preparation ************************************************************/

    result = { records: [{ id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }] }
    expectedResult.push(result)
    expectedQuery.push(`select json_group_array(json_object('id', uuid_str(id), 'title', title)) as records from record where uuid_str(id) like ('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const selectUuid5 = await connection.selectFrom(tRecord)
        .select({
            records: connection.aggregateAsArray({
                id: tRecord.id,
                title: tRecord.title
            })
        })
        .where(tRecord.id.asString().contains('7002'))
        .executeSelectOne()

    assertEquals(selectUuid5, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_blob(?), ?) on conflict do nothing`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictDoNothing()
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_blob(?), ?) on conflict (title) do nothing`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOn(tRecord.title)
        .doNothing()
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_blob(?), ?) on conflict (title) where lower(title) like lower('%' || ? || '%') escape '\\' do nothing`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","memo"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOn(tRecord.title)
        .where(tRecord.title.containsInsensitive('memo'))
        .doNothing()
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_blob(?), ?) on conflict do update set title = ?`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","My voice memo 2"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictDoUpdateSet({
            title: 'My voice memo 2'
        })
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_blob(?), ?) on conflict (title) do update set title = ?`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","My voice memo 2"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOn(tRecord.title)
        .doUpdateSet({
            title: 'My voice memo 2'
        })
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_blob(?), ?) on conflict (title) where lower(title) like lower('%' || ? || '%') escape '\\' do update set title = ?`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","memo","My voice memo 2"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOn(tRecord.title)
        .where(tRecord.title.containsInsensitive('memo'))
        .doUpdateSet({
            title: 'My voice memo 2'
        })
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_blob(?), ?) on conflict do update set title = ? where lower(record.title) like lower('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","My voice memo 2","My"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictDoUpdateSet({
            title: 'My voice memo 2'
        })
        .where(tRecord.title.containsInsensitive('My'))
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_blob(?), ?) on conflict (title) do update set title = ? where lower(record.title) like lower('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","My voice memo 2","My"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOn(tRecord.title)
        .doUpdateSet({
            title: 'My voice memo 2'
        })
        .where(tRecord.title.containsInsensitive('My'))
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_blob(?), ?) on conflict (title) where lower(title) like lower('%' || ? || '%') escape '\\' do update set title = ? where lower(record.title) like lower('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","memo","My voice memo 2","My"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOn(tRecord.title)
        .where(tRecord.title.containsInsensitive('memo'))
        .doUpdateSet({
            title: 'My voice memo 2'
        })
        .where(tRecord.title.containsInsensitive('My'))
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_blob(?), ?) on conflict do update set title = record.title || ? || excluded.title`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo"," - "]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    const tRecordForInsert = tRecord.valuesForInsert()
    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictDoUpdateSet({
            title: tRecord.title.concat(' - ').concat(tRecordForInsert.title)
        })
        .executeInsert()
    assertEquals(insertUuid, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'John',
        lastName: 'Smith',
    }
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values (?, ?, ?) on conflict do update set first_name = customer.first_name || ? || excluded.first_name, last_name = customer.last_name || ? || excluded.last_name returning id as id, first_name as firstName, last_name as lastName`)
    expectedParams.push(`["John","Smith",1," - "," - "]`)
    expectedType.push(`insertReturningOneRow`)

    /* *** Example ****************************************************************/

    const tCustomerForInsert = tCustomer.valuesForInsert()
    const insertReturningCustomerData4 = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        })
        .onConflictDoUpdateSet({
            firstName: tCustomer.firstName.concat(' - ').concat(tCustomerForInsert.firstName),
            lastName: tCustomer.lastName.concat(' - ').concat(tCustomerForInsert.lastName)
        })
        .returning({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .executeInsertOne()

    assertEquals(insertReturningCustomerData4, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    let companyName: string | undefined = undefined

    let customers = await connection.selectFrom(tCustomer)
        .optionalJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .where(tCompany.name.equalsIfValue(companyName))
        .select(extractWritableColumnsFrom(tCustomer))
        .executeSelectMany()
    assertEquals(customers, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, customer.company_id as companyId from customer join company on company.id = customer.company_id where company.name = ?`)
    expectedParams.push(`["My company name"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    companyName = 'My company name'

    customers = await connection.selectFrom(tCustomer)
        .optionalJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .where(tCompany.name.equalsIfValue(companyName))
        .select(extractWritableColumnsFrom(tCustomer))
        .executeSelectMany()
    assertEquals(customers, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select first_name as firstName, last_name as lastName, birthday as birthday from customer where company_id = ?`)
    expectedParams.push(`[16]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const userCompanyId = 16
    let onlyCustomersOfUserCompany = true

    let customers2 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.equals(userCompanyId).onlyWhen(onlyCustomersOfUserCompany))
        .select({
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .executeSelectMany()
    assertEquals(customers2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select first_name as firstName, last_name as lastName, birthday as birthday from customer`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    onlyCustomersOfUserCompany = false

    customers2 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.equals(userCompanyId).onlyWhen(onlyCustomersOfUserCompany))
        .select({
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .executeSelectMany()
    assertEquals(customers2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || ? || last_name as name, calculateAge(birthday) as age from customer`)
    expectedParams.push(`[" "]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const customersWithAge = await connection.selectFrom(tCustomer)
        .select({
            id: tCustomer.id,
            name: tCustomer.name,
            age: tCustomer.age,
        })
        .executeSelectMany()
    assertEquals(customersWithAge, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as companyId, id as companyName, parent_id as companyParentId, parent_id as favouriteCustomerId from company where id = ? union all select company.id as companyId, company.id as companyName, company.parent_id as companyParentId, company.parent_id as favouriteCustomerId from company join recursive_select_1 on recursive_select_1.companyParentId = company.id) select companyId as companyId, companyName as companyName, companyParentId as companyParentId, favouriteCustomerId as favouriteCustomerId from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)

    expectedResult.push(0)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as companyId, id as companyName, parent_id as companyParentId, parent_id as favouriteCustomerId from company where id = ? union all select company.id as companyId, company.id as companyName, company.parent_id as companyParentId, company.parent_id as favouriteCustomerId from company join recursive_select_1 on recursive_select_1.companyParentId = company.id) select count(*) from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneColumnOneRow`)

    // const tCustomerLeftJoin = tCustomer.forUseInLeftJoin()
    
    const availableFields7 = {
        companyId: tCompany.id,
        companyName: tCompany.id,
        companyParentId: tCompany.parentId,
        favouriteCustomerId: tCompany.favouriteCustomerId,
        favouriteCustomerName: tCustomerLeftJoin.name
    };
    const fieldsToPick7 = {companyName: true, favouriteCustomerId: true};
    const pickedFields7 = dynamicPick(availableFields7, fieldsToPick7, ['companyId', 'companyParentId']);
    
    const companyTreeWithFavouriteCustomer = await connection.selectFrom(tCompany)
        .optionalLeftJoin(tCustomerLeftJoin).on(tCompany.favouriteCustomerId.equals(tCustomerLeftJoin.id))
        .where(tCompany.id.equals(10))
        .select(pickedFields7)
        .recursiveUnionAll((child) => {
            return connection.selectFrom(tCompany)
                .optionalLeftJoin(tCustomerLeftJoin).on(tCompany.favouriteCustomerId.equals(tCustomerLeftJoin.id))
                .join(child).on(child.companyParentId.equals(tCompany.id))
                .select(pickedFields7)
        })
        .executeSelectPage()
    assertEquals(companyTreeWithFavouriteCustomer, { data: result, count: 0})

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as companyId, id as companyName, parent_id as companyParentId, parent_id as favouriteCustomerId from company where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)

    expectedResult.push(0)
    expectedQuery.push(`select count(*) from company where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneColumnOneRow`)

    // const tCustomerLeftJoin = tCustomer.forUseInLeftJoin()
    
    const availableFields8 = {
        companyId: tCompany.id,
        companyName: tCompany.id,
        companyParentId: tCompany.parentId,
        favouriteCustomerId: tCompany.favouriteCustomerId,
        favouriteCustomerName: tCustomerLeftJoin.name
    };
    const fieldsToPick8 = {companyName: true, favouriteCustomerId: true};
    const pickedFields8 = dynamicPick(availableFields8, fieldsToPick8, ['companyId', 'companyParentId']);
    
    const companyWithFavouriteCustomer = await connection.selectFrom(tCompany)
        .optionalLeftJoin(tCustomerLeftJoin).on(tCompany.favouriteCustomerId.equals(tCustomerLeftJoin.id))
        .where(tCompany.id.equals(10))
        .select(pickedFields8)
        .executeSelectPage()
    assertEquals(companyWithFavouriteCustomer, { data: result, count: 0})

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`with customerForUpdate(id, firstName, lastName) as (values (?, ?, ?)) update customer set first_name = customerForUpdate.firstName, last_name = customerForUpdate.lastName from customerForUpdate where customer.id = customerForUpdate.id`)
    expectedParams.push(`[1,"First Name","Last Name"]`)
    expectedType.push(`update`)

    /* *** Example ****************************************************************/

    class VCustomerForUpdate extends Values<DBConnection, 'customerForUpdate'> {
        id = this.column('int')
        firstName = this.column('string')
        lastName = this.column('string')
    }
    const customerForUpdate = Values.create(VCustomerForUpdate, 'customerForUpdate', [{
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }])
    
    updateCustomer = await connection.update(tCustomer)
        .from(customerForUpdate)
        .set({
            firstName: customerForUpdate.firstName,
            lastName: customerForUpdate.lastName
        })
        .where(tCustomer.id.equals(customerForUpdate.id))
        .executeUpdate()
    
    assertEquals(updateCustomer, result)

    // /* *** Preparation ************************************************************/

    // result = 1
    // expectedResult.push(result)
    // expectedQuery.push(`with customerForDelete(firstName, lastName) as (values ($1, $2)) delete from customer using customerForDelete where customer.first_name = customerForDelete.firstName and customer.last_name = customerForDelete.lastName`)
    // expectedParams.push(`["First Name","Last Name"]`)
    // expectedType.push(`delete`)

    // /* *** Example ****************************************************************/

    // class VCustomerForDelete extends Values<DBConnection, 'customerForDelete'> {
    //     firstName = this.column('string')
    //     lastName = this.column('string')
    // }
    // const customerForDelete = Values.create(VCustomerForDelete, 'customerForDelete', [{
    //     firstName: 'First Name',
    //     lastName: 'Last Name'
    // }])
    
    // deleteCustomer = await connection.deleteFrom(tCustomer)
    //     .using(customerForDelete)
    //     .where(tCustomer.firstName.equals(customerForDelete.firstName))
    //     .and(tCustomer.lastName.equals(customerForDelete.lastName))
    //     .executeDelete()
    
    // assertEquals(deleteCustomer, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, ifnull((select count(*) as result from customer where company_id = company.id), ?) as numberOfCustomers from company`)
    expectedParams.push(`[0]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const numberOfCustomers = connection
        .subSelectUsing(tCompany)
        .from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(connection.countAll())
        .forUseAsInlineQueryValue()  // At this point is a value that you can use in other query
        .valueWhenNull(0)

    const companiesWithNumberOfCustomers = await connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name,
            numberOfCustomers: numberOfCustomers
        })
        .executeSelectMany()

    assertEquals(companiesWithNumberOfCustomers, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with customerCountPerCompany as BEFORE (select company.id as companyId, company.name as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.name) AFTER select companyId as acmeCompanyId, companyName as acmeCompanyName, customerCount as acmeCustomerCount from customerCountPerCompany where lower(companyName) like lower('%' || ? || '%') escape '\\'`)
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompanyWith2 = connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        }).groupBy('companyId', 'companyName')
        .customizeQuery({
            beforeWithQuery: connection.rawFragment`BEFORE`,
            afterWithQuery: connection.rawFragment`AFTER`
        })
        .forUseInQueryAs('customerCountPerCompany')
    
    const customerCountPerAcmeCompanies2 = await connection.selectFrom(customerCountPerCompanyWith2)
        .where(customerCountPerCompanyWith2.companyName.containsInsensitive('ACME'))
        .select({
            acmeCompanyId: customerCountPerCompanyWith2.companyId,
            acmeCompanyName: customerCountPerCompanyWith2.companyName,
            acmeCustomerCount: customerCountPerCompanyWith2.customerCount
        })
        .executeSelectMany()
    
    assertEquals(customerCountPerAcmeCompanies2, result)

    /* *** Preparation ************************************************************/

    result = [ 'id', 'firstName', 'lastName', 'birthday', 'companyId', 'name', 'age' ]

    /* *** Example ****************************************************************/

    const tCustomerColumnNames = extractColumnNamesFrom(tCustomer)

    assertEquals(tCustomerColumnNames, result)

    /* *** Preparation ************************************************************/

    result = [ 'id', 'firstName', 'lastName', 'birthday', 'companyId' ]

    /* *** Example ****************************************************************/

    const tCustomerWritableColumnNames = extractWritableColumnNamesFrom(tCustomer)

    assertEquals(tCustomerWritableColumnNames, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, null as lastName, birthday as birthday from customer where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    // const customerId = 10
    
    const customerWithIdWithRules = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName.onlyWhenOrNull(true),
            lastName: tCustomer.lastName.onlyWhenOrNull(false),
            birthday: tCustomer.birthday
        })
        .executeSelectOne()
    
    assertEquals(customerWithIdWithRules, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, null as lastName, birthday as birthday from customer where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    // const customerId = 10
    
    const customerWithIdWithRules2 = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName.ignoreWhenAsNull(false),
            lastName: tCustomer.lastName.ignoreWhenAsNull(true),
            birthday: tCustomer.birthday
        })
        .executeSelectOne()
    
    assertEquals(customerWithIdWithRules2, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    // const customerId = 10
    let diaplayNames = true
    
    const customerWithIdWithRules3 = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName.onlyWhenOrNull(diaplayNames),
            lastName: tCustomer.lastName.onlyWhenOrNull(diaplayNames),
            birthday: tCustomer.birthday
        })
        .executeSelectOne()
    
    assertEquals(customerWithIdWithRules3, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, null as firstName, null as lastName, birthday as birthday from customer where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    // const customerId = 10
    diaplayNames = false
    
    const customerWithIdWithRules4 = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName.onlyWhenOrNull(diaplayNames),
            lastName: tCustomer.lastName.onlyWhenOrNull(diaplayNames),
            birthday: tCustomer.birthday
        })
        .executeSelectOne()
    
    assertEquals(customerWithIdWithRules4, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, null as companyId, null as companyName from customer where id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    let canSeeCompanyInfo = false

    const customerWithOptionalCompany7 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday,
            companyId: tCompany.id.onlyWhenOrNull(canSeeCompanyInfo),
            companyName: tCompany.name.onlyWhenOrNull(canSeeCompanyInfo)
        })
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany7, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, company.id as companyId, company.name as companyName from customer inner join company on company.id = customer.company_id where customer.id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    canSeeCompanyInfo = true

    const customerWithOptionalCompany8 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday,
            companyId: tCompany.id.onlyWhenOrNull(canSeeCompanyInfo),
            companyName: tCompany.name.onlyWhenOrNull(canSeeCompanyInfo)
        })
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany8, result)
    
    /* *** Preparation ************************************************************/

    result = {
        data: [],
        count: 0
    }
    expectedResult.push([])
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName from customer where lower(first_name) like lower(? || '%') escape '\\' or lower(last_name) like lower(? || '%') escape '\\' group by id order by firstName, lastName limit ? offset ?`)
    expectedParams.push(`["Smi","Smi",10,20]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push(0)
    expectedQuery.push(`with result_for_count as (select id as id, first_name as firstName, last_name as lastName from customer where lower(first_name) like lower(? || '%') escape '\\' or lower(last_name) like lower(? || '%') escape '\\' group by id order by firstName, lastName) select count(*) from result_for_count`)
    expectedParams.push(`["Smi","Smi"]`)
    expectedType.push(`selectOneColumnOneRow`)
    
    /* *** Example ****************************************************************/

    const customerName2 = 'Smi'
    const customerPageWithName2 = await connection.selectFrom(tCustomer)
        .where(
            tCustomer.firstName.startsWithInsensitive(customerName2)
        ).or(
            tCustomer.lastName.startsWithInsensitive(customerName2)
        ).select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .groupBy(tCustomer.id)
        .orderBy('firstName')
        .orderBy('lastName')
        .limit(10)
        .offset(20)
        .executeSelectPage()
    
    assertEquals(customerPageWithName2, result)

    /* *** Preparation ************************************************************/

    result = {
        data: [],
        count: 0
    }
    expectedResult.push([])
    expectedQuery.push(`select distinct id as id, first_name as firstName, last_name as lastName from customer where lower(first_name) like lower(? || '%') escape '\\' or lower(last_name) like lower(? || '%') escape '\\' order by firstName, lastName limit ? offset ?`)
    expectedParams.push(`["Smi","Smi",10,20]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push(0)
    expectedQuery.push(`with result_for_count as (select distinct id as id, first_name as firstName, last_name as lastName from customer where lower(first_name) like lower(? || '%') escape '\\' or lower(last_name) like lower(? || '%') escape '\\' order by firstName, lastName) select count(*) from result_for_count`)
    expectedParams.push(`["Smi","Smi"]`)
    expectedType.push(`selectOneColumnOneRow`)
    
    /* *** Example ****************************************************************/

    const customerName3 = 'Smi'
    const customerPageWithName3 = await connection.selectDistinctFrom(tCustomer)
        .where(
            tCustomer.firstName.startsWithInsensitive(customerName3)
        ).or(
            tCustomer.lastName.startsWithInsensitive(customerName3)
        ).select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .orderBy('firstName')
        .orderBy('lastName')
        .limit(10)
        .offset(20)
        .executeSelectPage()
    
    assertEquals(customerPageWithName3, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update customer set first_name = ?, last_name = ? where id = ?`)
    expectedParams.push(`["John","Smith",12]`)
    expectedType.push(`update`)

    /* *** Example ****************************************************************/

    const shapedUpdateCustomerName = {
        id: 12,
        customerFirstName: 'John',
        customerLastName: 'Smith',
    }
    
    const shapedUpdateCustomerNameResult = await connection.update(tCustomer)
        .shapedAs({
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        })
        .set(shapedUpdateCustomerName)
        .where(tCustomer.id.equals(shapedUpdateCustomerName.id))
        .executeUpdate()

    assertEquals(shapedUpdateCustomerNameResult, result)

    // /* *** Preparation ************************************************************/

    // result = 1
    // expectedResult.push(result)
    // expectedQuery.push(`update customer inner join company on customer.company_id = company.id set customer.first_name = ?, customer.last_name = ?, company.name = ? where customer.id = ?`)
    // expectedParams.push(`["John","Smith","ACME Inc.",12]`)
    // expectedType.push(`update`)

    // /* *** Example ****************************************************************/

    // const shapedUpdateCustomerNameAndCompanyName = {
    //     id: 12,
    //     customerFirstName: 'John',
    //     customerLastName: 'Smith',
    //     companyName: 'ACME Inc.'
    // }
    
    // const shapedUpdateCustomerNameAndCompanyNameResult = await connection.update(tCustomer)
    //     .innerJoin(tCompany).on(tCustomer.companyId.equals(tCompany.id))
    //     .shapedAs({
    //         customerFirstName: tCustomer.firstName,
    //         customerLastName: tCustomer.lastName,
    //         companyName: tCompany.name
    //     })
    //     .set(shapedUpdateCustomerNameAndCompanyName)
    //     .where(tCustomer.id.equals(shapedUpdateCustomerName.id))
    //     .executeUpdate()

    // assertEquals(shapedUpdateCustomerNameAndCompanyNameResult, result)
}

main().then(() => {
    console.log('All ok')
    process.exit(0)
}).catch((e) => {
    console.error(e)
    process.exit(1)
})