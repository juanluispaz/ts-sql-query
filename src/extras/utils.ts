import type { ITableOrView } from "../utils/ITableOrView"
import { IValueSource, isValueSource, __getValueSourcePrivate, AnyValueSource } from "../expressions/values"
import { isColumn, __getColumnPrivate } from "../utils/Column"
import type { AutogeneratedIdColumnKeys, ColumnKeys, IdColumnKeys, ProvidedIdColumnKeys, WritableColumnKeys } from "./types"

type OnlyStringKey<KEY> = KEY extends string ? KEY : never

export function prefixCapitalized<O extends object, PREFIX extends string>(obj: O, prefix: PREFIX): { [K in OnlyStringKey<keyof O> as `${PREFIX}${Capitalize<K>}`]: O[K] } {
    if (!obj) {
        return obj
    }
    const result: any = {}
    for (let key in obj) {
        result[prefix + key.substr(0, 1).toUpperCase() + key.substr(1)] = obj[key]
    }
    return result
}

export function prefixMapForSplitCapitalized<O extends object, PREFIX extends string>(obj: O, prefix: PREFIX): { [K in OnlyStringKey<keyof O> as K]: `${PREFIX}${Capitalize<K>}` } {
    if (!obj) {
        return obj
    }
    const result: any = {}
    for (let key in obj) {
        result[key] = prefix + key.substr(0, 1).toUpperCase() + key.substr(1)
    }
    return result
}

type CapitalizedGuided<PREFIX extends string, KEY extends string, REFERENCE extends object> = KEY extends keyof REFERENCE
    ? (
        REFERENCE[KEY] extends IValueSource<any, any, any, infer OPTIONAL_TYPE>
        ? (
            OPTIONAL_TYPE extends 'required'
            ? `${PREFIX}${Capitalize<KEY>}!`
            : `${PREFIX}${Capitalize<KEY>}`
        ) : `${PREFIX}${Capitalize<KEY>}`
    ) : `${PREFIX}${Capitalize<KEY>}`

export function prefixMapForGuidedSplitCapitalized<O extends object, R extends ITableOrView<any> | { [KEY in keyof O]?: AnyValueSource }, PREFIX extends string>(obj: O, reference: R, prefix: PREFIX): { [K in OnlyStringKey<keyof O> as K]: CapitalizedGuided<PREFIX, K, R> } {
    if (!obj) {
        return obj
    }
    const result: any = {}
    for (let key in obj) {
        const r = (reference as any)[key]
        if (isValueSource(r) && __getValueSourcePrivate(r).__optionalType === 'required') {
            result[key] = prefix + key.substr(0, 1).toUpperCase() + key.substr(1) + '!'
        } else {
            result[key] = prefix + key.substr(0, 1).toUpperCase() + key.substr(1)
        }
    }
    return result
}

type NameGuided<KEY extends string, REFERENCE extends object> = KEY extends keyof REFERENCE
    ? (
        REFERENCE[KEY] extends IValueSource<any, any, any, infer OPTIONAL_TYPE>
        ? (
            OPTIONAL_TYPE extends 'required'
            ? `${KEY}!`
            : KEY
        ) : KEY
    ) : KEY

export function mapForGuidedSplit<O extends object, R extends ITableOrView<any> | { [KEY in keyof O]?: AnyValueSource } >(obj: O, reference: R): { [K in OnlyStringKey<keyof O> as K]: NameGuided<K, R> } {
    if (!obj) {
        return obj
    }
    const result: any = {}
    for (let key in obj) {
        const r = (reference as any)[key]
        if (isValueSource(r) && __getValueSourcePrivate(r).__optionalType === 'required') {
            result[key] = key + '!'
        } else {
            result[key] = key
        }
    }
    return result
}

export function prefixDotted<O extends object, PREFIX extends string>(obj: O, prefix: PREFIX): { [K in OnlyStringKey<keyof O> as `${PREFIX}.${K}`]-?: O[K] } {
    if (!obj) {
        return obj
    }
    const result: any = {}
    for (let key in obj) {
        result[prefix + '.' + key] = obj[key]
    }
    return result
}

export function prefixMapForSplitDotted<O extends object, PREFIX extends string>(obj: O, prefix: PREFIX): { [K in OnlyStringKey<keyof O> as K]-?: `${PREFIX}.${K}` } {
    if (!obj) {
        return obj
    }
    const result: any = {}
    for (let key in obj) {
        result[key] = prefix + '.' + key
    }
    return result
}

type DottedGuided<PREFIX extends string, KEY extends string, REFERENCE extends object> = KEY extends keyof REFERENCE
    ? (
        REFERENCE[KEY] extends IValueSource<any, any, any, infer OPTIONAL_TYPE>
        ? (
            OPTIONAL_TYPE extends 'required'
            ? `${PREFIX}.${KEY}!`
            : `${PREFIX}.${KEY}`
        ) : `${PREFIX}.${KEY}`
    ) : `${PREFIX}.${KEY}`

export function prefixMapForGuidedSplitDotted<O extends object, R extends ITableOrView<any> | { [KEY in keyof O]?: AnyValueSource }, PREFIX extends string>(obj: O, reference: R, prefix: PREFIX): { [K in OnlyStringKey<keyof O> as K]: DottedGuided<PREFIX, K, R> } {
    if (!obj) {
        return obj
    }
    const result: any = {}
    for (let key in obj) {
        const r = (reference as any)[key]
        if (isValueSource(r) && __getValueSourcePrivate(r).__optionalType === 'required') {
            result[key] = prefix + '.' + key + '!'
        } else {
            result[key] = prefix + '.' + key
        }
    }
    return result
}

export function extractColumnsFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): { [K in Exclude<ColumnKeys<O>, EXCLUDE>]: O[K] } {
    if (!obj) {
        return obj
    }
    const ignore: any = {}
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true
        }
    }

    const result: any = {}
    for (let key in obj) {
        if (key in ignore) {
            continue
        }
        const value = obj[key]
        if (isValueSource(value)) {
            result[key] = value
        }
    }
    return result
}

export function extractWritableColumnsFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): { [K in Exclude<WritableColumnKeys<O>, EXCLUDE>]: O[K] } {
    if (!obj) {
        return obj
    }
    const ignore: any = {}
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true
        }
    }
    
    const result: any = {}
    for (let key in obj) {
        if (key in ignore) {
            continue
        }
        const value = obj[key]
        if (isColumn(value)) {
            if (!__getColumnPrivate(value).__isComputed) {
                result[key] = value
            }
        }
    }
    return result
}

export function extractIdColumnsFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): { [K in Exclude<IdColumnKeys<O>, EXCLUDE>]: O[K] } {
    if (!obj) {
        return obj
    }
    const ignore: any = {}
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true
        }
    }
    
    const result: any = {}
    for (let key in obj) {
        if (key in ignore) {
            continue
        }
        const value = obj[key]
        if (isColumn(value)) {
            const columnPrivate = __getColumnPrivate(value)
            if (columnPrivate.__isPrimaryKey) {
                result[key] = value
            }
        }
    }
    return result
}

export function extractAutogeneratedIdColumnsFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): { [K in Exclude<AutogeneratedIdColumnKeys<O>, EXCLUDE>]: O[K] } {
    if (!obj) {
        return obj
    }
    const ignore: any = {}
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true
        }
    }
    
    const result: any = {}
    for (let key in obj) {
        if (key in ignore) {
            continue
        }
        const value = obj[key]
        if (isColumn(value)) {
            const columnPrivate = __getColumnPrivate(value)
            if (columnPrivate.__isAutogeneratedPrimaryKey) {
                result[key] = value
            }
        }
    }
    return result
}

export function extractProvidedIdColumnsFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): { [K in Exclude<ProvidedIdColumnKeys<O>, EXCLUDE>]: O[K] } {
    if (!obj) {
        return obj
    }
    const ignore: any = {}
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true
        }
    }
    
    const result: any = {}
    for (let key in obj) {
        if (key in ignore) {
            continue
        }
        const value = obj[key]
        if (isColumn(value)) {
            const columnPrivate = __getColumnPrivate(value)
            if (columnPrivate.__isPrimaryKey && !columnPrivate.__isAutogeneratedPrimaryKey) {
                result[key] = value
            }
        }
    }
    return result
}

export function extractColumnNamesFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): Exclude<ColumnKeys<O>, EXCLUDE>[] {
    if (!obj) {
        return []
    }
    const ignore: any = {}
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true
        }
    }

    const result: any[] = []
    for (let key in obj) {
        if (key in ignore) {
            continue
        }
        const value = obj[key]
        if (isValueSource(value)) {
            result.push(key)
        }
    }
    return result
}

export function extractWritableColumnNamesFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): Exclude<WritableColumnKeys<O>, EXCLUDE>[] {
    if (!obj) {
        return []
    }
    const ignore: any = {}
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true
        }
    }

    const result: any[] = []
    for (let key in obj) {
        if (key in ignore) {
            continue
        }
        const value = obj[key]
        if (isColumn(value)) {
            if (!__getColumnPrivate(value).__isComputed) {
                result.push(key)
            }
        }
    }
    return result
}

export function extractIdColumnNamesFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): Exclude<IdColumnKeys<O>, EXCLUDE>[] {
    if (!obj) {
        return []
    }
    const ignore: any = {}
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true
        }
    }

    const result: any[] = []
    for (let key in obj) {
        if (key in ignore) {
            continue
        }
        const value = obj[key]
        if (isColumn(value)) {
            const columnPrivate = __getColumnPrivate(value)
            if (columnPrivate.__isPrimaryKey) {
                result.push(key)
            }
        }
    }
    return result
}

export function extractAutogeneratedIdColumnNamesFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): Exclude<AutogeneratedIdColumnKeys<O>, EXCLUDE>[] {
    if (!obj) {
        return []
    }
    const ignore: any = {}
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true
        }
    }

    const result: any[] = []
    for (let key in obj) {
        if (key in ignore) {
            continue
        }
        const value = obj[key]
        if (isColumn(value)) {
            const columnPrivate = __getColumnPrivate(value)
            if (columnPrivate.__isAutogeneratedPrimaryKey) {
                result.push(key)
            }
        }
    }
    return result
}

export function extractProvidedIdColumnNamesFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): Exclude<AutogeneratedIdColumnKeys<O>, EXCLUDE>[] {
    if (!obj) {
        return []
    }
    const ignore: any = {}
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true
        }
    }

    const result: any[] = []
    for (let key in obj) {
        if (key in ignore) {
            continue
        }
        const value = obj[key]
        if (isColumn(value)) {
            const columnPrivate = __getColumnPrivate(value)
            if (columnPrivate.__isPrimaryKey && !columnPrivate.__isAutogeneratedPrimaryKey) {
                result.push(key)
            }
        }
    }
    return result
}

export function extractWritableShapeFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): { [K in Exclude<WritableColumnKeys<O>, EXCLUDE>]: K } {
    if (!obj) {
        return obj
    }
    const ignore: any = {}
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true
        }
    }
    
    const result: any = {}
    for (let key in obj) {
        if (key in ignore) {
            continue
        }
        const value = obj[key]
        if (isColumn(value)) {
            if (!__getColumnPrivate(value).__isComputed) {
                result[key] = key
            }
        }
    }
    return result
}
