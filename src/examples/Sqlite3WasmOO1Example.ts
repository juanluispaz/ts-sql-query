/*
 * npm install @sqlite.org/sqlite-wasm
 */

import { Table } from "../Table";
import { assertEquals } from "./assertEquals";
import { ConsoleLogQueryRunner } from "../queryRunners/ConsoleLogQueryRunner";
import { SqliteConnection } from "../connections/SqliteConnection";
// @ts-ignore // TODO: remove when mjs conversion
import type { Database } from '@sqlite.org/sqlite-wasm';
// import { fromBinaryUUID, toBinaryUUID } from "binary-uuid";
// import { v4 as uuidv4 } from "uuid";
import { SqliteDateTimeFormat, SqliteDateTimeFormatType } from "../connections/SqliteConfiguration";
import { Values } from "../Values";
import { CustomBooleanTypeAdapter } from "../TypeAdapter";
import { Sqlite3WasmOO1QueryRunner } from "../queryRunners/Sqlite3WasmOO1QueryRunner";

class DBConnection extends SqliteConnection<'DBConnection'> {
    protected compatibilityMode = false
    protected uuidStrategy = 'string' as const

    protected getDateTimeFormat(_type: SqliteDateTimeFormatType): SqliteDateTimeFormat {
        return 'Julian day as real number'
    }

    increment(i: number) {
        // Fake implentation for testing purposes
        return this.selectFromNoTable().selectOneColumn(this.const(i, 'int').add(1)).executeSelectOne()
    }
    appendToAllCompaniesName(aditional: string) {
        // Fake implentation for testing purposes
        return this.updateAllowingNoWhere(tCompany).set({
            name: tCompany.name.concat(aditional)
        })
        .executeUpdate()
    }
}

const tCompany = new class TCompany extends Table<DBConnection, 'TCompany'> {
    id = this.autogeneratedPrimaryKey('id', 'int');
    name = this.column('name', 'string');
    parentId = this.optionalColumn('parent_id', 'int');
    constructor() {
        super('company'); // table name in the database
    }
}()

const tCustomer = new class TCustomer extends Table<DBConnection, 'TCustomer'> {
    id = this.autogeneratedPrimaryKey('id', 'int');
    firstName = this.column('first_name', 'string');
    lastName = this.column('last_name', 'string');
    birthday = this.optionalColumn('birthday', 'localDate');
    companyId = this.column('company_id', 'int');
    constructor() {
        super('customer'); // table name in the database
    }
}()

const tRecord = new class TRecord extends Table<DBConnection, 'TRecord'> {
    id = this.primaryKey('id', 'uuid');
    title = this.column('title', 'string');
    constructor() {
        super('record'); // table name in the database
    }
}()

const tBoolean = new class TBoolean extends Table<DBConnection, 'TBoolean'> {
    id = this.autogeneratedPrimaryKey('id', 'int');
    boolA = this.column('bool_a', 'boolean');
    optionalBoolB = this.optionalColumn('opt_bool_b', 'boolean');
    customBooleanC = this.column('bool_c', 'boolean', new CustomBooleanTypeAdapter('T', 'F'));
    customBooleanD = this.column('bool_d', 'boolean', new CustomBooleanTypeAdapter('Y', 'N'));
    customOptionalBooleanE = this.optionalColumn('opt_bool_e', 'boolean', new CustomBooleanTypeAdapter('T', 'F'));
    customOptionalBooleanF = this.optionalColumn('opt_bool_f', 'boolean', new CustomBooleanTypeAdapter('Y', 'N'));
    constructor() {
        super('boolean_table'); // table name in the database
    }
}()

//const db = new sqlite3(Database()
// db.function('uuid', uuidv4 as (_: unknown) => unknown)
// db.function('uuid_str', fromBinaryUUID as (_: unknown) => unknown)
// db.function('uuid_blob', toBinaryUUID as (_: unknown) => unknown)

async function main(db: Database) {
    const connection = new DBConnection(new ConsoleLogQueryRunner(new Sqlite3WasmOO1QueryRunner(db)))
    await connection.beginTransaction()

    try {
        await connection.queryRunner.executeDatabaseSchemaModification(`drop table if exists customer`)
        await connection.queryRunner.executeDatabaseSchemaModification(`drop table if exists company`)

        await connection.queryRunner.executeDatabaseSchemaModification(`
            create table company (
                id integer primary key autoincrement,
                name varchar(100) not null,
                parent_id int null references company(id)
            )
        `)

        await connection.queryRunner.executeDatabaseSchemaModification(`
            create table customer (
                id integer primary key autoincrement,
                first_name varchar(100) not null,
                last_name varchar(100) not null,
                birthday date,
                company_id int not null references company(id)
            )
        `)

        await connection.queryRunner.executeDatabaseSchemaModification(`drop table if exists record`)
        await connection.queryRunner.executeDatabaseSchemaModification(`
            create table record (
                id blob(16) primary key,
                title varchar(100) not null
            )
        `)

        await connection.queryRunner.executeDatabaseSchemaModification(`drop table if exists boolean_table`)
        await connection.queryRunner.executeDatabaseSchemaModification(`
            create table boolean_table (
                id integer primary key autoincrement,
                bool_a int1 not null check (bool_a = 0 or bool_a = 1),
                opt_bool_b int1 null check (opt_bool_b = 0 or opt_bool_b = 1),
                bool_c char1 not null check (bool_c = 'T' or bool_c = 'F'),
                bool_d char1 not null check (bool_d = 'Y' or bool_d = 'N'),
                opt_bool_e char1 null check (opt_bool_e = 'T' or opt_bool_e = 'F'),
                opt_bool_f char1 null check (opt_bool_f = 'Y' or opt_bool_f = 'N')
            )
        `)

        let i = await connection
            .insertInto(tCompany)
            .values({ name: 'ACME' })
            .returningLastInsertedId()
            .executeInsert()
        assertEquals(i, 1)
        
        const companyIdOne = await connection.selectFrom(tCompany).where(tCompany.id.in([1])).selectOneColumn(tCompany.id).executeSelectMany()
        assertEquals(companyIdOne, [1])

        const companyIdEmpty = await connection.selectFrom(tCompany).where(tCompany.id.in([])).selectOneColumn(tCompany.id).executeSelectMany()
        assertEquals(companyIdEmpty, [])

        i = await connection
            .insertInto(tCompany)
            .values({ name: 'FOO' })
            .executeInsert()
        assertEquals(i, 1)

        i = await connection
            .insertInto(tCustomer)
            .values({ firstName: 'John', lastName: 'Smith', companyId: 1 })
            .returningLastInsertedId()
            .executeInsert()
        assertEquals(i, 1)
                
        i = await connection
            .insertInto(tCustomer)
            .values({ firstName: 'Other', lastName: 'Person', companyId: 1 })
            .returningLastInsertedId()
            .executeInsert()
        assertEquals(i, 2)

        i = await connection
            .insertInto(tCustomer)
            .values({ firstName: 'Jane', lastName: 'Doe', companyId: 1 })
            .returningLastInsertedId()
            .executeInsert()
        assertEquals(i, 3)

        let company = await connection
            .selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .select({
                id: tCompany.id,
                name: tCompany.name
            })
            .executeSelectOne()
        assertEquals(company, { id: 1, name: 'ACME' })

        let companies = await connection
            .selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name
            })
            .orderBy('id')
            .executeSelectMany()
        assertEquals(companies, [{ id: 1, name: 'ACME' }, { id: 2, name: 'FOO' }])

        let name = await connection
            .selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .selectOneColumn(tCompany.name)
            .executeSelectOne()
        assertEquals(name, 'ACME')

        let names = await connection
            .selectFrom(tCompany)
            .selectOneColumn(tCompany.name)
            .orderBy('result')
            .executeSelectMany()
        assertEquals(names, ['ACME', 'FOO'])

        i = await connection
            .insertInto(tCompany)
            .from(
                connection
                .selectFrom(tCompany)
                .select({
                    name: tCompany.name.concat(' 2')
                })
            )
            .executeInsert()
        assertEquals(i, 2)

        names = await connection
            .selectFrom(tCompany)
            .selectOneColumn(tCompany.name)
            .orderBy('result')
            .executeSelectMany()
        assertEquals(names, ['ACME', 'ACME 2', 'FOO', 'FOO 2'])

        const fooComanyNameLength = connection
            .selectFrom(tCompany)
            .selectOneColumn(tCompany.name.length())
            .where(tCompany.id.equals(2))
            .forUseAsInlineQueryValue()

        companies = await connection
            .selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name
            })
            .where(tCompany.name.length().greaterThan(fooComanyNameLength))
            .orderBy('id')
            .executeSelectMany()
        assertEquals(companies, [{ id: 1, name: 'ACME' },{ id: 3, name: 'ACME 2' }, { id: 4, name: 'FOO 2'}])

        i = await connection
            .update(tCompany)
            .set({
                name: tCompany.name.concat(tCompany.name)
            })
            .where(tCompany.id.equals(2))
            .executeUpdate()
        assertEquals(i, 1)

        name = await connection
            .selectFrom(tCompany)
            .where(tCompany.id.equals(2))
            .selectOneColumn(tCompany.name)
            .executeSelectOne()
        assertEquals(name, 'FOOFOO')

        i = await connection
            .deleteFrom(tCompany)
            .where(tCompany.id.equals(2))
            .executeDelete()
        assertEquals(i, 1)

        let maybe = await connection
            .selectFrom(tCompany)
            .where(tCompany.id.equals(2))
            .selectOneColumn(tCompany.name)
            .executeSelectNoneOrOne()
        assertEquals(maybe, null)

        let page = await connection
            .selectFrom(tCustomer)
            .select({
                id: tCustomer.id,
                name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName)
            })
            .orderBy('id')
            .limit(2)
            .executeSelectPage()
        assertEquals(page, {
            count: 3,
            data: [
                { id: 1, name: 'John Smith' },
                { id: 2, name: 'Other Person' }
            ]
        })

        const customerCountPerCompanyWith = connection.selectFrom(tCompany)
            .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
            .select({
                companyId: tCompany.id,
                companyName: tCompany.name,
                endsWithME: tCompany.name.endsWithInsensitive('me'),
                customerCount: connection.count(tCustomer.id)
            }).groupBy('companyId', 'companyName', 'endsWithME')
            .forUseInQueryAs('customerCountPerCompany')

        const customerCountPerAcmeCompanies = await connection.selectFrom(customerCountPerCompanyWith)
            .where(customerCountPerCompanyWith.companyName.containsInsensitive('ACME'))
            .select({
                acmeCompanyId: customerCountPerCompanyWith.companyId,
                acmeCompanyName: customerCountPerCompanyWith.companyName,
                acmeEndsWithME: customerCountPerCompanyWith.endsWithME,
                acmeCustomerCount: customerCountPerCompanyWith.customerCount
            })
            .executeSelectMany()
        assertEquals(customerCountPerAcmeCompanies, [
            { acmeCompanyId: 1, acmeCompanyName: 'ACME', acmeEndsWithME: true, acmeCustomerCount: 3 }
        ])

        const aggregatedCustomersOfAcme = connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .selectOneColumn(connection.aggregateAsArray({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            }))
            .forUseAsInlineQueryValue()

        const acmeCompanyWithCustomers = await connection.selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                customers: aggregatedCustomersOfAcme
            })
            .executeSelectOne()
        acmeCompanyWithCustomers.customers!.sort((a, b) => {
            return a.id - b.id
        })
        assertEquals(acmeCompanyWithCustomers, {
            id: 1,
            name: 'ACME',
            customers: [
                { id: 1, firstName: 'John', lastName: 'Smith' },
                { id: 2, firstName: 'Other', lastName: 'Person' },
                { id: 3, firstName: 'Jane', lastName: 'Doe' }
            ]
        })

        const tCustomerLeftJoin = tCustomer.forUseInLeftJoin()
        const acmeCompanyWithCustomers2 = await connection.selectFrom(tCompany).leftJoin(tCustomerLeftJoin).on(tCustomerLeftJoin.companyId.equals(tCompany.id))
            .where(tCompany.id.equals(1))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                customers: connection.aggregateAsArray({
                    id: tCustomerLeftJoin.id,
                    firstName: tCustomerLeftJoin.firstName,
                    lastName: tCustomerLeftJoin.lastName
                }).useEmptyArrayForNoValue()
            })
            .groupBy('id')
            .executeSelectOne()
        acmeCompanyWithCustomers2.customers!.sort((a, b) => {
            return a.id - b.id
        })
        assertEquals(acmeCompanyWithCustomers2, {
            id: 1,
            name: 'ACME',
            customers: [
                { id: 1, firstName: 'John', lastName: 'Smith' },
                { id: 2, firstName: 'Other', lastName: 'Person' },
                { id: 3, firstName: 'Jane', lastName: 'Doe' }
            ]
        })

        const aggregatedCustomersOfAcme3 = connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .selectOneColumn(connection.aggregateAsArrayOfOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName)))
            .forUseAsInlineQueryValue()

        const acmeCompanyWithCustomers3 = await connection.selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                customers: aggregatedCustomersOfAcme3.useEmptyArrayForNoValue()
            })
            .executeSelectOne()
        acmeCompanyWithCustomers3.customers.sort()
        assertEquals(acmeCompanyWithCustomers3, {
            id: 1,
            name: 'ACME',
            customers: [
                'Jane Doe',
                'John Smith',
                'Other Person'
            ]
        })

        const aggregatedCustomersOfAcme4 = connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            })
            .forUseAsInlineAggregatedArrayValue()

        const acmeCompanyWithCustomers4 = await connection.selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                customers: aggregatedCustomersOfAcme4
            })
            .executeSelectOne()
        acmeCompanyWithCustomers4.customers!.sort((a, b) => {
            return a.id - b.id
        })
        assertEquals(acmeCompanyWithCustomers4, {
            id: 1,
            name: 'ACME',
            customers: [
                { id: 1, firstName: 'John', lastName: 'Smith' },
                { id: 2, firstName: 'Other', lastName: 'Person' },
                { id: 3, firstName: 'Jane', lastName: 'Doe' }
            ]
        })

        const aggregatedCustomersOfAcme5 = connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            })
            .orderBy('id')
            .forUseAsInlineAggregatedArrayValue()

        const acmeCompanyWithCustomers5 = await connection.selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                customers: aggregatedCustomersOfAcme5
            })
            .executeSelectOne()
        assertEquals(acmeCompanyWithCustomers5, {
            id: 1,
            name: 'ACME',
            customers: [
                { id: 1, firstName: 'John', lastName: 'Smith' },
                { id: 2, firstName: 'Other', lastName: 'Person' },
                { id: 3, firstName: 'Jane', lastName: 'Doe' }
            ]
        })

        const aggregatedCustomersOfAcme6 = connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
            .forUseAsInlineAggregatedArrayValue()

        const acmeCompanyWithCustomers6 = await connection.selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                customers: aggregatedCustomersOfAcme6.useEmptyArrayForNoValue()
            })
            .executeSelectOne()
        acmeCompanyWithCustomers6.customers.sort()
        assertEquals(acmeCompanyWithCustomers6, {
            id: 1,
            name: 'ACME',
            customers: [
                'Jane Doe',
                'John Smith',
                'Other Person'
            ]
        })

        const aggregatedCustomersOfAcme7 = connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
            .orderBy('result')
            .forUseAsInlineAggregatedArrayValue()

        const acmeCompanyWithCustomers7 = await connection.selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                customers: aggregatedCustomersOfAcme7.useEmptyArrayForNoValue()
            })
            .executeSelectOne()
        assertEquals(acmeCompanyWithCustomers7, {
            id: 1,
            name: 'ACME',
            customers: [
                'Jane Doe',
                'John Smith',
                'Other Person'
            ]
        })

        const aggregatedCustomersOfAcme8 = connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            }).union(
                connection.subSelectUsing(tCompany).from(tCustomer)
                .where(tCustomer.companyId.equals(tCompany.id))
                .select({
                    id: tCustomer.id,
                    firstName: tCustomer.firstName,
                    lastName: tCustomer.lastName
                })
            )
            .forUseAsInlineAggregatedArrayValue()

        const acmeCompanyWithCustomers8 = await connection.selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                customers: aggregatedCustomersOfAcme8
            })
            .executeSelectOne()
        acmeCompanyWithCustomers8.customers!.sort((a, b) => {
            return a.id - b.id
        })
        assertEquals(acmeCompanyWithCustomers8, {
            id: 1,
            name: 'ACME',
            customers: [
                { id: 1, firstName: 'John', lastName: 'Smith' },
                { id: 2, firstName: 'Other', lastName: 'Person' },
                { id: 3, firstName: 'Jane', lastName: 'Doe' }
            ]
        })

        const aggregatedCustomersOfAcme9 = connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            }).union(
                connection.subSelectUsing(tCompany).from(tCustomer)
                .where(tCustomer.companyId.equals(tCompany.id))
                .select({
                    id: tCustomer.id,
                    firstName: tCustomer.firstName,
                    lastName: tCustomer.lastName
                })
            ).orderBy('id')
            .forUseAsInlineAggregatedArrayValue()

        const acmeCompanyWithCustomers9 = await connection.selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                customers: aggregatedCustomersOfAcme9
            })
            .executeSelectOne()
        assertEquals(acmeCompanyWithCustomers9, {
            id: 1,
            name: 'ACME',
            customers: [
                { id: 1, firstName: 'John', lastName: 'Smith' },
                { id: 2, firstName: 'Other', lastName: 'Person' },
                { id: 3, firstName: 'Jane', lastName: 'Doe' }
            ]
        })

        const aggregatedCustomersOfAcme10 = connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
            .union(
                connection.subSelectUsing(tCompany).from(tCustomer)
                .where(tCustomer.companyId.equals(tCompany.id))
                .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
            )
            .forUseAsInlineAggregatedArrayValue()

        const acmeCompanyWithCustomers10 = await connection.selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                customers: aggregatedCustomersOfAcme10.useEmptyArrayForNoValue()
            })
            .executeSelectOne()
        acmeCompanyWithCustomers10.customers.sort()
        assertEquals(acmeCompanyWithCustomers10, {
            id: 1,
            name: 'ACME',
            customers: [
                'Jane Doe',
                'John Smith',
                'Other Person'
            ]
        })

        const aggregatedCustomersOfAcme11 = connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
            .union(
                connection.subSelectUsing(tCompany).from(tCustomer)
                .where(tCustomer.companyId.equals(tCompany.id))
                .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
            ).orderBy('result')
            .forUseAsInlineAggregatedArrayValue()

        const acmeCompanyWithCustomers11 = await connection.selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                customers: aggregatedCustomersOfAcme11.useEmptyArrayForNoValue()
            })
            .executeSelectOne()
        assertEquals(acmeCompanyWithCustomers11, {
            id: 1,
            name: 'ACME',
            customers: [
                'Jane Doe',
                'John Smith',
                'Other Person'
            ]
        })

        i = await connection.increment(10)
        assertEquals(i, 11)

        await connection.appendToAllCompaniesName(' Cia.')

        name = await connection
            .selectFrom(tCompany)
            .where(tCompany.id.equals(1))
            .selectOneColumn(tCompany.name)
            .executeSelectOne()
        assertEquals(name, 'ACME Cia.')

        let ii = await connection
            .insertInto(tCompany)
            .from(
                connection
                .selectFrom(tCompany)
                .select({
                    name: tCompany.name.concat(' 3')
                })
            )
            .returningLastInsertedId()
            .executeInsert()
        assertEquals(ii, [5, 6, 7])

        const updatedSmithFirstName = await connection.update(tCustomer)
            .set({
                firstName: 'Ron'
            })
            .where(tCustomer.id.equals(1))
            .returningOneColumn(tCustomer.firstName)
            .executeUpdateOne()
        assertEquals(updatedSmithFirstName, 'Ron')

        const deletedCustomers = await connection.deleteFrom(tCustomer)
            .where(tCustomer.id.greaterOrEquals(2))
            .returning({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            })
            .executeDeleteMany()
        deletedCustomers.sort((a, b) => {
            return a.id - b.id
        })
        assertEquals(deletedCustomers, [{ id: 2, firstName: 'Other', lastName: 'Person' }, { id:3, firstName: 'Jane', lastName: 'Doe' } ])

        let insertOneCustomers = await connection
            .insertInto(tCustomer)
            .values({ firstName: 'Other', lastName: 'Person', companyId: 1 })
            .returning({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            })
            .executeInsertOne()
        assertEquals(insertOneCustomers, { id: 4, firstName: 'Other', lastName: 'Person' })

        const insertMultipleCustomers = await connection
            .insertInto(tCustomer)
            .values([
                { firstName: 'Other 2', lastName: 'Person 2', companyId: 1 },
                { firstName: 'Other 3', lastName: 'Person 3', companyId: 1 }
            ])
            .returning({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            })
            .executeInsertMany()
        assertEquals(insertMultipleCustomers, [ { id: 5, firstName: 'Other 2', lastName: 'Person 2' }, { id: 6, firstName: 'Other 3', lastName: 'Person 3' }])

        insertOneCustomers = await connection
            .insertInto(tCustomer)
            .from(
                connection
                .selectFrom(tCustomer)
                .select({
                    firstName: tCustomer.firstName.concat(' 2'),
                    lastName: tCustomer.lastName.concat(' 2'),
                    companyId: tCustomer.companyId
                })
                .where(tCustomer.id.equals(1))
            )
            .returning({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            })
            .executeInsertOne()
        assertEquals(insertOneCustomers, { id: 7, firstName: 'Ron 2', lastName: 'Smith 2' })

        i = await connection.update(tCustomer)
            .from(tCompany)
            .set({
                lastName: tCustomer.lastName.concat(' - ').concat(tCompany.name)
            })
            .where(tCustomer.companyId.equals(tCompany.id))
            .and(tCustomer.id.equals(1))
            .executeUpdate()
        assertEquals(i, 1)

        const companiesIds = await connection.insertInto(tCompany)
            .values([
                {name: 'Top Company'},
                {name: 'Mic Company', parentId: 8},
                {name: 'Low Company', parentId: 9}
            ])
            .returningLastInsertedId()
            .executeInsert()
        assertEquals(companiesIds, [8, 9, 10])

        const parentCompany = tCompany.as('parentCompany')

        const parentCompanies = connection.subSelectUsing(tCompany)
            .from(parentCompany)
            .select({
                id: parentCompany.id,
                name: parentCompany.name,
                parentId: parentCompany.parentId
            })
            .where(parentCompany.id.equals(tCompany.parentId))
            .recursiveUnionAllOn((child) => {
                return child.parentId.equals(parentCompany.id)
            })
            .forUseAsInlineAggregatedArrayValue()

        const lowCompany = await connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name,
                parentId: tCompany.parentId,
                parents: parentCompanies
            })
            .where(tCompany.id.equals(10))
            .executeSelectOne()
        assertEquals(lowCompany, { id: 10, name: 'Low Company', parentId: 9, parents: [{ id: 9, name: 'Mic Company', parentId: 8 }, { id: 8, name: 'Top Company' }] })

        const parentCompanies2 = connection.selectFrom(parentCompany)
            .select({
                id: parentCompany.id,
                name: parentCompany.name,
                parentId: parentCompany.parentId
            })
            .where(parentCompany.id.equals(9))
            .recursiveUnionAllOn((child) => {
                return child.parentId.equals(parentCompany.id)
            })
            .forUseAsInlineAggregatedArrayValue()

        const lowCompany2 = await connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name,
                parentId: tCompany.parentId,
                parents: parentCompanies2
            })
            .where(tCompany.id.equals(10))
            .executeSelectOne()
        assertEquals(lowCompany2, { id: 10, name: 'Low Company', parentId: 9, parents: [{ id: 9, name: 'Mic Company', parentId: 8 }, { id: 8, name: 'Top Company' }] })

        const lowCompany3 = await connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name,
                parentId: tCompany.parentId
            })
            .where(tCompany.id.equals(10))
            .composeDeletingInternalProperty({
                externalProperty: 'parentId',
                internalProperty: 'startId',
                propertyName: 'parents'
            }).withMany((ids) => {
                return connection.selectFrom(parentCompany)
                    .select({
                        id: parentCompany.id,
                        name: parentCompany.name,
                        parentId: parentCompany.parentId,
                        startId: parentCompany.id
                    })
                    .where(parentCompany.id.in(ids))
                    .recursiveUnionAll((child) => {
                        return connection.selectFrom(parentCompany)
                            .join(child).on(child.parentId.equals(parentCompany.id))
                            .select({
                                id: parentCompany.id,
                                name: parentCompany.name,
                                parentId: parentCompany.parentId,
                                startId: child.startId
                            })
                    })
                    .executeSelectMany()
            })
            .executeSelectOne()
        assertEquals(lowCompany3, { id: 10, name: 'Low Company', parentId: 9, parents: [{ id: 9, name: 'Mic Company', parentId: 8 }, { id: 8, name: 'Top Company' }] })

        i = await connection.insertInto(tRecord).values({
                id: '89bf68fc-7002-11ec-90d6-0242ac120003',
                title: 'My voice memo'
            }).executeInsert()
        assertEquals(i, 1)

        const record = await connection.selectFrom(tRecord)
            .select({
                id: tRecord.id,
                title: tRecord.title
            })
            .where(tRecord.id.asString().contains('7002'))
            .executeSelectOne()
        assertEquals(record, { id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' })

        const date = new Date('2022-11-21T19:33:56.123Z')
        const dateValue = connection.const(date, 'localDateTime')
        const dateValidation = await connection
            .selectFromNoTable()
            .select({
                fullYear: dateValue.getFullYear(),
                month: dateValue.getMonth(),
                date: dateValue.getDate(),
                day: dateValue.getDay(),
                hours: dateValue.getHours(),
                minutes: dateValue.getMinutes(),
                second: dateValue.getSeconds(),
                milliseconds: dateValue.getMilliseconds(),
                time: dateValue.getTime(),
                dateValue: dateValue,
            })
            .executeSelectOne()
        assertEquals(dateValidation, {
            fullYear: date.getUTCFullYear(),
            month: date.getUTCMonth(),
            date: date.getUTCDate(),
            day: date.getUTCDay(),
            hours: date.getUTCHours(),
            minutes: date.getUTCMinutes(),
            second: date.getUTCSeconds(),
            milliseconds: date.getUTCMilliseconds(),
            time: date.getTime(),
            dateValue: date,
        })

        class VCustomerForUpdate extends Values<DBConnection, 'customerForUpdate'> {
            id = this.column('int')
            firstName = this.column('string')
            lastName = this.column('string')
        }
        const customerForUpdate = Values.create(VCustomerForUpdate, 'customerForUpdate', [{
            id: 100,
            firstName: 'First Name',
            lastName: 'Last Name'
        }])
        
        i = await connection.update(tCustomer)
            .from(customerForUpdate)
            .set({
                firstName: customerForUpdate.firstName,
                lastName: customerForUpdate.lastName
            })
            .where(tCustomer.id.equals(customerForUpdate.id))
            .executeUpdate()
        assertEquals(i, 0)
    
        // class VCustomerForDelete extends Values<DBConnection, 'customerForDelete'> {
        //     firstName = this.column('string')
        //     lastName = this.column('string')
        // }
        // const customerForDelete = Values.create(VCustomerForDelete, 'customerForDelete', [{
        //     firstName: 'First Name',
        //     lastName: 'Last Name'
        // }])
        
        // i = await connection.deleteFrom(tCustomer)
        //     .using(customerForDelete)
        //     .where(tCustomer.firstName.equals(customerForDelete.firstName))
        //     .and(tCustomer.lastName.equals(customerForDelete.lastName))
        //     .executeDelete()
        // assertEquals(i, 0)

        i = await connection
            .insertInto(tBoolean)
            .values({ 
                boolA: true,
                optionalBoolB: true,
                customBooleanC: true,
                customBooleanD: true,
                customOptionalBooleanE: true,
                customOptionalBooleanF: true,
             })
            .executeInsert()
        assertEquals(i, 1)

        const booleanWith = connection
            .selectFrom(tBoolean)
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
                ands: tBoolean.boolA
                    .and(tBoolean.optionalBoolB)
                    .and(tBoolean.customBooleanC)
                    .and(tBoolean.customBooleanD)
                    .and(tBoolean.customOptionalBooleanE)
                    .and(tBoolean.customOptionalBooleanF),
                ors: tBoolean.boolA
                    .or(tBoolean.optionalBoolB)
                    .or(tBoolean.customBooleanC)
                    .or(tBoolean.customBooleanD)
                    .or(tBoolean.customOptionalBooleanE)
                    .or(tBoolean.customOptionalBooleanF),
            }).forUseInQueryAs('booleanWith')

        const booleanAlias = tBoolean.as('booleanAlias')
        const booleanSelect = await connection
            .selectFrom(tBoolean)
            .from(booleanWith)
            .where(tBoolean.boolA)
            .and(tBoolean.optionalBoolB)
            .and(tBoolean.customBooleanC)
            .and(tBoolean.customBooleanD)
            .and(tBoolean.customOptionalBooleanE)
            .and(tBoolean.customOptionalBooleanF)
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.optionalBoolB.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.customOptionalBooleanE.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.customOptionalBooleanF.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB)))
            .and(tBoolean.optionalBoolB.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB)))
            .and(tBoolean.customOptionalBooleanE.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB)))
            .and(tBoolean.customOptionalBooleanF.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.optionalBoolB.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.customOptionalBooleanE.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.customOptionalBooleanF.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.optionalBoolB.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.customOptionalBooleanE.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.customOptionalBooleanF.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE)))
            .and(tBoolean.optionalBoolB.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE)))
            .and(tBoolean.customOptionalBooleanE.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE)))
            .and(tBoolean.customOptionalBooleanF.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF)))
            .and(tBoolean.optionalBoolB.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF)))
            .and(tBoolean.customOptionalBooleanE.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF)))
            .and(tBoolean.customOptionalBooleanF.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF)))
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
                ands: tBoolean.boolA
                    .and(tBoolean.optionalBoolB)
                    .and(tBoolean.customBooleanC)
                    .and(tBoolean.customBooleanD)
                    .and(tBoolean.customOptionalBooleanE)
                    .and(tBoolean.customOptionalBooleanF),
                ors: tBoolean.boolA
                    .or(tBoolean.optionalBoolB)
                    .or(tBoolean.customBooleanC)
                    .or(tBoolean.customBooleanD)
                    .or(tBoolean.customOptionalBooleanE)
                    .or(tBoolean.customOptionalBooleanF),
                withBoolA: booleanWith.boolA,
                withOptionalBoolB: booleanWith.optionalBoolB,
                withCustomBooleanC: booleanWith.customBooleanC,
                withCustomBooleanD: booleanWith.customBooleanD,
                withCustomOptionalBooleanE: booleanWith.customOptionalBooleanE,
                withCustomOptionalBooleanF: booleanWith.customOptionalBooleanF,
                withAnds: booleanWith.ands,
                withOrs: booleanWith.ors,
                inlineBoolA: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA).forUseAsInlineQueryValue(),
                inlineOptionalBoolB: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB).forUseAsInlineQueryValue(),
                inlineCustomBooleanC: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC).forUseAsInlineQueryValue(),
                inlineCustomBooleanD: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD).forUseAsInlineQueryValue(),
                inlineCustomOptionalBooleanE: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE).forUseAsInlineQueryValue(),
                inlineCustomOptionalBooleanF: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF).forUseAsInlineQueryValue(),
                inlineAnds: connection.selectFrom(booleanAlias).selectOneColumn(
                    booleanAlias.boolA
                    .and(booleanAlias.optionalBoolB)
                    .and(booleanAlias.customBooleanC)
                    .and(booleanAlias.customBooleanD)
                    .and(booleanAlias.customOptionalBooleanE)
                    .and(booleanAlias.customOptionalBooleanF))
                    .forUseAsInlineQueryValue(),
                inlineOrs: connection.selectFrom(booleanAlias).selectOneColumn(
                    booleanAlias.boolA
                    .or(booleanAlias.optionalBoolB)
                    .or(booleanAlias.customBooleanC)
                    .or(booleanAlias.customBooleanD)
                    .or(booleanAlias.customOptionalBooleanE)
                    .or(booleanAlias.customOptionalBooleanF))
                    .forUseAsInlineQueryValue(),
            })
            .executeSelectOne()

        assertEquals(booleanSelect, {
            boolA: true,
            optionalBoolB: true,
            customBooleanC: true,
            customBooleanD: true,
            customOptionalBooleanE: true,
            customOptionalBooleanF: true,
            ands: true,
            ors: true,
            withBoolA: true,
            withOptionalBoolB: true,
            withCustomBooleanC: true,
            withCustomBooleanD: true,
            withCustomOptionalBooleanE: true,
            withCustomOptionalBooleanF: true,
            withAnds: true,
            withOrs: true,
            inlineBoolA: true,
            inlineOptionalBoolB: true,
            inlineCustomBooleanC: true,
            inlineCustomBooleanD: true,
            inlineCustomOptionalBooleanE: true,
            inlineCustomOptionalBooleanF: true,
            inlineAnds: true,
            inlineOrs: true,
        })

        const booleanAggreagte = await connection
            .selectFrom(tBoolean)
            .from(booleanWith)
            .select({
                data: connection.aggregateAsArray({
                    boolA: tBoolean.boolA,
                    optionalBoolB: tBoolean.optionalBoolB,
                    customBooleanC: tBoolean.customBooleanC,
                    customBooleanD: tBoolean.customBooleanD,
                    customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                    customOptionalBooleanF: tBoolean.customOptionalBooleanF,
                    ands: tBoolean.boolA
                        .and(tBoolean.optionalBoolB)
                        .and(tBoolean.customBooleanC)
                        .and(tBoolean.customBooleanD)
                        .and(tBoolean.customOptionalBooleanE)
                        .and(tBoolean.customOptionalBooleanF),
                    ors: tBoolean.boolA
                        .or(tBoolean.optionalBoolB)
                        .or(tBoolean.customBooleanC)
                        .or(tBoolean.customBooleanD)
                        .or(tBoolean.customOptionalBooleanE)
                        .or(tBoolean.customOptionalBooleanF),
                    withBoolA: booleanWith.boolA,
                    withOptionalBoolB: booleanWith.optionalBoolB,
                    withCustomBooleanC: booleanWith.customBooleanC,
                    withCustomBooleanD: booleanWith.customBooleanD,
                    withCustomOptionalBooleanE: booleanWith.customOptionalBooleanE,
                    withCustomOptionalBooleanF: booleanWith.customOptionalBooleanF,
                    withAnds: booleanWith.ands,
                    withOrs: booleanWith.ors,
                    inlineBoolA: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA).forUseAsInlineQueryValue(),
                    inlineOptionalBoolB: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB).forUseAsInlineQueryValue(),
                    inlineCustomBooleanC: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC).forUseAsInlineQueryValue(),
                    inlineCustomBooleanD: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD).forUseAsInlineQueryValue(),
                    inlineCustomOptionalBooleanE: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE).forUseAsInlineQueryValue(),
                    inlineCustomOptionalBooleanF: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF).forUseAsInlineQueryValue(),
                    inlineAnds: connection.selectFrom(booleanAlias).selectOneColumn(
                        booleanAlias.boolA
                        .and(booleanAlias.optionalBoolB)
                        .and(booleanAlias.customBooleanC)
                        .and(booleanAlias.customBooleanD)
                        .and(booleanAlias.customOptionalBooleanE)
                        .and(booleanAlias.customOptionalBooleanF))
                        .forUseAsInlineQueryValue(),
                    inlineOrs: connection.selectFrom(booleanAlias).selectOneColumn(
                        booleanAlias.boolA
                        .or(booleanAlias.optionalBoolB)
                        .or(booleanAlias.customBooleanC)
                        .or(booleanAlias.customBooleanD)
                        .or(booleanAlias.customOptionalBooleanE)
                        .or(booleanAlias.customOptionalBooleanF))
                        .forUseAsInlineQueryValue(),
                })
            })
            .groupBy(tBoolean.id)
            .executeSelectOne()
        
        assertEquals(booleanAggreagte, { data: [{
            boolA: true,
            optionalBoolB: true,
            customBooleanC: true,
            customBooleanD: true,
            customOptionalBooleanE: true,
            customOptionalBooleanF: true,
            ands: true,
            ors: true,
            withBoolA: true,
            withOptionalBoolB: true,
            withCustomBooleanC: true,
            withCustomBooleanD: true,
            withCustomOptionalBooleanE: true,
            withCustomOptionalBooleanF: true,
            withAnds: true,
            withOrs: true,
            inlineBoolA: true,
            inlineOptionalBoolB: true,
            inlineCustomBooleanC: true,
            inlineCustomBooleanD: true,
            inlineCustomOptionalBooleanE: true,
            inlineCustomOptionalBooleanF: true,
            inlineAnds: true,
            inlineOrs: true,
        }]})

        const aggreagateBooleanQuery = connection
            .selectFrom(tBoolean)
            .from(booleanWith)
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
                ands: tBoolean.boolA
                    .and(tBoolean.optionalBoolB)
                    .and(tBoolean.customBooleanC)
                    .and(tBoolean.customBooleanD)
                    .and(tBoolean.customOptionalBooleanE)
                    .and(tBoolean.customOptionalBooleanF),
                ors: tBoolean.boolA
                    .or(tBoolean.optionalBoolB)
                    .or(tBoolean.customBooleanC)
                    .or(tBoolean.customBooleanD)
                    .or(tBoolean.customOptionalBooleanE)
                    .or(tBoolean.customOptionalBooleanF),
                withBoolA: booleanWith.boolA,
                withOptionalBoolB: booleanWith.optionalBoolB,
                withCustomBooleanC: booleanWith.customBooleanC,
                withCustomBooleanD: booleanWith.customBooleanD,
                withCustomOptionalBooleanE: booleanWith.customOptionalBooleanE,
                withCustomOptionalBooleanF: booleanWith.customOptionalBooleanF,
                withAnds: booleanWith.ands,
                withOrs: booleanWith.ors,
                inlineBoolA: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA).forUseAsInlineQueryValue(),
                inlineOptionalBoolB: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB).forUseAsInlineQueryValue(),
                inlineCustomBooleanC: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC).forUseAsInlineQueryValue(),
                inlineCustomBooleanD: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD).forUseAsInlineQueryValue(),
                inlineCustomOptionalBooleanE: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE).forUseAsInlineQueryValue(),
                inlineCustomOptionalBooleanF: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF).forUseAsInlineQueryValue(),
                inlineAnds: connection.selectFrom(booleanAlias).selectOneColumn(
                    booleanAlias.boolA
                    .and(booleanAlias.optionalBoolB)
                    .and(booleanAlias.customBooleanC)
                    .and(booleanAlias.customBooleanD)
                    .and(booleanAlias.customOptionalBooleanE)
                    .and(booleanAlias.customOptionalBooleanF))
                    .forUseAsInlineQueryValue(),
                inlineOrs: connection.selectFrom(booleanAlias).selectOneColumn(
                    booleanAlias.boolA
                    .or(booleanAlias.optionalBoolB)
                    .or(booleanAlias.customBooleanC)
                    .or(booleanAlias.customBooleanD)
                    .or(booleanAlias.customOptionalBooleanE)
                    .or(booleanAlias.customOptionalBooleanF))
                    .forUseAsInlineQueryValue(),
            })
            .forUseAsInlineAggregatedArrayValue()
        
        const aggreagateBooleanQueryResult = await connection.selectFromNoTable().select({data: aggreagateBooleanQuery}).executeSelectOne()
        
        assertEquals(aggreagateBooleanQueryResult, { data: [{
            boolA: true,
            optionalBoolB: true,
            customBooleanC: true,
            customBooleanD: true,
            customOptionalBooleanE: true,
            customOptionalBooleanF: true,
            ands: true,
            ors: true,
            withBoolA: true,
            withOptionalBoolB: true,
            withCustomBooleanC: true,
            withCustomBooleanD: true,
            withCustomOptionalBooleanE: true,
            withCustomOptionalBooleanF: true,
            withAnds: true,
            withOrs: true,
            inlineBoolA: true,
            inlineOptionalBoolB: true,
            inlineCustomBooleanC: true,
            inlineCustomBooleanD: true,
            inlineCustomOptionalBooleanE: true,
            inlineCustomOptionalBooleanF: true,
            inlineAnds: true,
            inlineOrs: true,
        }]})

        i = await connection
            .updateAllowingNoWhere(tBoolean)
            .set({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
             })
            .executeUpdate()
        assertEquals(i, 1)

        let boolValidation = await connection
            .selectFrom(tBoolean)
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
            })
            .executeSelectOne()
        assertEquals(boolValidation, {
            boolA: true,
            optionalBoolB: true,
            customBooleanC: true,
            customBooleanD: true,
            customOptionalBooleanE: true,
            customOptionalBooleanF: true,
        })

        i = await connection
            .updateAllowingNoWhere(tBoolean)
            .set({
                boolA: tBoolean.optionalBoolB.valueWhenNull(false),
                optionalBoolB: tBoolean.customBooleanC,
                customBooleanC: tBoolean.customBooleanD,
                customBooleanD: tBoolean.customOptionalBooleanE.valueWhenNull(false),
                customOptionalBooleanE: tBoolean.customOptionalBooleanF,
                customOptionalBooleanF: tBoolean.boolA,
             })
            .executeUpdate()
        assertEquals(i, 1)

        boolValidation = await connection
            .selectFrom(tBoolean)
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
            })
            .executeSelectOne()
        assertEquals(boolValidation, {
            boolA: true,
            optionalBoolB: true,
            customBooleanC: true,
            customBooleanD: true,
            customOptionalBooleanE: true,
            customOptionalBooleanF: true,
        })

        i = await connection
            .updateAllowingNoWhere(tBoolean)
            .set({
                boolA: tBoolean.customBooleanC,
                optionalBoolB: tBoolean.customBooleanD,
                customBooleanC: tBoolean.customOptionalBooleanE.valueWhenNull(false),
                customBooleanD: tBoolean.customOptionalBooleanF.valueWhenNull(false),
                customOptionalBooleanE: tBoolean.boolA,
                customOptionalBooleanF: tBoolean.optionalBoolB,
             })
            .executeUpdate()
        assertEquals(i, 1)

        boolValidation = await connection
            .selectFrom(tBoolean)
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
            })
            .executeSelectOne()
        assertEquals(boolValidation, {
            boolA: true,
            optionalBoolB: true,
            customBooleanC: true,
            customBooleanD: true,
            customOptionalBooleanE: true,
            customOptionalBooleanF: true,
        })

        i = await connection
            .updateAllowingNoWhere(tBoolean)
            .set({
                boolA: tBoolean.customBooleanD,
                optionalBoolB: tBoolean.customOptionalBooleanE,
                customBooleanC: tBoolean.customOptionalBooleanF.valueWhenNull(false),
                customBooleanD: tBoolean.boolA,
                customOptionalBooleanE: tBoolean.optionalBoolB,
                customOptionalBooleanF: tBoolean.customBooleanC,
             })
            .executeUpdate()
        assertEquals(i, 1)

        boolValidation = await connection
            .selectFrom(tBoolean)
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
            })
            .executeSelectOne()
        assertEquals(boolValidation, {
            boolA: true,
            optionalBoolB: true,
            customBooleanC: true,
            customBooleanD: true,
            customOptionalBooleanE: true,
            customOptionalBooleanF: true,
        })

        i = await connection
            .updateAllowingNoWhere(tBoolean)
            .set({
                boolA: tBoolean.customOptionalBooleanE.valueWhenNull(false),
                optionalBoolB: tBoolean.customOptionalBooleanF,
                customBooleanC: tBoolean.boolA,
                customBooleanD: tBoolean.optionalBoolB.valueWhenNull(false),
                customOptionalBooleanE: tBoolean.customBooleanC,
                customOptionalBooleanF: tBoolean.customBooleanD,
             })
            .executeUpdate()
        assertEquals(i, 1)

        boolValidation = await connection
            .selectFrom(tBoolean)
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
            })
            .executeSelectOne()
        assertEquals(boolValidation, {
            boolA: true,
            optionalBoolB: true,
            customBooleanC: true,
            customBooleanD: true,
            customOptionalBooleanE: true,
            customOptionalBooleanF: true,
        })

        i = await connection
            .updateAllowingNoWhere(tBoolean)
            .set({
                boolA: tBoolean.customOptionalBooleanF.valueWhenNull(false),
                optionalBoolB: tBoolean.boolA,
                customBooleanC: tBoolean.optionalBoolB.valueWhenNull(false),
                customBooleanD: tBoolean.customBooleanC,
                customOptionalBooleanE: tBoolean.customBooleanD,
                customOptionalBooleanF: tBoolean.customOptionalBooleanE,
             })
            .executeUpdate()
        assertEquals(i, 1)

        boolValidation = await connection
            .selectFrom(tBoolean)
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
            })
            .executeSelectOne()
        assertEquals(boolValidation, {
            boolA: true,
            optionalBoolB: true,
            customBooleanC: true,
            customBooleanD: true,
            customOptionalBooleanE: true,
            customOptionalBooleanF: true,
        })

        i = await connection
            .updateAllowingNoWhere(tBoolean)
            .set({
                boolA: tBoolean.boolA.negate(),
                optionalBoolB: tBoolean.optionalBoolB.negate(),
                customBooleanC: tBoolean.customBooleanC.negate(),
                customBooleanD: tBoolean.customBooleanD.negate(),
                customOptionalBooleanE: tBoolean.customOptionalBooleanE.negate(),
                customOptionalBooleanF: tBoolean.customOptionalBooleanF.negate(),
            })
            .executeUpdate()
        assertEquals(i, 1)

        boolValidation = await connection
            .selectFrom(tBoolean)
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
            })
            .executeSelectOne()
        assertEquals(boolValidation, {
            boolA: false,
            optionalBoolB: false,
            customBooleanC: false,
            customBooleanD: false,
            customOptionalBooleanE: false,
            customOptionalBooleanF: false,
        })

        i = await connection
            .updateAllowingNoWhere(tBoolean)
            .set({
                boolA: false,
                optionalBoolB: false,
                customBooleanC: false,
                customBooleanD: false,
                customOptionalBooleanE: false,
                customOptionalBooleanF: false,
            })
            .executeUpdate()
        assertEquals(i, 1)

        boolValidation = await connection
            .selectFrom(tBoolean)
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
            })
            .executeSelectOne()
        assertEquals(boolValidation, {
            boolA: false,
            optionalBoolB: false,
            customBooleanC: false,
            customBooleanD: false,
            customOptionalBooleanE: false,
            customOptionalBooleanF: false,
        })

        const booleanSelect2 = await connection
            .selectFrom(tBoolean)
            .from(booleanWith)
            .where(tBoolean.boolA.negate())
            .and(tBoolean.optionalBoolB.negate())
            .and(tBoolean.customBooleanC.negate())
            .and(tBoolean.customBooleanD.negate())
            .and(tBoolean.customOptionalBooleanE.negate())
            .and(tBoolean.customOptionalBooleanF.negate())
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.optionalBoolB.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.customOptionalBooleanE.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.customOptionalBooleanF.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB)))
            .and(tBoolean.optionalBoolB.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB)))
            .and(tBoolean.customOptionalBooleanE.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB)))
            .and(tBoolean.customOptionalBooleanF.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.optionalBoolB.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.customOptionalBooleanE.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.customOptionalBooleanF.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.optionalBoolB.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.customOptionalBooleanE.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.customOptionalBooleanF.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE)))
            .and(tBoolean.optionalBoolB.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE)))
            .and(tBoolean.customOptionalBooleanE.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE)))
            .and(tBoolean.customOptionalBooleanF.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF)))
            .and(tBoolean.optionalBoolB.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF)))
            .and(tBoolean.customOptionalBooleanE.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF)))
            .and(tBoolean.customOptionalBooleanF.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF)))
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
                ands: tBoolean.boolA
                    .and(tBoolean.optionalBoolB)
                    .and(tBoolean.customBooleanC)
                    .and(tBoolean.customBooleanD)
                    .and(tBoolean.customOptionalBooleanE)
                    .and(tBoolean.customOptionalBooleanF),
                ors: tBoolean.boolA
                    .or(tBoolean.optionalBoolB)
                    .or(tBoolean.customBooleanC)
                    .or(tBoolean.customBooleanD)
                    .or(tBoolean.customOptionalBooleanE)
                    .or(tBoolean.customOptionalBooleanF),
                withBoolA: booleanWith.boolA,
                withOptionalBoolB: booleanWith.optionalBoolB,
                withCustomBooleanC: booleanWith.customBooleanC,
                withCustomBooleanD: booleanWith.customBooleanD,
                withCustomOptionalBooleanE: booleanWith.customOptionalBooleanE,
                withCustomOptionalBooleanF: booleanWith.customOptionalBooleanF,
                withAnds: booleanWith.ands,
                withOrs: booleanWith.ors,
                inlineBoolA: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA).forUseAsInlineQueryValue(),
                inlineOptionalBoolB: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB).forUseAsInlineQueryValue(),
                inlineCustomBooleanC: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC).forUseAsInlineQueryValue(),
                inlineCustomBooleanD: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD).forUseAsInlineQueryValue(),
                inlineCustomOptionalBooleanE: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE).forUseAsInlineQueryValue(),
                inlineCustomOptionalBooleanF: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF).forUseAsInlineQueryValue(),
                inlineAnds: connection.selectFrom(booleanAlias).selectOneColumn(
                    booleanAlias.boolA
                    .and(booleanAlias.optionalBoolB)
                    .and(booleanAlias.customBooleanC)
                    .and(booleanAlias.customBooleanD)
                    .and(booleanAlias.customOptionalBooleanE)
                    .and(booleanAlias.customOptionalBooleanF))
                    .forUseAsInlineQueryValue(),
                inlineOrs: connection.selectFrom(booleanAlias).selectOneColumn(
                    booleanAlias.boolA
                    .or(booleanAlias.optionalBoolB)
                    .or(booleanAlias.customBooleanC)
                    .or(booleanAlias.customBooleanD)
                    .or(booleanAlias.customOptionalBooleanE)
                    .or(booleanAlias.customOptionalBooleanF))
                    .forUseAsInlineQueryValue(),
            })
            .executeSelectOne()

        assertEquals(booleanSelect2, {
            boolA: false,
            optionalBoolB: false,
            customBooleanC: false,
            customBooleanD: false,
            customOptionalBooleanE: false,
            customOptionalBooleanF: false,
            ands: false,
            ors: false,
            withBoolA: false,
            withOptionalBoolB: false,
            withCustomBooleanC: false,
            withCustomBooleanD: false,
            withCustomOptionalBooleanE: false,
            withCustomOptionalBooleanF: false,
            withAnds: false,
            withOrs: false,
            inlineBoolA: false,
            inlineOptionalBoolB: false,
            inlineCustomBooleanC: false,
            inlineCustomBooleanD: false,
            inlineCustomOptionalBooleanE: false,
            inlineCustomOptionalBooleanF: false,
            inlineAnds: false,
            inlineOrs: false,
        })

        const booleanAggreagte2 = await connection
            .selectFrom(tBoolean)
            .from(booleanWith)
            .select({
                data: connection.aggregateAsArray({
                    boolA: tBoolean.boolA,
                    optionalBoolB: tBoolean.optionalBoolB,
                    customBooleanC: tBoolean.customBooleanC,
                    customBooleanD: tBoolean.customBooleanD,
                    customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                    customOptionalBooleanF: tBoolean.customOptionalBooleanF,
                    ands: tBoolean.boolA
                        .and(tBoolean.optionalBoolB)
                        .and(tBoolean.customBooleanC)
                        .and(tBoolean.customBooleanD)
                        .and(tBoolean.customOptionalBooleanE)
                        .and(tBoolean.customOptionalBooleanF),
                    ors: tBoolean.boolA
                        .or(tBoolean.optionalBoolB)
                        .or(tBoolean.customBooleanC)
                        .or(tBoolean.customBooleanD)
                        .or(tBoolean.customOptionalBooleanE)
                        .or(tBoolean.customOptionalBooleanF),
                    withBoolA: booleanWith.boolA,
                    withOptionalBoolB: booleanWith.optionalBoolB,
                    withCustomBooleanC: booleanWith.customBooleanC,
                    withCustomBooleanD: booleanWith.customBooleanD,
                    withCustomOptionalBooleanE: booleanWith.customOptionalBooleanE,
                    withCustomOptionalBooleanF: booleanWith.customOptionalBooleanF,
                    withAnds: booleanWith.ands,
                    withOrs: booleanWith.ors,
                    inlineBoolA: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA).forUseAsInlineQueryValue(),
                    inlineOptionalBoolB: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB).forUseAsInlineQueryValue(),
                    inlineCustomBooleanC: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC).forUseAsInlineQueryValue(),
                    inlineCustomBooleanD: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD).forUseAsInlineQueryValue(),
                    inlineCustomOptionalBooleanE: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE).forUseAsInlineQueryValue(),
                    inlineCustomOptionalBooleanF: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF).forUseAsInlineQueryValue(),
                    inlineAnds: connection.selectFrom(booleanAlias).selectOneColumn(
                        booleanAlias.boolA
                        .and(booleanAlias.optionalBoolB)
                        .and(booleanAlias.customBooleanC)
                        .and(booleanAlias.customBooleanD)
                        .and(booleanAlias.customOptionalBooleanE)
                        .and(booleanAlias.customOptionalBooleanF))
                        .forUseAsInlineQueryValue(),
                    inlineOrs: connection.selectFrom(booleanAlias).selectOneColumn(
                        booleanAlias.boolA
                        .or(booleanAlias.optionalBoolB)
                        .or(booleanAlias.customBooleanC)
                        .or(booleanAlias.customBooleanD)
                        .or(booleanAlias.customOptionalBooleanE)
                        .or(booleanAlias.customOptionalBooleanF))
                        .forUseAsInlineQueryValue(),
                })
            })
            .groupBy(tBoolean.id)
            .executeSelectOne()
        
        assertEquals(booleanAggreagte2, { data: [{
            boolA: false,
            optionalBoolB: false,
            customBooleanC: false,
            customBooleanD: false,
            customOptionalBooleanE: false,
            customOptionalBooleanF: false,
            ands: false,
            ors: false,
            withBoolA: false,
            withOptionalBoolB: false,
            withCustomBooleanC: false,
            withCustomBooleanD: false,
            withCustomOptionalBooleanE: false,
            withCustomOptionalBooleanF: false,
            withAnds: false,
            withOrs: false,
            inlineBoolA: false,
            inlineOptionalBoolB: false,
            inlineCustomBooleanC: false,
            inlineCustomBooleanD: false,
            inlineCustomOptionalBooleanE: false,
            inlineCustomOptionalBooleanF: false,
            inlineAnds: false,
            inlineOrs: false,
        }]})
        
        const aggreagateBooleanQueryResult2 = await connection.selectFromNoTable().select({data: aggreagateBooleanQuery}).executeSelectOne()
        
        assertEquals(aggreagateBooleanQueryResult2, { data: [{
            boolA: false,
            optionalBoolB: false,
            customBooleanC: false,
            customBooleanD: false,
            customOptionalBooleanE: false,
            customOptionalBooleanF: false,
            ands: false,
            ors: false,
            withBoolA: false,
            withOptionalBoolB: false,
            withCustomBooleanC: false,
            withCustomBooleanD: false,
            withCustomOptionalBooleanE: false,
            withCustomOptionalBooleanF: false,
            withAnds: false,
            withOrs: false,
            inlineBoolA: false,
            inlineOptionalBoolB: false,
            inlineCustomBooleanC: false,
            inlineCustomBooleanD: false,
            inlineCustomOptionalBooleanE: false,
            inlineCustomOptionalBooleanF: false,
            inlineAnds: false,
            inlineOrs: false,
        }]})

        i = await connection
            .updateAllowingNoWhere(tBoolean)
            .set({
                boolA: true,
                optionalBoolB: null,
                customBooleanC: true,
                customBooleanD: true,
                customOptionalBooleanE: null,
                customOptionalBooleanF: null,
            })
            .executeUpdate()
        assertEquals(i, 1)

        boolValidation = await connection
            .selectFrom(tBoolean)
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
            })
            .executeSelectOne()
        assertEquals(boolValidation, {
            boolA: true,
            // optionalBoolB: undefined,
            customBooleanC: true,
            customBooleanD: true,
            // customOptionalBooleanE: undefined,
            // customOptionalBooleanF: undefined,
        })

        const booleanSelect3 = await connection
            .selectFrom(tBoolean)
            .from(booleanWith)
            .where(tBoolean.boolA.isNotNull())
            .and(tBoolean.optionalBoolB.isNull())
            .and(tBoolean.customBooleanC.isNotNull())
            .and(tBoolean.customBooleanD.isNull().negate())
            .and(tBoolean.customOptionalBooleanE.isNull())
            .and(tBoolean.customOptionalBooleanF.isNotNull().negate())
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.optionalBoolB.valueWhenNull(true).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.customOptionalBooleanE.valueWhenNull(true).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.customOptionalBooleanF.valueWhenNull(true).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB.valueWhenNull(true))))
            .and(tBoolean.optionalBoolB.valueWhenNull(false).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB.valueWhenNull(false))))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB.valueWhenNull(true))))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB.valueWhenNull(true))))
            .and(tBoolean.customOptionalBooleanE.valueWhenNull(false).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB.valueWhenNull(false))))
            .and(tBoolean.customOptionalBooleanF.valueWhenNull(false).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB.valueWhenNull(false))))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.optionalBoolB.valueWhenNull(true).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.customOptionalBooleanE.valueWhenNull(true).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.customOptionalBooleanF.valueWhenNull(true).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.optionalBoolB.valueWhenNull(true).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.customOptionalBooleanE.valueWhenNull(true).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.customOptionalBooleanF.valueWhenNull(true).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD)))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE.valueWhenNull(true))))
            .and(tBoolean.optionalBoolB.valueWhenNull(false).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE.valueWhenNull(false))))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE.valueWhenNull(true))))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE.valueWhenNull(true))))
            .and(tBoolean.customOptionalBooleanE.valueWhenNull(false).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE.valueWhenNull(false))))
            .and(tBoolean.customOptionalBooleanF.valueWhenNull(false).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE.valueWhenNull(false))))
            .and(tBoolean.boolA.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF.valueWhenNull(true))))
            .and(tBoolean.optionalBoolB.valueWhenNull(false).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF.valueWhenNull(false))))
            .and(tBoolean.customBooleanC.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF.valueWhenNull(true))))
            .and(tBoolean.customBooleanD.in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF.valueWhenNull(true))))
            .and(tBoolean.customOptionalBooleanE.valueWhenNull(false).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF.valueWhenNull(false))))
            .and(tBoolean.customOptionalBooleanF.valueWhenNull(false).in(connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF.valueWhenNull(false))))
            .select({
                boolA: tBoolean.boolA,
                optionalBoolB: tBoolean.optionalBoolB,
                customBooleanC: tBoolean.customBooleanC,
                customBooleanD: tBoolean.customBooleanD,
                customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                customOptionalBooleanF: tBoolean.customOptionalBooleanF,
                ands: tBoolean.boolA
                    .and(tBoolean.optionalBoolB)
                    .and(tBoolean.customBooleanC)
                    .and(tBoolean.customBooleanD)
                    .and(tBoolean.customOptionalBooleanE)
                    .and(tBoolean.customOptionalBooleanF),
                ors: tBoolean.boolA
                    .or(tBoolean.optionalBoolB)
                    .or(tBoolean.customBooleanC)
                    .or(tBoolean.customBooleanD)
                    .or(tBoolean.customOptionalBooleanE)
                    .or(tBoolean.customOptionalBooleanF),
                withBoolA: booleanWith.boolA,
                withOptionalBoolB: booleanWith.optionalBoolB,
                withCustomBooleanC: booleanWith.customBooleanC,
                withCustomBooleanD: booleanWith.customBooleanD,
                withCustomOptionalBooleanE: booleanWith.customOptionalBooleanE,
                withCustomOptionalBooleanF: booleanWith.customOptionalBooleanF,
                withAnds: booleanWith.ands,
                withOrs: booleanWith.ors,
                inlineBoolA: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA).forUseAsInlineQueryValue(),
                inlineOptionalBoolB: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB).forUseAsInlineQueryValue(),
                inlineCustomBooleanC: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC).forUseAsInlineQueryValue(),
                inlineCustomBooleanD: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD).forUseAsInlineQueryValue(),
                inlineCustomOptionalBooleanE: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE).forUseAsInlineQueryValue(),
                inlineCustomOptionalBooleanF: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF).forUseAsInlineQueryValue(),
                inlineAnds: connection.selectFrom(booleanAlias).selectOneColumn(
                    booleanAlias.boolA
                    .and(booleanAlias.optionalBoolB)
                    .and(booleanAlias.customBooleanC)
                    .and(booleanAlias.customBooleanD)
                    .and(booleanAlias.customOptionalBooleanE)
                    .and(booleanAlias.customOptionalBooleanF))
                    .forUseAsInlineQueryValue(),
                inlineOrs: connection.selectFrom(booleanAlias).selectOneColumn(
                    booleanAlias.boolA
                    .or(booleanAlias.optionalBoolB)
                    .or(booleanAlias.customBooleanC)
                    .or(booleanAlias.customBooleanD)
                    .or(booleanAlias.customOptionalBooleanE)
                    .or(booleanAlias.customOptionalBooleanF))
                    .forUseAsInlineQueryValue(),
            })
            .executeSelectOne()

        assertEquals(booleanSelect3, {
            boolA: true,
            // optionalBoolB: undefined,
            customBooleanC: true,
            customBooleanD: true,
            // customOptionalBooleanE: undefined,
            // customOptionalBooleanF: undefined,
            // ands: undefined,
            ors: true,
            withBoolA: true,
            // withOptionalBoolB: undefined,
            withCustomBooleanC: true,
            withCustomBooleanD: true,
            // withCustomOptionalBooleanE: undefined,
            // withCustomOptionalBooleanF: undefined,
            // withAnds: undefined,
            withOrs: true,
            inlineBoolA: true,
            // inlineOptionalBoolB: undefined,
            inlineCustomBooleanC: true,
            inlineCustomBooleanD: true,
            // inlineCustomOptionalBooleanE: undefined,
            // inlineCustomOptionalBooleanF: undefined,
            // inlineAnds: undefined,
            inlineOrs: true,
        })

        const booleanAggreagte3 = await connection
            .selectFrom(tBoolean)
            .from(booleanWith)
            .select({
                data: connection.aggregateAsArray({
                    boolA: tBoolean.boolA,
                    optionalBoolB: tBoolean.optionalBoolB,
                    customBooleanC: tBoolean.customBooleanC,
                    customBooleanD: tBoolean.customBooleanD,
                    customOptionalBooleanE: tBoolean.customOptionalBooleanE,
                    customOptionalBooleanF: tBoolean.customOptionalBooleanF,
                    ands: tBoolean.boolA
                        .and(tBoolean.optionalBoolB)
                        .and(tBoolean.customBooleanC)
                        .and(tBoolean.customBooleanD)
                        .and(tBoolean.customOptionalBooleanE)
                        .and(tBoolean.customOptionalBooleanF),
                    ors: tBoolean.boolA
                        .or(tBoolean.optionalBoolB)
                        .or(tBoolean.customBooleanC)
                        .or(tBoolean.customBooleanD)
                        .or(tBoolean.customOptionalBooleanE)
                        .or(tBoolean.customOptionalBooleanF),
                    withBoolA: booleanWith.boolA,
                    withOptionalBoolB: booleanWith.optionalBoolB,
                    withCustomBooleanC: booleanWith.customBooleanC,
                    withCustomBooleanD: booleanWith.customBooleanD,
                    withCustomOptionalBooleanE: booleanWith.customOptionalBooleanE,
                    withCustomOptionalBooleanF: booleanWith.customOptionalBooleanF,
                    withAnds: booleanWith.ands,
                    withOrs: booleanWith.ors,
                    inlineBoolA: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.boolA).forUseAsInlineQueryValue(),
                    inlineOptionalBoolB: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.optionalBoolB).forUseAsInlineQueryValue(),
                    inlineCustomBooleanC: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanC).forUseAsInlineQueryValue(),
                    inlineCustomBooleanD: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customBooleanD).forUseAsInlineQueryValue(),
                    inlineCustomOptionalBooleanE: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanE).forUseAsInlineQueryValue(),
                    inlineCustomOptionalBooleanF: connection.selectFrom(booleanAlias).selectOneColumn(booleanAlias.customOptionalBooleanF).forUseAsInlineQueryValue(),
                    inlineAnds: connection.selectFrom(booleanAlias).selectOneColumn(
                        booleanAlias.boolA
                        .and(booleanAlias.optionalBoolB)
                        .and(booleanAlias.customBooleanC)
                        .and(booleanAlias.customBooleanD)
                        .and(booleanAlias.customOptionalBooleanE)
                        .and(booleanAlias.customOptionalBooleanF))
                        .forUseAsInlineQueryValue(),
                    inlineOrs: connection.selectFrom(booleanAlias).selectOneColumn(
                        booleanAlias.boolA
                        .or(booleanAlias.optionalBoolB)
                        .or(booleanAlias.customBooleanC)
                        .or(booleanAlias.customBooleanD)
                        .or(booleanAlias.customOptionalBooleanE)
                        .or(booleanAlias.customOptionalBooleanF))
                        .forUseAsInlineQueryValue(),
                })
            })
            .groupBy(tBoolean.id)
            .executeSelectOne()
        
        assertEquals(booleanAggreagte3, { data: [{
            boolA: true,
            // optionalBoolB: undefined,
            customBooleanC: true,
            customBooleanD: true,
            // customOptionalBooleanE: undefined,
            // customOptionalBooleanF: undefined,
            // ands: undefined,
            ors: true,
            withBoolA: true,
            // withOptionalBoolB: undefined,
            withCustomBooleanC: true,
            withCustomBooleanD: true,
            // withCustomOptionalBooleanE: undefined,
            // withCustomOptionalBooleanF: undefined,
            // withAnds: undefined,
            withOrs: true,
            inlineBoolA: true,
            // inlineOptionalBoolB: undefined,
            inlineCustomBooleanC: true,
            inlineCustomBooleanD: true,
            // inlineCustomOptionalBooleanE: undefined,
            // inlineCustomOptionalBooleanF: undefined,
            // inlineAnds: undefined,
            inlineOrs: true,
        }]})
        
        const aggreagateBooleanQueryResult3 = await connection.selectFromNoTable().select({data: aggreagateBooleanQuery}).executeSelectOne()
        
        assertEquals(aggreagateBooleanQueryResult3, { data: [{
            boolA: true,
            // optionalBoolB: undefined,
            customBooleanC: true,
            customBooleanD: true,
            // customOptionalBooleanE: undefined,
            // customOptionalBooleanF: undefined,
            // ands: undefined,
            ors: true,
            withBoolA: true,
            // withOptionalBoolB: undefined,
            withCustomBooleanC: true,
            withCustomBooleanD: true,
            // withCustomOptionalBooleanE: undefined,
            // withCustomOptionalBooleanF: undefined,
            // withAnds: undefined,
            withOrs: true,
            inlineBoolA: true,
            // inlineOptionalBoolB: undefined,
            inlineCustomBooleanC: true,
            inlineCustomBooleanD: true,
            // inlineCustomOptionalBooleanE: undefined,
            // inlineCustomOptionalBooleanF: undefined,
            // inlineAnds: undefined,
            inlineOrs: true,
        }]})

        await connection.commit()
    } catch(e) {
        await connection.rollback()
        throw e
    }
}

async function run() {
    // @ts-ignore // TODO: find a better way to impòrt node version
    const {default: sqlite3InitModule} = await import('../../node_modules/@sqlite.org/sqlite-wasm/sqlite-wasm/jswasm/sqlite3-node.mjs')
    try {
        const sqlite3 = await sqlite3InitModule();
        const db: Database = new sqlite3.oo1.DB();
        // db.createFunction('uuid', _ => uuidv4())
        // db.createFunction('uuid_str', (_context, blob: any) => fromBinaryUUID(blob))
        // db.createFunction('uuid_blob', (_context, str: any) => toBinaryUUID(str))
        await main(db);
        console.log('All ok');
        process.exit(0);
    } catch(e) {
        console.error(e)
        process.exit(1)
    }
}
run()