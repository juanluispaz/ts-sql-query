import { BooleanValueSource, NumberValueSource, StringValueSource, LocalDateValueSource, LocalTimeValueSource, LocalDateTimeValueSource, EqualableValueSource, ComparableValueSource, BigintValueSource, __getValueSourcePrivate, UuidValueSource, IBooleanValueSource, INumberValueSource, IBigintValueSource, IStringValueSource, IUuidValueSource, ILocalDateValueSource, ILocalTimeValueSource, ILocalDateTimeValueSource, IEqualableValueSource, IComparableValueSource, AnyValueSource, ValueType, CustomIntValueSource, CustomDoubleValueSource, CustomUuidValueSource, CustomLocalDateTimeValueSource, ICustomIntValueSource, ICustomDoubleValueSource, ICustomUuidValueSource, ICustomLocalDateValueSource, ICustomLocalTimeValueSource, ICustomLocalDateTimeValueSource, CustomLocalDateValueSource, CustomLocalTimeValueSource } from "./expressions/values"
import { ITable, IWithView, __addWiths, __registerTableOrView, ITableOrView, __registerRequiredColumn, HasIsValue, OfDB } from "./utils/ITableOrView"
import type { TypeAdapter } from "./TypeAdapter"
import type { AliasedTableOrView, AutogeneratedPrimaryKeyColumnsTypesOf, AsOldValues, AsValuesForInsert, AsForUseInLeftJoin, AsAliasedForUseInLeftJoin } from "./utils/tableOrViewUtils"
import { Column, ColumnWithDefaultValue, DBColumn, PrimaryKeyAutogeneratedColumn, PrimaryKeyColumn } from "./utils/Column"
import { DBColumnImpl } from "./internal/DBColumnImpl"
import { connection, isTableOrViewObject, source, type } from "./utils/symbols"
import { IConnection } from "./utils/IConnection"
import type { RawFragment } from "./utils/RawFragment"
import type { BigintFragmentExpression, BooleanFragmentExpression, ComparableFragmentExpression, CustomDoubleFragmentExpression, CustomIntFragmentExpression, CustomLocalDateFragmentExpression, CustomLocalDateTimeFragmentExpression, CustomLocalTimeFragmentExpression, CustomUuidFragmentExpression, LocalDateFragmentExpression, LocalDateTimeFragmentExpression, EqualableFragmentExpression, NumberFragmentExpression, StringFragmentExpression, LocalTimeFragmentExpression, UuidFragmentExpression } from "./expressions/fragment"
import { ValueSourceFromBuilder } from "./internal/ValueSourceImpl"
import { FragmentQueryBuilder } from "./queryBuilders/FragmentQueryBuilder"
import { NNoTableOrViewRequiredFrom, NTable } from "./utils/sourceName"
import { __setColumnsForLeftJoin } from './utils/leftJoinUtils'

class TableOf</*in|out*/ SOURCE extends NTable<any, any>> implements ITable<SOURCE> {
    [isTableOrViewObject]: true = true;
    [source]!: SOURCE
    [type]!: 'table'
    /* implements __ITableOrViewPrivate as private members*/
    // @ts-ignore
    private __name: string
    // @ts-ignore
    private __as?: string
    // @ts-ignore
    private __forUseInLeftJoin?: boolean
    // @ts-ignore
    private __type: 'table' = 'table'
    // @ts-ignore
    private __template?: RawFragment<any>
    // @ts-ignore
    private __oldValues?: boolean
    // @ts-ignore
    private __valuesForInsert?: boolean

    constructor(name: string) {
        this.__name = name
    }

    as<ALIAS extends string>(as: ALIAS): AliasedTableOrView<this, ALIAS> {
        const result = new ((this as any).constructor)() as TableOf<any>
        result.__as = as
        return result as any
    }
    forUseInLeftJoin(): AsForUseInLeftJoin<this> {
        return this.forUseInLeftJoinAs('') as any
    }
    forUseInLeftJoinAs<ALIAS extends string>(as: ALIAS): AsAliasedForUseInLeftJoin<this, ALIAS> {
        const result = new ((this as any).constructor)() as TableOf<any>
        result.__as = as
        result.__forUseInLeftJoin = true
        __setColumnsForLeftJoin(result as any)
        return result as any
    }
    oldValues(this: OfDB<'sqlServer'>) : AsOldValues<this>
    oldValues(this: OfDB<'noopDB'>) : AsOldValues<this>
    oldValues(this: OfDB<'postgreSql'>) : [AutogeneratedPrimaryKeyColumnsTypesOf<this>] extends [never] ? never : AsOldValues<this>
    // Sqlite waiting for https://sqlite.org/forum/forumpost/2d49770b89
    //oldValues(this: { [database]: Sqlite }) : [AutogeneratedPrimaryKeyColumnsTypesOf<this>] extends [never] ? never : OldValues<this>
    oldValues(this: OfDB<'postgreSql' | 'sqlServer' | 'noopDB'>): never
    oldValues(): any {
        const result = new ((this as any).constructor)() as TableOf<any>
        result.__as = '_old_'
        result.__oldValues = true
        return result as any
    }

    valuesForInsert(this: OfDB<'postgreSql'>) : AsValuesForInsert<this>
    valuesForInsert(this: OfDB<'sqlite'>) : AsValuesForInsert<this>
    valuesForInsert(this: OfDB<'mariaDB'>) : AsValuesForInsert<this>
    valuesForInsert(this: OfDB<'mySql'>) : AsValuesForInsert<this>
    valuesForInsert(this: OfDB<'noopDB'>) : AsValuesForInsert<this>
    valuesForInsert(this: OfDB<'postgreSql' | 'sqlite' | 'mariaDB' | 'mySql' | 'noopDB'> ): never
    valuesForInsert(): any {
        const result = new ((this as any).constructor)() as TableOf<any>
        result.__as = '_values_for_insert_'
        result.__valuesForInsert = true
        return result as any
    }

    protected column(name: string, type: 'boolean', adapter?: TypeAdapter): BooleanValueSource<SOURCE, 'required'> & Column
    protected column(name: string, type: 'int', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'> & Column
    protected column(name: string, type: 'bigint', adapter?: TypeAdapter): BigintValueSource<SOURCE, 'required'> & Column
    protected column(name: string, type: 'double', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'> & Column
    protected column(name: string, type: 'string', adapter?: TypeAdapter): StringValueSource<SOURCE, 'required'> & Column
    protected column(name: string, type: 'uuid', adapter?: TypeAdapter): UuidValueSource<SOURCE, 'required'> & Column
    protected column(name: string, type: 'localDate', adapter?: TypeAdapter): LocalDateValueSource<SOURCE, 'required'> & Column
    protected column(name: string, type: 'localTime', adapter?: TypeAdapter): LocalTimeValueSource<SOURCE, 'required'> & Column
    protected column(name: string, type: 'localDateTime', adapter?: TypeAdapter): LocalDateTimeValueSource<SOURCE, 'required'> & Column
    protected column<T, TYPE_NAME extends string>(name: string, type: 'customInt', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, TYPE_NAME, 'required'> & Column
    protected column<T, TYPE_NAME extends string>(name: string, type: 'customDouble', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'required'> & Column
    protected column<T, TYPE_NAME extends string>(name: string, type: 'customUuid', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, TYPE_NAME, 'required'> & Column
    protected column<T, TYPE_NAME extends string>(name: string, type: 'customLocalDate', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'required'> & Column
    protected column<T, TYPE_NAME extends string>(name: string, type: 'customLocalTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'required'> & Column
    protected column<T, TYPE_NAME extends string>(name: string, type: 'customLocalDateTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'required'> & Column
    protected column<T, TYPE_NAME extends string>(name: string, type: 'enum', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & Column
    protected column<T, TYPE_NAME extends string>(name: string, type: 'custom', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & Column
    protected column<T, TYPE_NAME extends string>(name: string, type: 'customComparable', typeName: TYPE_NAME, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, TYPE_NAME, 'required'> & Column
    protected column<T>(name: string, type: 'customInt', typeName: string, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, T, 'required'> & Column
    protected column<T>(name: string, type: 'customDouble', typeName: string, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, T, 'required'> & Column
    protected column<T>(name: string, type: 'customUuid', typeName: string, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, T, 'required'> & Column
    protected column<T>(name: string, type: 'customLocalDate', typeName: string, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, T, 'required'> & Column
    protected column<T>(name: string, type: 'customLocalTime', typeName: string, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, T, 'required'> & Column
    protected column<T>(name: string, type: 'customLocalDateTime', typeName: string, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, T, 'required'> & Column
    protected column<T>(name: string, type: 'enum', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'> & Column
    protected column<T>(name: string, type: 'custom', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'> & Column
    protected column<T>(name: string, type: 'customComparable', typeName: string, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, T, 'required'> & Column
    protected column(name: string, type: string, adapter?: TypeAdapter | string, adapter2?: TypeAdapter): any /* EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & Column */ { // Returns any to avoid: Type instantiation is excessively deep and possibly infinite.ts(2589)
        if (typeof adapter === 'string') {
            return new DBColumnImpl(this, name, type as ValueType, adapter, adapter2)
        }
        return new DBColumnImpl(this, name, type as ValueType, type, adapter)
    }

    protected optionalColumn(name: string, type: 'boolean', adapter?: TypeAdapter): BooleanValueSource<SOURCE, 'optional'> & Column
    protected optionalColumn(name: string, type: 'int', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'optional'> & Column
    protected optionalColumn(name: string, type: 'bigint', adapter?: TypeAdapter): BigintValueSource<SOURCE, 'optional'> & Column
    protected optionalColumn(name: string, type: 'double', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'optional'> & Column
    protected optionalColumn(name: string, type: 'string', adapter?: TypeAdapter): StringValueSource<SOURCE, 'optional'> & Column
    protected optionalColumn(name: string, type: 'uuid', adapter?: TypeAdapter): UuidValueSource<SOURCE, 'optional'> & Column
    protected optionalColumn(name: string, type: 'localDate', adapter?: TypeAdapter): LocalDateValueSource<SOURCE, 'optional'> & Column
    protected optionalColumn(name: string, type: 'localTime', adapter?: TypeAdapter): LocalTimeValueSource<SOURCE, 'optional'> & Column
    protected optionalColumn(name: string, type: 'localDateTime', adapter?: TypeAdapter): LocalDateTimeValueSource<SOURCE, 'optional'> & Column
    protected optionalColumn<T, TYPE_NAME extends string>(name: string, type: 'customInt', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, TYPE_NAME, 'optional'> & Column
    protected optionalColumn<T, TYPE_NAME extends string>(name: string, type: 'customDouble', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'optional'> & Column
    protected optionalColumn<T, TYPE_NAME extends string>(name: string, type: 'customUuid', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, TYPE_NAME, 'optional'> & Column
    protected optionalColumn<T, TYPE_NAME extends string>(name: string, type: 'customLocalDate', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'optional'> & Column
    protected optionalColumn<T, TYPE_NAME extends string>(name: string, type: 'customLocalTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'optional'> & Column
    protected optionalColumn<T, TYPE_NAME extends string>(name: string, type: 'customLocalDateTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'optional'> & Column
    protected optionalColumn<T, TYPE_NAME extends string>(name: string, type: 'enum', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'> & Column
    protected optionalColumn<T, TYPE_NAME extends string>(name: string, type: 'custom', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'> & Column
    protected optionalColumn<T, TYPE_NAME extends string>(name: string, type: 'customComparable', typeName: TYPE_NAME, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, TYPE_NAME, 'optional'> & Column
    protected optionalColumn<T>(name: string, type: 'customInt', typeName: string, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, T, 'optional'> & Column
    protected optionalColumn<T>(name: string, type: 'customDouble', typeName: string, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, T, 'optional'> & Column
    protected optionalColumn<T>(name: string, type: 'customUuid', typeName: string, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, T, 'optional'> & Column
    protected optionalColumn<T>(name: string, type: 'customLocalDate', typeName: string, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, T, 'optional'> & Column
    protected optionalColumn<T>(name: string, type: 'customLocalTime', typeName: string, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, T, 'optional'> & Column
    protected optionalColumn<T>(name: string, type: 'customLocalDateTime', typeName: string, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, T, 'optional'> & Column
    protected optionalColumn<T>(name: string, type: 'enum', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'optional'> & Column
    protected optionalColumn<T>(name: string, type: 'custom', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'optional'> & Column
    protected optionalColumn<T>(name: string, type: 'customComparable', typeName: string, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, T, 'optional'> & Column
    protected optionalColumn(name: string, type: string, adapter?: TypeAdapter | string, adapter2?: TypeAdapter): any /* EqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'> & Column */ { // Returns any to avoid: Type instantiation is excessively deep and possibly infinite.ts(2589)
        if (typeof adapter === 'string') {
            return (new DBColumnImpl(this, name, type as ValueType, adapter, adapter2)).__asOptionalColumn()
        }
        return (new DBColumnImpl(this, name, type as ValueType, type, adapter)).__asOptionalColumn()
    }

    protected columnWithDefaultValue(name: string, type: 'boolean', adapter?: TypeAdapter): BooleanValueSource<SOURCE, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue(name: string, type: 'int', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue(name: string, type: 'bigint', adapter?: TypeAdapter): BigintValueSource<SOURCE, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue(name: string, type: 'double', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue(name: string, type: 'string', adapter?: TypeAdapter): StringValueSource<SOURCE, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue(name: string, type: 'uuid', adapter?: TypeAdapter): UuidValueSource<SOURCE, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue(name: string, type: 'localDate', adapter?: TypeAdapter): LocalDateValueSource<SOURCE, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue(name: string, type: 'localTime', adapter?: TypeAdapter): LocalTimeValueSource<SOURCE, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue(name: string, type: 'localDateTime', adapter?: TypeAdapter): LocalDateTimeValueSource<SOURCE, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customInt', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, TYPE_NAME, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customDouble', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customUuid', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, TYPE_NAME, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customLocalDate', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customLocalTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customLocalDateTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'enum', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'custom', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customComparable', typeName: TYPE_NAME, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, TYPE_NAME, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T>(name: string, type: 'customInt', typeName: string, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, T, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T>(name: string, type: 'customDouble', typeName: string, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, T, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T>(name: string, type: 'customUuid', typeName: string, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, T, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T>(name: string, type: 'customLocalDate', typeName: string, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, T, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T>(name: string, type: 'customLocalTime', typeName: string, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, T, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T>(name: string, type: 'customLocalDateTime', typeName: string, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, T, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T>(name: string, type: 'enum', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T>(name: string, type: 'custom', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue<T>(name: string, type: 'customComparable', typeName: string, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, T, 'required'> & ColumnWithDefaultValue
    protected columnWithDefaultValue(name: string, type: string, adapter?: TypeAdapter | string, adapter2?: TypeAdapter): any /* EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & ColumnWithDefaultValue */ { // Returns any to avoid: Type instantiation is excessively deep and possibly infinite.ts(2589)
        if (typeof adapter === 'string') {
            return (new DBColumnImpl(this, name, type as ValueType, adapter, adapter2)).__asColumnWithDefaultValue()
        }
        return (new DBColumnImpl(this, name, type as ValueType, type, adapter)).__asColumnWithDefaultValue()
    }

    protected optionalColumnWithDefaultValue(name: string, type: 'boolean', adapter?: TypeAdapter): BooleanValueSource<SOURCE, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue(name: string, type: 'int', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue(name: string, type: 'bigint', adapter?: TypeAdapter): BigintValueSource<SOURCE, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue(name: string, type: 'double', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue(name: string, type: 'string', adapter?: TypeAdapter): StringValueSource<SOURCE, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue(name: string, type: 'uuid', adapter?: TypeAdapter): UuidValueSource<SOURCE, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue(name: string, type: 'localDate', adapter?: TypeAdapter): LocalDateValueSource<SOURCE, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue(name: string, type: 'localTime', adapter?: TypeAdapter): LocalTimeValueSource<SOURCE, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue(name: string, type: 'localDateTime', adapter?: TypeAdapter): LocalDateTimeValueSource<SOURCE, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customInt', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, TYPE_NAME, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customDouble', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customUuid', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, TYPE_NAME, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customLocalDate', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customLocalTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customLocalDateTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'enum', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'custom', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T, TYPE_NAME extends string>(name: string, type: 'customComparable', typeName: TYPE_NAME, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, TYPE_NAME, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T>(name: string, type: 'customInt', typeName: string, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, T, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T>(name: string, type: 'customDouble', typeName: string, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, T, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T>(name: string, type: 'customUuid', typeName: string, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, T, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T>(name: string, type: 'customLocalDate', typeName: string, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, T, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T>(name: string, type: 'customLocalTime', typeName: string, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, T, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T>(name: string, type: 'customLocalDateTime', typeName: string, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, T, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T>(name: string, type: 'enum', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T>(name: string, type: 'custom', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue<T>(name: string, type: 'customComparable', typeName: string, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, T, 'optional'> & ColumnWithDefaultValue
    protected optionalColumnWithDefaultValue(name: string, type: string, adapter?: TypeAdapter | string, adapter2?: TypeAdapter): any /* EqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'> & ColumnWithDefaultValue */ { // Returns any to avoid: Type instantiation is excessively deep and possibly infinite.ts(2589)
        if (typeof adapter === 'string') {
            return (new DBColumnImpl(this, name, type as ValueType, adapter, adapter2)).__asOptionalColumnWithDefaultValue()
        }
        return (new DBColumnImpl(this, name, type as ValueType, type, adapter)).__asOptionalColumnWithDefaultValue()
    }

    protected autogeneratedPrimaryKey(name: string, type: 'boolean', adapter?: TypeAdapter): BooleanValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey(name: string, type: 'int', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey(name: string, type: 'bigint', adapter?: TypeAdapter): BigintValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey(name: string, type: 'double', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey(name: string, type: 'string', adapter?: TypeAdapter): StringValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey(name: string, type: 'uuid', adapter?: TypeAdapter): UuidValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey(name: string, type: 'localDate', adapter?: TypeAdapter): LocalDateValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey(name: string, type: 'localTime', adapter?: TypeAdapter): LocalTimeValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey(name: string, type: 'localDateTime', adapter?: TypeAdapter): LocalDateTimeValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T, TYPE_NAME extends string>(name: string, type: 'customInt', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T, TYPE_NAME extends string>(name: string, type: 'customDouble', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T, TYPE_NAME extends string>(name: string, type: 'customUuid', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T, TYPE_NAME extends string>(name: string, type: 'customLocalDate', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T, TYPE_NAME extends string>(name: string, type: 'customLocalTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T, TYPE_NAME extends string>(name: string, type: 'customLocalDateTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T, TYPE_NAME extends string>(name: string, type: 'enum', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T, TYPE_NAME extends string>(name: string, type: 'custom', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T, TYPE_NAME extends string>(name: string, type: 'customComparable', typeName: TYPE_NAME, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T>(name: string, type: 'customInt', typeName: string, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T>(name: string, type: 'customDouble', typeName: string, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T>(name: string, type: 'customUuid', typeName: string, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T>(name: string, type: 'customLocalDate', typeName: string, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T>(name: string, type: 'customLocalTime', typeName: string, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T>(name: string, type: 'customLocalDateTime', typeName: string, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T>(name: string, type: 'enum', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T>(name: string, type: 'custom', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey<T>(name: string, type: 'customComparable', typeName: string, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKey(name: string, type: string, adapter?: TypeAdapter | string, adapter2?: TypeAdapter): any /* EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn */ { // Returns any to avoid: Type instantiation is excessively deep and possibly infinite.ts(2589)
        if (typeof adapter === 'string') {
            return (new DBColumnImpl(this, name, type as ValueType, adapter, adapter2)).__asAutogeneratedPrimaryKey()
        }
        return (new DBColumnImpl(this, name, type as ValueType, type, adapter)).__asAutogeneratedPrimaryKey()
    }

    protected primaryKey(name: string, type: 'boolean', adapter?: TypeAdapter): BooleanValueSource<SOURCE, 'required'> & PrimaryKeyColumn
    protected primaryKey(name: string, type: 'int', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'> & PrimaryKeyColumn
    protected primaryKey(name: string, type: 'bigint', adapter?: TypeAdapter): BigintValueSource<SOURCE, 'required'> & PrimaryKeyColumn
    protected primaryKey(name: string, type: 'double', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'> & PrimaryKeyColumn
    protected primaryKey(name: string, type: 'string', adapter?: TypeAdapter): StringValueSource<SOURCE, 'required'> & PrimaryKeyColumn
    protected primaryKey(name: string, type: 'uuid', adapter?: TypeAdapter): UuidValueSource<SOURCE, 'required'> & PrimaryKeyColumn
    protected primaryKey(name: string, type: 'localDate', adapter?: TypeAdapter): LocalDateValueSource<SOURCE, 'required'> & PrimaryKeyColumn
    protected primaryKey(name: string, type: 'localTime', adapter?: TypeAdapter): LocalTimeValueSource<SOURCE, 'required'> & PrimaryKeyColumn
    protected primaryKey(name: string, type: 'localDateTime', adapter?: TypeAdapter): LocalDateTimeValueSource<SOURCE, 'required'> & PrimaryKeyColumn
    protected primaryKey<T, TYPE_NAME extends string>(name: string, type: 'customInt', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyColumn
    protected primaryKey<T, TYPE_NAME extends string>(name: string, type: 'customDouble', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyColumn
    protected primaryKey<T, TYPE_NAME extends string>(name: string, type: 'customUuid', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyColumn
    protected primaryKey<T, TYPE_NAME extends string>(name: string, type: 'customLocalDate', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyColumn
    protected primaryKey<T, TYPE_NAME extends string>(name: string, type: 'customLocalTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyColumn
    protected primaryKey<T, TYPE_NAME extends string>(name: string, type: 'customLocalDateTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyColumn
    protected primaryKey<T, TYPE_NAME extends string>(name: string, type: 'enum', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyColumn
    protected primaryKey<T, TYPE_NAME extends string>(name: string, type: 'custom', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyColumn
    protected primaryKey<T, TYPE_NAME extends string>(name: string, type: 'customComparable', typeName: TYPE_NAME, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyColumn
    protected primaryKey<T>(name: string, type: 'customInt', typeName: string, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, T, 'required'> & PrimaryKeyColumn
    protected primaryKey<T>(name: string, type: 'customDouble', typeName: string, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, T, 'required'> & PrimaryKeyColumn
    protected primaryKey<T>(name: string, type: 'customUuid', typeName: string, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, T, 'required'> & PrimaryKeyColumn
    protected primaryKey<T>(name: string, type: 'customLocalDate', typeName: string, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, T, 'required'> & PrimaryKeyColumn
    protected primaryKey<T>(name: string, type: 'customLocalTime', typeName: string, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, T, 'required'> & PrimaryKeyColumn
    protected primaryKey<T>(name: string, type: 'customLocalDateTime', typeName: string, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, T, 'required'> & PrimaryKeyColumn
    protected primaryKey<T>(name: string, type: 'enum', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'> & PrimaryKeyColumn
    protected primaryKey<T>(name: string, type: 'custom', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'> & PrimaryKeyColumn
    protected primaryKey<T>(name: string, type: 'customComparable', typeName: string, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, T, 'required'> & PrimaryKeyColumn
    protected primaryKey(name: string, type: string, adapter?: TypeAdapter | string, adapter2?: TypeAdapter): any /* EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyColumn */ { // Returns any to avoid: Type instantiation is excessively deep and possibly infinite.ts(2589)
        if (typeof adapter === 'string') {
            return (new DBColumnImpl(this, name, type as ValueType, adapter, adapter2)).__asPrimaryKey()
        }
        return (new DBColumnImpl(this, name, type as ValueType, type, adapter)).__asPrimaryKey()
    }

    protected autogeneratedPrimaryKeyBySequence(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'boolean', adapter?: TypeAdapter): BooleanValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'int', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'bigint', adapter?: TypeAdapter): BigintValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'double', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'string', adapter?: TypeAdapter): StringValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'uuid', adapter?: TypeAdapter): UuidValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'localDate', adapter?: TypeAdapter): LocalDateValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'localTime', adapter?: TypeAdapter): LocalTimeValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'localDateTime', adapter?: TypeAdapter): LocalDateTimeValueSource<SOURCE, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T, TYPE_NAME extends string>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customInt', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T, TYPE_NAME extends string>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customDouble', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T, TYPE_NAME extends string>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customUuid', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T, TYPE_NAME extends string>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customLocalDate', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T, TYPE_NAME extends string>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customLocalTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T, TYPE_NAME extends string>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customLocalDateTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T, TYPE_NAME extends string>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'enum', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T, TYPE_NAME extends string>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'custom', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T, TYPE_NAME extends string>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customComparable', typeName: TYPE_NAME, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customInt', typeName: string, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customDouble', typeName: string, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customUuid', typeName: string, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customLocalDate', typeName: string, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customLocalTime', typeName: string, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customLocalDateTime', typeName: string, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'enum', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'custom', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence<T>(this: OfDB<'oracle' | 'postgreSql' | 'sqlServer'>, name: string, sequenceName: string, type: 'customComparable', typeName: string, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, T, 'required'> & PrimaryKeyAutogeneratedColumn
    protected autogeneratedPrimaryKeyBySequence(name: string, sequenceName: string, type: string, adapter?: TypeAdapter | string, adapter2?: TypeAdapter): any /* EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> & PrimaryKeyAutogeneratedColumn */ { // Returns any to avoid: Type instantiation is excessively deep and possibly infinite.ts(2589)
        if (typeof adapter === 'string') {
            return (new DBColumnImpl(this, name, type as ValueType, adapter, adapter2)).__asAutogeneratedPrimaryKeyBySequence(sequenceName)
        }
        return (new DBColumnImpl(this, name, type as ValueType, type, adapter)).__asAutogeneratedPrimaryKeyBySequence(sequenceName)
    }

    protected computedColumn(name: string, type: 'boolean', adapter?: TypeAdapter): BooleanValueSource<SOURCE, 'required'>
    protected computedColumn(name: string, type: 'int', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'>
    protected computedColumn(name: string, type: 'bigint', adapter?: TypeAdapter): BigintValueSource<SOURCE, 'required'>
    protected computedColumn(name: string, type: 'double', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'>
    protected computedColumn(name: string, type: 'string', adapter?: TypeAdapter): StringValueSource<SOURCE, 'required'>
    protected computedColumn(name: string, type: 'uuid', adapter?: TypeAdapter): UuidValueSource<SOURCE, 'required'>
    protected computedColumn(name: string, type: 'localDate', adapter?: TypeAdapter): LocalDateValueSource<SOURCE, 'required'>
    protected computedColumn(name: string, type: 'localTime', adapter?: TypeAdapter): LocalTimeValueSource<SOURCE, 'required'>
    protected computedColumn(name: string, type: 'localDateTime', adapter?: TypeAdapter): LocalDateTimeValueSource<SOURCE, 'required'>
    protected computedColumn<T, TYPE_NAME extends string>(name: string, type: 'customInt', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected computedColumn<T, TYPE_NAME extends string>(name: string, type: 'customDouble', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected computedColumn<T, TYPE_NAME extends string>(name: string, type: 'customUuid', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected computedColumn<T, TYPE_NAME extends string>(name: string, type: 'customLocalDate', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected computedColumn<T, TYPE_NAME extends string>(name: string, type: 'customLocalTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected computedColumn<T, TYPE_NAME extends string>(name: string, type: 'customLocalDateTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected computedColumn<T, TYPE_NAME extends string>(name: string, type: 'enum', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected computedColumn<T, TYPE_NAME extends string>(name: string, type: 'custom', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected computedColumn<T, TYPE_NAME extends string>(name: string, type: 'customComparable', typeName: TYPE_NAME, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected computedColumn<T>(name: string, type: 'customInt', typeName: string, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, T, 'required'>
    protected computedColumn<T>(name: string, type: 'customDouble', typeName: string, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, T, 'required'>
    protected computedColumn<T>(name: string, type: 'customUuid', typeName: string, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, T, 'required'>
    protected computedColumn<T>(name: string, type: 'customLocalDate', typeName: string, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, T, 'required'>
    protected computedColumn<T>(name: string, type: 'customLocalTime', typeName: string, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, T, 'required'>
    protected computedColumn<T>(name: string, type: 'customLocalDateTime', typeName: string, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, T, 'required'>
    protected computedColumn<T>(name: string, type: 'enum', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'>
    protected computedColumn<T>(name: string, type: 'custom', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'>
    protected computedColumn<T>(name: string, type: 'customComparable', typeName: string, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, T, 'required'>
    protected computedColumn(name: string, type: string, adapter?: TypeAdapter | string, adapter2?: TypeAdapter): any /* EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> */ { // Returns any to avoid: Type instantiation is excessively deep and possibly infinite.ts(2589)
        if (typeof adapter === 'string') {
            return new DBColumnImpl(this, name, type as ValueType, adapter, adapter2).__asComputedColumn()
        }
        return new DBColumnImpl(this, name, type as ValueType, type, adapter).__asComputedColumn()
    }

    protected optionalComputedColumn(name: string, type: 'boolean', adapter?: TypeAdapter): BooleanValueSource<SOURCE, 'optional'>
    protected optionalComputedColumn(name: string, type: 'int', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'optional'>
    protected optionalComputedColumn(name: string, type: 'bigint', adapter?: TypeAdapter): BigintValueSource<SOURCE, 'optional'>
    protected optionalComputedColumn(name: string, type: 'double', adapter?: TypeAdapter): NumberValueSource<SOURCE, 'optional'>
    protected optionalComputedColumn(name: string, type: 'string', adapter?: TypeAdapter): StringValueSource<SOURCE, 'optional'>
    protected optionalComputedColumn(name: string, type: 'uuid', adapter?: TypeAdapter): UuidValueSource<SOURCE, 'optional'>
    protected optionalComputedColumn(name: string, type: 'localDate', adapter?: TypeAdapter): LocalDateValueSource<SOURCE, 'optional'>
    protected optionalComputedColumn(name: string, type: 'localTime', adapter?: TypeAdapter): LocalTimeValueSource<SOURCE, 'optional'>
    protected optionalComputedColumn(name: string, type: 'localDateTime', adapter?: TypeAdapter): LocalDateTimeValueSource<SOURCE, 'optional'>
    protected optionalComputedColumn<T, TYPE_NAME extends string>(name: string, type: 'customInt', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalComputedColumn<T, TYPE_NAME extends string>(name: string, type: 'customDouble', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalComputedColumn<T, TYPE_NAME extends string>(name: string, type: 'customUuid', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalComputedColumn<T, TYPE_NAME extends string>(name: string, type: 'customLocalDate', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalComputedColumn<T, TYPE_NAME extends string>(name: string, type: 'customLocalTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalComputedColumn<T, TYPE_NAME extends string>(name: string, type: 'customLocalDateTime', typeName: TYPE_NAME, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalComputedColumn<T, TYPE_NAME extends string>(name: string, type: 'enum', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalComputedColumn<T, TYPE_NAME extends string>(name: string, type: 'custom', typeName: TYPE_NAME, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalComputedColumn<T, TYPE_NAME extends string>(name: string, type: 'customComparable', typeName: TYPE_NAME, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalComputedColumn<T>(name: string, type: 'customInt', typeName: string, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, T, 'optional'>
    protected optionalComputedColumn<T>(name: string, type: 'customDouble', typeName: string, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, T, 'optional'>
    protected optionalComputedColumn<T>(name: string, type: 'customUuid', typeName: string, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, T, 'optional'>
    protected optionalComputedColumn<T>(name: string, type: 'customLocalDate', typeName: string, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, T, 'optional'>
    protected optionalComputedColumn<T>(name: string, type: 'customLocalTime', typeName: string, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, T, 'optional'>
    protected optionalComputedColumn<T>(name: string, type: 'customLocalDateTime', typeName: string, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, T, 'optional'>
    protected optionalComputedColumn<T>(name: string, type: 'enum', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'optional'>
    protected optionalComputedColumn<T>(name: string, type: 'custom', typeName: string, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'optional'>
    protected optionalComputedColumn<T>(name: string, type: 'customComparable', typeName: string, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, T, 'optional'>
    protected optionalComputedColumn(name: string, type: string, adapter?: TypeAdapter | string, adapter2?: TypeAdapter): any /* EqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'> */ { // Returns any to avoid: Type instantiation is excessively deep and possibly infinite.ts(2589)
        if (typeof adapter === 'string') {
            return (new DBColumnImpl(this, name, type as ValueType, adapter, adapter2)).__asOptionalColumn().__asOptionalComputedColumn()
        }
        return (new DBColumnImpl(this, name, type as ValueType, type, adapter)).__asOptionalColumn().__asOptionalComputedColumn()
    }

    protected virtualColumnFromFragment(type: 'boolean', fn: (fragment: BooleanFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'required'>) => IBooleanValueSource<SOURCE, 'required'>, adapter?: TypeAdapter): BooleanValueSource<SOURCE, 'required'>
    protected virtualColumnFromFragment(type: 'int', fn: (fragment: NumberFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'required'>) => INumberValueSource<SOURCE, 'required'>, adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'>
    protected virtualColumnFromFragment(type: 'bigint', fn: (fragment: BigintFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'required'>) => IBigintValueSource<SOURCE, 'required'>, adapter?: TypeAdapter): BigintValueSource<SOURCE, 'required'>
    protected virtualColumnFromFragment(type: 'double', fn: (fragment: NumberFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'required'>) => INumberValueSource<SOURCE, 'required'>, adapter?: TypeAdapter): NumberValueSource<SOURCE, 'required'>
    protected virtualColumnFromFragment(type: 'string', fn: (fragment: StringFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'required'>) => IStringValueSource<SOURCE, 'required'>, adapter?: TypeAdapter): StringValueSource<SOURCE, 'required'>
    protected virtualColumnFromFragment(type: 'uuid', fn: (fragment: UuidFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'required'>) => IUuidValueSource<SOURCE, 'required'>, adapter?: TypeAdapter): UuidValueSource<SOURCE, 'required'>
    protected virtualColumnFromFragment(type: 'localDate', fn: (fragment: LocalDateFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'required'>) => ILocalDateValueSource<SOURCE, 'required'>, adapter?: TypeAdapter): LocalDateValueSource<SOURCE, 'required'>
    protected virtualColumnFromFragment(type: 'localTime', fn: (fragment: LocalTimeFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'required'>) => ILocalTimeValueSource<SOURCE, 'required'>, adapter?: TypeAdapter): LocalTimeValueSource<SOURCE, 'required'>
    protected virtualColumnFromFragment(type: 'localDateTime', fn: (fragment: LocalDateTimeFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'required'>) => ILocalDateTimeValueSource<SOURCE, 'required'>, adapter?: TypeAdapter): LocalDateTimeValueSource<SOURCE, 'required'>
    protected virtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customInt', typeName: TYPE_NAME, fn: (fragment: CustomIntFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'required'>) => ICustomIntValueSource<SOURCE, T, TYPE_NAME, 'required'>, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected virtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customDouble', typeName: TYPE_NAME, fn: (fragment: CustomDoubleFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'required'>) => ICustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'required'>, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected virtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customUuid', typeName: TYPE_NAME, fn: (fragment: CustomUuidFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'required'>) => ICustomUuidValueSource<SOURCE, T, TYPE_NAME, 'required'>, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected virtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customLocalDate', typeName: TYPE_NAME, fn: (fragment: CustomLocalDateFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'required'>) => ICustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'required'>, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected virtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customLocalTime', typeName: TYPE_NAME, fn: (fragment: CustomLocalTimeFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'required'>) => ICustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'required'>, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected virtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customLocalDateTime', typeName: TYPE_NAME, fn: (fragment: CustomLocalDateTimeFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'required'>) => ICustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'required'>, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected virtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'enum', typeName: TYPE_NAME, fn: (fragment: EqualableFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'required'>) => IEqualableValueSource<SOURCE, T, TYPE_NAME, 'required'>, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected virtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'custom', typeName: TYPE_NAME, fn: (fragment: EqualableFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'required'>) => IEqualableValueSource<SOURCE, T, TYPE_NAME, 'required'>, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected virtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customComparable', typeName: TYPE_NAME, fn: (fragment: ComparableFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'required'>) => IComparableValueSource<SOURCE, T, TYPE_NAME, 'required'>, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, TYPE_NAME, 'required'>
    protected virtualColumnFromFragment<T>(type: 'customInt', typeName: string, fn: (fragment: CustomIntFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'required'>) => ICustomIntValueSource<SOURCE, T, T, 'required'>, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, T, 'required'>
    protected virtualColumnFromFragment<T>(type: 'customDouble', typeName: string, fn: (fragment: CustomDoubleFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'required'>) => ICustomDoubleValueSource<SOURCE, T, T, 'required'>, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, T, 'required'>
    protected virtualColumnFromFragment<T>(type: 'customUuid', typeName: string, fn: (fragment: CustomUuidFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'required'>) => ICustomUuidValueSource<SOURCE, T, T, 'required'>, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, T, 'required'>
    protected virtualColumnFromFragment<T>(type: 'customLocalDate', typeName: string, fn: (fragment: CustomLocalDateFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'required'>) => ICustomLocalDateValueSource<SOURCE, T, T, 'required'>, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, T, 'required'>
    protected virtualColumnFromFragment<T>(type: 'customLocalTime', typeName: string, fn: (fragment: CustomLocalTimeFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'required'>) => ICustomLocalTimeValueSource<SOURCE, T, T, 'required'>, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, T, 'required'>
    protected virtualColumnFromFragment<T>(type: 'customLocalDateTime', typeName: string, fn: (fragment: CustomLocalDateTimeFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'required'>) => ICustomLocalDateTimeValueSource<SOURCE, T, T, 'required'>, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, T, 'required'>
    protected virtualColumnFromFragment<T>(type: 'enum', typeName: string, fn: (fragment: EqualableFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'required'>) => IEqualableValueSource<SOURCE, T, T, 'required'>, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'>
    protected virtualColumnFromFragment<T>(type: 'custom', typeName: string, fn: (fragment: EqualableFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'required'>) => IEqualableValueSource<SOURCE, T, T, 'required'>, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'required'>
    protected virtualColumnFromFragment<T>(type: 'customComparable', typeName: string, fn: (fragment: ComparableFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'required'>) => IComparableValueSource<SOURCE, T, T, 'required'>, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, T, 'required'>
    protected virtualColumnFromFragment(type: string, arg1: any, arg2?: any, arg3?: TypeAdapter): any /* EqualableValueSource<SOURCE, T, TYPE_NAME, 'required'> */ { // Returns any to avoid: Type instantiation is excessively deep and possibly infinite.ts(2589)
        if (typeof arg1 === 'string') {
            const fragmentBuilder =  new FragmentQueryBuilder(type as ValueType, arg1, 'required', arg3)
            return new ValueSourceFromBuilder(arg2 as (fragment: any) => AnyValueSource, fragmentBuilder, type as ValueType, arg1, 'required', arg3)
        }
        const fragmentBuilder =  new FragmentQueryBuilder(type as ValueType, type, 'required', arg2 as TypeAdapter | undefined)
        return new ValueSourceFromBuilder(arg1 as (fragment: any) => AnyValueSource, fragmentBuilder, type as ValueType, type, 'required', arg2 as TypeAdapter | undefined)
    }

    protected optionalVirtualColumnFromFragment(type: 'boolean', fn: (fragment: BooleanFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'optional'>) => IBooleanValueSource<SOURCE, 'optional'>, adapter?: TypeAdapter): BooleanValueSource<SOURCE, 'optional'>
    protected optionalVirtualColumnFromFragment(type: 'int', fn: (fragment: NumberFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'optional'>) => INumberValueSource<SOURCE, 'optional'>, adapter?: TypeAdapter): NumberValueSource<SOURCE, 'optional'>
    protected optionalVirtualColumnFromFragment(type: 'bigint', fn: (fragment: BigintFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'optional'>) => IBigintValueSource<SOURCE, 'optional'>, adapter?: TypeAdapter): BigintValueSource<SOURCE, 'optional'>
    protected optionalVirtualColumnFromFragment(type: 'double', fn: (fragment: NumberFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'optional'>) => INumberValueSource<SOURCE, 'optional'>, adapter?: TypeAdapter): NumberValueSource<SOURCE, 'optional'>
    protected optionalVirtualColumnFromFragment(type: 'string', fn: (fragment: StringFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'optional'>) => IStringValueSource<SOURCE, 'optional'>, adapter?: TypeAdapter): StringValueSource<SOURCE, 'optional'>
    protected optionalVirtualColumnFromFragment(type: 'uuid', fn: (fragment: UuidFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'optional'>) => IUuidValueSource<SOURCE, 'optional'>, adapter?: TypeAdapter): UuidValueSource<SOURCE, 'optional'>
    protected optionalVirtualColumnFromFragment(type: 'localDate', fn: (fragment: LocalDateFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'optional'>) => ILocalDateValueSource<SOURCE, 'optional'>, adapter?: TypeAdapter): LocalDateValueSource<SOURCE, 'optional'>
    protected optionalVirtualColumnFromFragment(type: 'localTime', fn: (fragment: LocalTimeFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'optional'>) => ILocalTimeValueSource<SOURCE, 'optional'>, adapter?: TypeAdapter): LocalTimeValueSource<SOURCE, 'optional'>
    protected optionalVirtualColumnFromFragment(type: 'localDateTime', fn: (fragment: LocalDateTimeFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, 'optional'>) => ILocalDateTimeValueSource<SOURCE, 'optional'>, adapter?: TypeAdapter): LocalDateTimeValueSource<SOURCE, 'optional'>
    protected optionalVirtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customInt', typeName: TYPE_NAME, fn: (fragment: CustomIntFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'optional'>) => ICustomIntValueSource<SOURCE, T, TYPE_NAME, 'optional'>, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalVirtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customDouble', typeName: TYPE_NAME, fn: (fragment: CustomDoubleFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'optional'>) => ICustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'optional'>, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalVirtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customUuid', typeName: TYPE_NAME, fn: (fragment: CustomUuidFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'optional'>) => ICustomUuidValueSource<SOURCE, T, TYPE_NAME, 'optional'>, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalVirtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customLocalDate', typeName: TYPE_NAME, fn: (fragment: CustomLocalDateFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'optional'>) => ICustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'optional'>, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalVirtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customLocalTime', typeName: TYPE_NAME, fn: (fragment: CustomLocalTimeFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'optional'>) => ICustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'optional'>, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalVirtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customLocalDateTime', typeName: TYPE_NAME, fn: (fragment: CustomLocalDateTimeFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'optional'>) => ICustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'optional'>, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalVirtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'enum', typeName: TYPE_NAME, fn: (fragment: EqualableFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'optional'>) => IEqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'>, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalVirtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'custom', typeName: TYPE_NAME, fn: (fragment: EqualableFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'optional'>) => IEqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'>, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalVirtualColumnFromFragment<T, TYPE_NAME extends string>(type: 'customComparable', typeName: TYPE_NAME, fn: (fragment: ComparableFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, TYPE_NAME, 'optional'>) => IComparableValueSource<SOURCE, T, TYPE_NAME, 'optional'>, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, TYPE_NAME, 'optional'>
    protected optionalVirtualColumnFromFragment<T>(type: 'customInt', typeName: string, fn: (fragment: CustomIntFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'optional'>) => ICustomIntValueSource<SOURCE, T, T, 'optional'>, adapter?: TypeAdapter): CustomIntValueSource<SOURCE, T, T, 'optional'>
    protected optionalVirtualColumnFromFragment<T>(type: 'customDouble', typeName: string, fn: (fragment: CustomDoubleFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'optional'>) => ICustomDoubleValueSource<SOURCE, T, T, 'optional'>, adapter?: TypeAdapter): CustomDoubleValueSource<SOURCE, T, T, 'optional'>
    protected optionalVirtualColumnFromFragment<T>(type: 'customUuid', typeName: string, fn: (fragment: CustomUuidFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'optional'>) => ICustomUuidValueSource<SOURCE, T, T, 'optional'>, adapter?: TypeAdapter): CustomUuidValueSource<SOURCE, T, T, 'optional'>
    protected optionalVirtualColumnFromFragment<T>(type: 'customLocalDate', typeName: string, fn: (fragment: CustomLocalDateFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'optional'>) => ICustomLocalDateValueSource<SOURCE, T, T, 'optional'>, adapter?: TypeAdapter): CustomLocalDateValueSource<SOURCE, T, T, 'optional'>
    protected optionalVirtualColumnFromFragment<T>(type: 'customLocalTime', typeName: string, fn: (fragment: CustomLocalTimeFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'optional'>) => ICustomLocalTimeValueSource<SOURCE, T, T, 'optional'>, adapter?: TypeAdapter): CustomLocalTimeValueSource<SOURCE, T, T, 'optional'>
    protected optionalVirtualColumnFromFragment<T>(type: 'customLocalDateTime', typeName: string, fn: (fragment: CustomLocalDateTimeFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'optional'>) => ICustomLocalDateTimeValueSource<SOURCE, T, T, 'optional'>, adapter?: TypeAdapter): CustomLocalDateTimeValueSource<SOURCE, T, T, 'optional'>
    protected optionalVirtualColumnFromFragment<T>(type: 'enum', typeName: string, fn: (fragment: EqualableFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'optional'>) => IEqualableValueSource<SOURCE, T, T, 'optional'>, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'optional'>
    protected optionalVirtualColumnFromFragment<T>(type: 'custom', typeName: string, fn: (fragment: EqualableFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'optional'>) => IEqualableValueSource<SOURCE, T, T, 'optional'>, adapter?: TypeAdapter): EqualableValueSource<SOURCE, T, T, 'optional'>
    protected optionalVirtualColumnFromFragment<T>(type: 'customComparable', typeName: string, fn: (fragment: ComparableFragmentExpression<NNoTableOrViewRequiredFrom<SOURCE>, T, T, 'optional'>) => IComparableValueSource<SOURCE, T, T, 'optional'>, adapter?: TypeAdapter): ComparableValueSource<SOURCE, T, T, 'optional'>
    protected optionalVirtualColumnFromFragment(type: string, arg1: any, arg2?: any, arg3?: TypeAdapter): any /* EqualableValueSource<SOURCE, T, TYPE_NAME, 'optional'> */ { // Returns any to avoid: Type instantiation is excessively deep and possibly infinite.ts(2589)
        if (typeof arg1 === 'string') {
            const fragmentBuilder =  new FragmentQueryBuilder(type as ValueType, arg1, 'optional', arg3)
            return new ValueSourceFromBuilder(arg2 as (fragment: any) => AnyValueSource, fragmentBuilder, type as ValueType, arg1, 'optional', arg3)
        }
        const fragmentBuilder =  new FragmentQueryBuilder(type as ValueType, type, 'optional', arg2 as TypeAdapter | undefined)
        return new ValueSourceFromBuilder(arg1 as (fragment: any) => AnyValueSource, fragmentBuilder, type as ValueType, type, 'optional', arg2 as TypeAdapter | undefined)
    }

    // @ts-ignore
    private __addWiths(sqlBuilder: HasIsValue, withs: Array<IWithView<any>>): void {
        __addWiths(this.__template, sqlBuilder, withs)
    }

    // @ts-ignore
    private __registerTableOrView(sqlBuilder: HasIsValue, requiredTablesOrViews: Set<ITableOrView<any>>): void {
        requiredTablesOrViews.add(this)
        __registerTableOrView(this.__template, sqlBuilder, requiredTablesOrViews)
    }

    // @ts-ignore
    private __registerRequiredColumn(sqlBuilder: HasIsValue, requiredColumns: Set<DBColumn>, onlyForTablesOrViews: Set<ITableOrView<any>>): void {
        __registerRequiredColumn(this.__template, sqlBuilder, requiredColumns, onlyForTablesOrViews)
    }

    // @ts-ignore
    private __getOldValues(_sqlBuilder: HasIsValue): ITableOrView<any> | undefined {
        if (this.__oldValues) {
            return this
        }
        return undefined
    }

    // @ts-ignore
    private __getValuesForInsert(_sqlBuilder: HasIsValue): ITableOrView<any> | undefined {
        if (this.__valuesForInsert) {
            return this
        }
        return undefined
    }

    // @ts-ignore
    private __isAllowed(_sqlBuilder: HasIsValue): boolean {
        return true
    }
}

export class Table</*in|out*/ CONNECTION extends IConnection<any>, NAME extends string> extends TableOf<NTable<CONNECTION[typeof connection], NAME>> {
    constructor(name: string) {
        super(name)
    }
}
