import type { ITable, ITableOrView, IView, IWithView, IValues, ResolvedShape, OldValues, ValuesForInsert, ForUseInLeftJoin, HasSource, ITableOrViewAlias } from "./ITableOrView"
import type { AnyValueSource, IValueSource, RemapValueSourceType, ValueSourceValueType } from "../expressions/values"
import type { source } from "./symbols"
import type { WritableDBColumn, WritableDBColumnWithDefaultValue, WritableDBColumnWithoutDefaultValue, WritableDBPrimaryKeyColumnWithDefaultValue } from "./Column"
import type { NAlias, NAsLeftJoin, NCustomizeAs, NGetDBFrom, NGetNameFrom, NOldValues, NSource, NValuesForInsert } from "./sourceName"
import type { ColumnsForAlias } from '../complexProjections/tableAlias'
import type { ColumnsForLeftJoin } from '../complexProjections/asLeftJoin'

export type ColumnsKeyOf<T> = ({ [K in keyof T]-?: T[K] extends WritableDBColumn ? K : never })[keyof T]
type ValueSourcesKeyOf<T> = ({ [K in keyof T]-?: T[K] extends AnyValueSource ? K : never })[keyof T]

export type AsOldValues<T extends ITableOrView<any>> = ColumnsForAlias<NOldValues<NGetDBFrom<T[typeof source]>, NGetNameFrom<T[typeof source]>>, T> & OldValues<NOldValues<NGetDBFrom<T[typeof source]>, NGetNameFrom<T[typeof source]>>>
export type AsValuesForInsert<T extends ITableOrView<any>> = ColumnsForAlias<NValuesForInsert<NGetDBFrom<T[typeof source]>, NGetNameFrom<T[typeof source]>>, T> & ValuesForInsert<NValuesForInsert<NGetDBFrom<T[typeof source]>, NGetNameFrom<T[typeof source]>>>
export type AliasedTableOrView<T extends ITableOrView<any>, ALIAS extends string> = ColumnsForAlias<NAlias<T[typeof source], ALIAS>, T> & ITableOrViewAlias< NAlias<T[typeof source], ALIAS>>

export type AsForUseInLeftJoin<T extends ITableOrView<any>> = ColumnsForLeftJoin<NAsLeftJoin<T[typeof source]>, T> & ForUseInLeftJoin<NAsLeftJoin<T[typeof source]>>
export type AsAliasedForUseInLeftJoin<T extends ITableOrView<any>, ALIAS extends string> = ColumnsForLeftJoin<NAlias<NAsLeftJoin<T[typeof source]>, ALIAS>, T> & ForUseInLeftJoin<NAlias<NAsLeftJoin<T[typeof source]>, ALIAS>>

export type FromRef<T extends ITableOrView<any>, REF extends HasSource<any>> = { [K in ValueSourcesKeyOf<T>]: RemapValueSourceType<REF[typeof source], T[K]> } & REF

type AddAliasMethods<T extends ITableOrView<any>> = T & {
    as<ALIAS extends string>(as: ALIAS): AliasedTableOrView<T, ALIAS>
    forUseInLeftJoin(): AsForUseInLeftJoin<T>
    forUseInLeftJoinAs<ALIAS extends string>(as: ALIAS): AsAliasedForUseInLeftJoin<T, ALIAS>
}

// COLUMNS already remapped using ColumnsForWithView before call WithView in order to make the type readable
export type WithView<SOURCE extends NSource, COLUMNS> = AddAliasMethods<COLUMNS & IWithView<SOURCE>>

type CustomizedTableOrViewType<T extends ITableOrView<any>, SOURCE extends NSource> = 
    T extends ITableOrViewAlias<any> ? ITableOrViewAlias<SOURCE>
    : T extends ITable<any> ? ITable<SOURCE>
    : T extends IView<any> ? IView<SOURCE>
    : T extends IWithView<any> ? IWithView<SOURCE>
    : T extends IValues<any> ? IValues<SOURCE>
    : never

type CustomizedTableOrViewNoAliasable<T extends ITableOrView<any>, SOURCE extends string> = ColumnsForAlias<SOURCE, T> & CustomizedTableOrViewType<T, SOURCE>

export type CustomizedTableOrView<T extends ITableOrView<any>, CUSTOMIZATION_NAME extends string> =
    (T extends {as(as: any): any}
    ? AddAliasMethods<CustomizedTableOrViewNoAliasable<T, NCustomizeAs<T[typeof source], CUSTOMIZATION_NAME>>>
    : CustomizedTableOrViewNoAliasable<T, NCustomizeAs<T[typeof source], CUSTOMIZATION_NAME>>
    ) & { /* added to avoid typescript expansion type, generating better error messages */ }

export type AutogeneratedPrimaryKeyColumnsTypesOf<T> = { [K in ColumnsKeyOf<T>]-?: 
    T[K] extends WritableDBPrimaryKeyColumnWithDefaultValue ? ValueSourceValueType<T[K]> : never
}[ColumnsKeyOf<T>]

export type ColumnsForSetOfWithShape<TABLE, SHAPE> = 
    SHAPE extends ResolvedShape<any>
    ? ColumnsForSetOf<SHAPE>
    : ColumnsForSetOf<TABLE>

export type ColumnsForSetOf<TYPE> = ColumnsKeyOf<TYPE>

export type RequiredColumnsForSetOfWithShape<TABLE, SHAPE> = 
    SHAPE extends ResolvedShape<any>
    ? RequiredColumnsForSetOf<SHAPE>
    : RequiredColumnsForSetOf<TABLE>

export type RequiredColumnsForSetOf<T> = { [K in ColumnsKeyOf<T>]-?: 
    T[K] extends IValueSource<any, any, any, 'required'> & WritableDBColumnWithoutDefaultValue ? K : never
}[ColumnsKeyOf<T>]

export type OptionalColumnsForSetOfWithShape<TABLE, SHAPE> = 
    SHAPE extends ResolvedShape<any>
    ? OptionalColumnsForSetOf<SHAPE>
    : OptionalColumnsForSetOf<TABLE>

export type OptionalColumnsForSetOf<T> = { [K in ColumnsKeyOf<T>]-?: 
    T[K] extends WritableDBColumnWithDefaultValue ? K
    : T[K] extends IValueSource<any, any, any, infer OPTIONAL_TYPE> & WritableDBColumn
    ? (
        OPTIONAL_TYPE extends 'required'
        ? never
        : K
    ) : never 
}[ColumnsKeyOf<T>]

export type ResolveShape<T extends HasSource<any>, SHAPE extends {}> = {
    [P in keyof SHAPE]: SHAPE[P] extends keyof T ? T[SHAPE[P]] : SHAPE[P]
} &  ResolvedShape<T[typeof source]>
