import { PostgreSqlConnection } from "../../connections/PostgreSqlConnection"
import { DynamicCondition, dynamicPick, DynamicPickPaths, dynamicPickPaths, expandTypeFromDynamicPickPaths, PickValuesPath } from "../../dynamicCondition"
import { fromRef, TableOrViewLeftJoinOf } from "../../extras/types"
import { extractColumnNamesFrom, extractColumnsFrom, extractWritableColumnNamesFrom, extractWritableColumnsFrom } from "../../extras/utils"
import { ConsoleLogQueryRunner } from "../../queryRunners/ConsoleLogQueryRunner"
import { MockQueryRunner } from "../../queryRunners/MockQueryRunner"
import { Table } from "../../Table"
import { CustomBooleanTypeAdapter } from "../../TypeAdapter"
import { Values } from "../../Values"
import { View } from "../../View"
import { assertEquals } from "../assertEquals"

class DBConnection extends PostgreSqlConnection<'DBConnection'> { 
    // insesitiveCollation = 'acs'

    bitwiseShiftLeft = this.buildFragmentWithArgs(
        this.arg('int', 'required'),
        this.arg('int', 'required')
    ).as((left, right) => {
        // The fragment here is: ${left} << ${right}
        // Could be another fragment like a function call: myFunction(${left}, ${right})
        return this.fragmentWithType('int', 'required').sql`${left} << ${right}`
    })

    bitwiseShiftLeft2 = this.buildFragmentWithMaybeOptionalArgs(
        this.arg('int', 'optional'),
        this.arg('int', 'optional')
    ).as((left, right) => {
        // The fragment here is: ${left} << ${right}
        // Could be another fragment like a function call: myFunction(${left}, ${right})
        return this.fragmentWithType('int', 'optional').sql`${left} << ${right}`
    })

    valuePlusOneEqualsIfValue = this.buildFragmentWithArgsIfValue(
        this.arg('int', 'required'),
        this.valueArg('int', 'optional')
    ).as((left, right) => {
        // The fragment here is: ${left} + 1 = ${right}
        // Could be another fragment like a function call: myFunction(${left}, ${right})
        return this.fragmentWithType('boolean', 'required').sql`${left} + 1 = ${right}`
    })

    forSystemTimeBetween = this.createTableOrViewCustomization<Date, Date>((table, alias, fromDate, toDate) => {
        const from = this.const(fromDate, 'localDateTime')
        const to = this.const(toDate, 'localDateTime')
        return this.rawFragment`${table} for system_time between ${from} and ${to} ${alias}`
    })
}

const tCompany = new class TCompany extends Table<DBConnection, 'TCompany'> {
    id = this.autogeneratedPrimaryKey('id', 'int')
    name = this.column('name', 'string')
    parentId = this.optionalColumn('parent_id', 'int')
    favouriteCustomerId = this.optionalColumn('parent_id', 'int')
    ubicationLatitude = this.optionalColumn('ubication_latitude', 'string')
    ubicationLongitude = this.optionalColumn('ubication_longitude', 'string')
    ubicationComment = this.optionalColumn('ubication_comment', 'string')
    constructor() {
        super('company'); // table name in the database
    }
}()

const tCustomer = new class TCustomer extends Table<DBConnection, 'TCustomer'> {
    id = this.autogeneratedPrimaryKey('id', 'int')
    firstName = this.column('first_name', 'string')
    lastName = this.column('last_name', 'string')
    birthday = this.optionalColumn('birthday', 'localDate')
    companyId = this.column('company_id', 'int')
    name = this.firstName.concat(' ').concat(this.lastName)
    age = this.optionalVirtualColumnFromFragment('int', (fragment) => {
        return fragment.sql`calculateAge(${this.birthday})`
    })
    constructor() {
        super('customer'); // table name in the database
    }
}()

const vCustomerAndCompany = new class VCustomerAndCompany extends View<DBConnection, 'VCustomerAndCompany'> {
    companyId = this.column('company_id', 'int')
    companyName = this.column('company_name', 'string')
    customerId = this.column('customer_id', 'int')
    customerFirstName = this.column('customer_first_name', 'string')
    customerLastName = this.column('customer_last_name', 'string')
    customerBirthday = this.optionalColumn('customer_birthday', 'localDate')
    constructor() {
        super('customer_company')
    }
}()
vCustomerAndCompany.as('testView')

const tCustomCompany = new class TCustomCompany extends Table<DBConnection, 'TCustomCompany'> {
    id = this.autogeneratedPrimaryKey('id', 'int');
    name = this.column('name', 'string');
    isBig = this.column('is_big', 'boolean', new CustomBooleanTypeAdapter('Y', 'N'));
    constructor() {
        super('custom_company'); // table name in the database
    }
}()

const tRecord = new class TRecord extends Table<DBConnection, 'TRecord'> {
    id = this.primaryKey('id', 'uuid');
    title = this.column('title', 'string');
    constructor() {
        super('record'); // table name in the database
    }
}()

async function main() {
    let result: any
    const expectedResult: any[] = []
    const expectedQuery: string[] = []
    const expectedParams: string[] = []
    const expectedType: string[] = []
    const mockQueryRunner = new MockQueryRunner(
        (type, query, params, index) => {
            assertEquals(query, expectedQuery[index])
            assertEquals(JSON.stringify(params), expectedParams[index])
            assertEquals(type, expectedType[index])
            return expectedResult[index]
        }
    )

    const connection = new DBConnection(new ConsoleLogQueryRunner(mockQueryRunner))

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, parent_id as "parentId", ubication_latitude as "ubication.latitude", ubication_longitude as "ubication.longitude", ubication_comment as "ubication.comment" from company`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const companies = await connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId,
            ubication: {
                latitude: tCompany.ubicationLatitude.asRequiredInOptionalObject(),
                longitude: tCompany.ubicationLongitude.asRequiredInOptionalObject(),
                comment: tCompany.ubicationComment
            }
        })
        .executeSelectMany()
    
    assertEquals(companies, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    let customerId = 10
    
    let customerWithId = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .executeSelectOne()
    
    assertEquals(customerWithId, result)

    let typeValidation: {
        id: number;
        firstName: string;
        lastName: string;
        birthday?: Date | undefined;
    } = null as any

    customerWithId = typeValidation
    typeValidation = customerWithId

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName" from customer where id = $1 order by customer.birthday desc nulls last`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    // const customerId = 10
    
    const customerWithId2 = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .orderBy(tCustomer.birthday, 'desc nulls last')
        .executeSelectOne()
    
    assertEquals(customerWithId2, result)

    /* *** Preparation ************************************************************/

    result = [{
        id: 1,
        name: {
            firstName: 'First Name',
            lastName: 'Last Name'
        }
    }]
    expectedResult.push([{
        id: 1,
        'name.firstName': 'First Name',
        'name.lastName': 'Last Name'
    }])
    expectedQuery.push(`select id as id, first_name as "name.firstName", last_name as "name.lastName", birthday as birthday from customer where company_id = $1 order by "name.firstName", "name.lastName"`)
    expectedParams.push(`[24]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    let companyId = 24

    const customersOfCompany = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.equals(companyId))
        .select({
            id: tCustomer.id,
            name: {
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
            },
            birthday: tCustomer.birthday
        })
        .orderBy('name.firstName')
        .orderBy('name.lastName')
        .executeSelectMany()
    
    assertEquals(customersOfCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || $1 || last_name as name, birthday as birthday from customer where first_name like ('%' || $2 || '%') order by lower(name), birthday asc nulls last`)
    expectedParams.push(`[" ","ohn"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const firstNameContains = 'ohn'
    const lastNameContains = null
    const birthdayIs = null
    const searchOrderBy = 'name insensitive, birthday asc nulls last'
    
    const searchedCustomers = await connection.selectFrom(tCustomer)
        .where(
                    tCustomer.firstName.containsIfValue(firstNameContains)
                .or(tCustomer.lastName.containsIfValue(lastNameContains))
            ).and(
                tCustomer.birthday.equalsIfValue(birthdayIs)
            )
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            birthday: tCustomer.birthday
        })
        .orderByFromString(searchOrderBy)
        .executeSelectMany()
    
    assertEquals(searchedCustomers, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || $1 || last_name as name, birthday as birthday from customer where first_name like ('%' || $2 || '%') order by lower(name), birthday asc nulls last`)
    expectedParams.push(`[" ","ohn"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    let searchedCustomersWhere = connection.dynamicBooleanExpressionUsing(tCustomer)
    if (firstNameContains) {
        searchedCustomersWhere = searchedCustomersWhere.and(tCustomer.firstName.contains(firstNameContains))
    }
    if (lastNameContains) {
        searchedCustomersWhere = searchedCustomersWhere.or(tCustomer.lastName.contains(lastNameContains))
    }
    if (birthdayIs) {
        searchedCustomersWhere = searchedCustomersWhere.and(tCustomer.birthday.equals(birthdayIs))
    }
    
    const searchedCustomers2 = await connection.selectFrom(tCustomer)
        .where(searchedCustomersWhere)
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            birthday: tCustomer.birthday
        })
        .orderByFromString(searchOrderBy)
        .executeSelectMany()
    
    assertEquals(searchedCustomers2, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || $1 || last_name as name, birthday as birthday from customer where first_name like ('%' || $2 || '%') order by lower(name), birthday asc nulls last`)
    expectedParams.push(`[" ","ohn"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const hideId = false

    let searchedCustomersWhere3 = connection.dynamicBooleanExpressionUsing(tCustomer)
    if (firstNameContains) {
        searchedCustomersWhere3 = searchedCustomersWhere3.and(tCustomer.firstName.contains(firstNameContains))
    }
    if (lastNameContains) {
        searchedCustomersWhere3 = searchedCustomersWhere3.or(tCustomer.lastName.contains(lastNameContains))
    }
    if (birthdayIs) {
        searchedCustomersWhere3 = searchedCustomersWhere3.and(tCustomer.birthday.equals(birthdayIs))
    }
    searchedCustomersWhere3 = searchedCustomersWhere3
    
    const searchedCustomers3 = await connection.selectFrom(tCustomer)
        .where(searchedCustomersWhere3)
        .select({
            id: tCustomer.id.ignoreWhenAsNull(hideId),
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            birthday: tCustomer.birthday
        })
        .orderByFromString(searchOrderBy)
        .executeSelectMany()
    
    assertEquals(searchedCustomers3, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as "firstName", customer.last_name as "lastName", customer.birthday as birthday, comp.name as "companyName" from customer inner join company as comp on customer.company_id = comp.id where customer.first_name ilike ($1 || '%') order by lower("firstName"), lower("lastName") asc`)
    expectedParams.push(`["John"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const firstName = 'John'
    const lastName = null
    
    const company = tCompany.as('comp')
    const customersWithCompanyName = await connection.selectFrom(tCustomer)
        .innerJoin(company).on(tCustomer.companyId.equals(company.id))
        .where(tCustomer.firstName.startsWithInsensitive(firstName))
            .and(tCustomer.lastName.startsWithInsensitiveIfValue(lastName))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday,
            companyName: company.name
        })
        .orderBy('firstName', 'insensitive')
        .orderBy('lastName', 'asc insensitive')
        .executeSelectMany()
    
    assertEquals(customersWithCompanyName, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as "customerId", first_name as "customerFirstName", last_name as "customerLastName" from customer where company_id in (select id as result from company where name like ('%' || $1 || '%')) order by "customerFirstName" asc nulls first, "customerLastName"`)
    expectedParams.push(`["Cia."]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const orderBy = 'customerFirstName asc nulls first, customerLastName'
    const customerWithSelectedCompanies = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.in(
            connection.selectFrom(tCompany)
                .where(tCompany.name.contains('Cia.'))
                .selectOneColumn(tCompany.id)
        )).select({
            customerId: tCustomer.id,
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        }).orderByFromString(orderBy)
        .executeSelectMany()
    
    assertEquals(customerWithSelectedCompanies, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select company.id as "companyId", company.name as "companyName", count(customer.id) as "customerCount" from company inner join customer on customer.company_id = company.id group by company.id, company.name`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompany = await connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        }).groupBy('companyId', 'companyName')
        .executeSelectMany()
    
    assertEquals(customerCountPerCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select company.id as "companyId", company.name as "companyName", count(customer.id) as "customerCount" from company inner join customer on customer.company_id = company.id group by company.id, company.name`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompany2 = await connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .groupBy(tCompany.id, tCompany.name)
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        })
        .executeSelectMany()
    
    assertEquals(customerCountPerCompany2, result)
    
    /* *** Preparation ************************************************************/

    result = {
        data: [],
        count: 0
    }
    expectedResult.push([])
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName" from customer where first_name ilike ($1 || '%') or last_name ilike ($2 || '%') order by "firstName", "lastName" limit $3 offset $4`)
    expectedParams.push(`["Smi","Smi",10,20]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push(0)
    expectedQuery.push(`select count(*) from customer where first_name ilike ($1 || '%') or last_name ilike ($2 || '%')`)
    expectedParams.push(`["Smi","Smi"]`)
    expectedType.push(`selectOneColumnOneRow`)
    
    /* *** Example ****************************************************************/

    const customerName = 'Smi'
    const customerPageWithName = await connection.selectFrom(tCustomer)
        .where(
            tCustomer.firstName.startsWithInsensitive(customerName)
        ).or(
            tCustomer.lastName.startsWithInsensitive(customerName)
        ).select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .orderBy('firstName')
        .orderBy('lastName')
        .limit(10)
        .offset(20)
        .executeSelectPage()
    
    assertEquals(customerPageWithName, result)
    
    /* *** Preparation ************************************************************/

    result = null
    expectedResult.push(result)
    expectedQuery.push(`select id::varchar as "idAsString", first_name || $1 || last_name as name from customer where !!id = !!$2`)
    expectedParams.push(`[" ",10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const id = 10
    const customersUsingCustomFragment = await connection.selectFrom(tCustomer)
        .where(connection.fragmentWithType('boolean', 'required').sql`!!${tCustomer.id} = !!${connection.const(id, 'int')}`)
        .select({
            idAsString: connection.fragmentWithType('string', 'required').sql`${tCustomer.id}::varchar`,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName)
        })
        .executeSelectNoneOrOne()
    
    assertEquals(customersUsingCustomFragment, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, id << $1 as "idMultiplyBy2" from company where (id * $2) = (id << $3)`)
    expectedParams.push(`[1,2,1]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const bitwiseMovements = 1
    const multiplier = 2
    const companiesUsingCustomFunctionFragment = await connection.selectFrom(tCompany)
        .where(tCompany.id.multiply(multiplier).equals(connection.bitwiseShiftLeft(tCompany.id, bitwiseMovements)))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            idMultiplyBy2: connection.bitwiseShiftLeft(tCompany.id, bitwiseMovements)
        })
        .executeSelectMany()
    
    assertEquals(companiesUsingCustomFunctionFragment, result)

    /* *** Preparation ************************************************************/

    result = [{id: 1, name: 'John'}]
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, id << $1 as "idMultiplyBy2" from company where (id * $2) = (id << $3)`)
    expectedParams.push(`[null,2,null]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const bitwiseMovements2 = null
    //const multiplier = 2
    const companiesUsingCustomFunctionFragment2 = await connection.selectFrom(tCompany)
        .where(tCompany.id.multiply(multiplier).equals(connection.bitwiseShiftLeft2(tCompany.id, bitwiseMovements2)))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            idMultiplyBy2: connection.bitwiseShiftLeft2(tCompany.id, bitwiseMovements2)
        })
        .executeSelectMany()
    
    assertEquals(companiesUsingCustomFunctionFragment2, result)

    /* *** Preparation ************************************************************/

    result = [{id: 1, name: 'John', idMultiplyBy2: 2}]
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, id << $1 as "idMultiplyBy2" from company where (id * $2) = (id << $3)`)
    expectedParams.push(`[1,2,1]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const bitwiseMovements3 = 1
    //const multiplier = 2
    const companiesUsingCustomFunctionFragment3 = await connection.selectFrom(tCompany)
        .where(tCompany.id.multiply(multiplier).equals(connection.bitwiseShiftLeft2(tCompany.id, bitwiseMovements3)))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            idMultiplyBy2: connection.bitwiseShiftLeft2(tCompany.id, bitwiseMovements3)
        })
        .executeSelectMany()
    
    assertEquals(companiesUsingCustomFunctionFragment3, result)

    /* *** Preparation ************************************************************/

    result = [{id: 1, name: 'John'}]
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, id << $1 as "idMultiplyBy2" from company where (id * $2) = (id << $3)`)
    expectedParams.push(`[1,2,1]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const bitwiseMovements4 = 1
    //const multiplier = 2
    const companiesUsingCustomFunctionFragment4 = await connection.selectFrom(tCompany)
        .where(tCompany.id.multiply(multiplier).equals(connection.bitwiseShiftLeft2(tCompany.id, bitwiseMovements4)))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            idMultiplyBy2: connection.bitwiseShiftLeft2(tCompany.id.asOptional(), bitwiseMovements4)
        })
        .executeSelectMany()
    
    assertEquals(companiesUsingCustomFunctionFragment4, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name from company where id + 1 = $1`)
    expectedParams.push(`[2]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const noValue = null
    const withValue = 2
    const companiesUsingCustomFunctionFragmentIfValue = await connection.selectFrom(tCompany)
        .where(connection.valuePlusOneEqualsIfValue(tCompany.id, noValue))
            .or(connection.valuePlusOneEqualsIfValue(tCompany.id, withValue))
        .select({
            id: tCompany.id,
            name: tCompany.name,
        })
        .executeSelectMany()
    
    assertEquals(companiesUsingCustomFunctionFragmentIfValue, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id, birthday) values ($1, $2, $3, $4) returning id`)
    expectedParams.push(`["John","Smith",1,"2000-03-01T00:00:00.000Z"]`)
    expectedType.push(`insertReturningLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const insertCustomer = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }).setIfNotSet({
            birthday: new Date('2000-03-01')
        }).returningLastInsertedId()
        .executeInsert()
    
    assertEquals(insertCustomer, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values ($1, $2, $3) returning id`)
    expectedParams.push(`["John","Smith",23]`)
    expectedType.push(`insertReturningLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const customerToInsert = {
        customerFirstName: 'John',
        customerLastName: 'Smith'
    }

    let currentCompanyId = 23

    const insertCustomer2 = await connection.insertInto(tCustomer)
        .shapedAs({
            customerFirstName: 'firstName',
            customerLastName: 'lastName'
        }).set(customerToInsert)
        .extendShape({
            customerCompanyId: 'companyId'
        }).set({
            customerCompanyId: currentCompanyId
        }).returningLastInsertedId()
        .executeInsert()
    
    assertEquals(insertCustomer2, result)
    
    /* *** Preparation ************************************************************/

    result = [2, 3]
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values ($1, $2, $3), ($4, $5, $6) returning id`)
    expectedParams.push(`["John","Smith",1,"Other","Person",1]`)
    expectedType.push(`insertReturningMultipleLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const valuesToInsert = [
        {
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        },
        {
            firstName: 'Other',
            lastName: 'Person',
            companyId: 1
        }
    ]
    
    const insertMultipleCustomers = await connection.insertInto(tCustomer)
        .values(valuesToInsert)
        .returningLastInsertedId()
        .executeInsert();
    
    assertEquals(insertMultipleCustomers, result)
    
    /* *** Preparation ************************************************************/

    result = [2, 3]
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values ($1, $2, $3), ($4, $5, $6) returning id`)
    expectedParams.push(`["John","Smith",23,"Other","Person",23]`)
    expectedType.push(`insertReturningMultipleLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const customersToInsert = [
        {
            customerFirstName: 'John',
            customerLastName: 'Smith'
        },
        {
            customerFirstName: 'Other',
            customerLastName: 'Person'
        }
    ]
    currentCompanyId = 23
    
    const insertMultipleCustomers2 = await connection.insertInto(tCustomer)
        .shapedAs({
            customerFirstName: 'firstName',
            customerLastName: 'lastName'
        })
        .values(customersToInsert)
        .extendShape({
            customerCompanyId: 'companyId'
        }).setForAll({
            customerCompanyId: currentCompanyId
        }).returningLastInsertedId()
        .executeInsert()
    
    assertEquals(insertMultipleCustomers2, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id, birthday) values ($1, $2, $3, $4)`)
    expectedParams.push(`["John","Smith",1,"2000-03-01T00:00:00.000Z"]`)
    expectedType.push(`insert`)
    
    /* *** Example ****************************************************************/

    const valuesToInsert3 = [
        {
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }
    ]
    
    const insertMultipleCustomers3 = await connection.insertInto(tCustomer)
        .dynamicValues(valuesToInsert3)
        .setForAllIfHasNoValue({
            birthday: new Date('2000-03-01')
        })
        .executeInsert();
    
    assertEquals(insertMultipleCustomers3, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) select first_name as "firstName", last_name as "lastName", company_id as "companyId" from customer where company_id = $1`)
    expectedParams.push(`[1]`)
    expectedType.push(`insert`)
    
    /* *** Example ****************************************************************/

    const insertCustomersFromSelect = await connection.insertInto(tCustomer)
        .from(
            connection.selectFrom(tCustomer)
            .where(
                tCustomer.companyId.equals(1)
            )
            .select({
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                companyId: tCustomer.companyId
            })
        )
        .executeInsert();
    
    assertEquals(insertCustomersFromSelect, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update customer set first_name = $1, last_name = $2 where id = $3`)
    expectedParams.push(`["John","Smith",10]`)
    expectedType.push(`update`)
    
    /* *** Example ****************************************************************/

    let updateCustomer = await connection.update(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('2000-03-01')
        }).ignoreIfSet('birthday')
        .where(tCustomer.id.equals(10))
        .executeUpdate()
    
    assertEquals(updateCustomer, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update customer set first_name = $1, last_name = $2, company_id = $3 where id = $4`)
    expectedParams.push(`["John","Smith",23,10]`)
    expectedType.push(`update`)
    
    /* *** Example ****************************************************************/

    customerId = 10
    const customerData = {
        newFirstName: 'John',
        newLastName: 'Smith',
    }
    currentCompanyId = 23

    updateCustomer = await connection.update(tCustomer)
        .shapedAs({
            newFirstName: 'firstName',
            newLastName: 'lastName'
        }) // Only these properties are allowed
        .set(customerData)
        .extendShape({
            newCompanyId: 'companyId'
        }) // Exend the shape to allow use in next sets 
        .set({
            newCompanyId: currentCompanyId
        })
        .where(tCustomer.id.equals(customerId))
        .executeUpdate()
    
    assertEquals(updateCustomer, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`delete from customer where id = $1`)
    expectedParams.push(`[10]`)
    expectedType.push(`delete`)
    
    /* *** Example ****************************************************************/

    let deleteCustomer = await connection.deleteFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .executeDelete()
    
    assertEquals(deleteCustomer, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with customerCountPerCompany as (select company.id as companyId, company.name as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.name) select companyId as "acmeCompanyId", companyName as "acmeCompanyName", customerCount as "acmeCustomerCount" from customerCountPerCompany where companyName ilike ('%' || $1 || '%')`)
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompanyWith = connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        }).groupBy('companyId', 'companyName')
        .forUseInQueryAs('customerCountPerCompany')
    
    const customerCountPerAcmeCompanies = await connection.selectFrom(customerCountPerCompanyWith)
        .where(customerCountPerCompanyWith.companyName.containsInsensitive('ACME'))
        .select({
            acmeCompanyId: customerCountPerCompanyWith.companyId,
            acmeCompanyName: customerCountPerCompanyWith.companyName,
            acmeCustomerCount: customerCountPerCompanyWith.customerCount
        })
        .executeSelectMany()
    
    assertEquals(customerCountPerAcmeCompanies, result)
    
    /* *** Preparation ************************************************************/
    
    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into custom_company (name, is_big) values ($1, case when $2::bool then 'Y' else 'N' end) returning id`)
    expectedParams.push(`["My Big Company",true]`)
    expectedType.push(`insertReturningLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const insertCustomCompany = await connection.insertInto(tCustomCompany).set({
            name: 'My Big Company',
            isBig: true
        }).returningLastInsertedId()
        .executeInsert()
    
    assertEquals(insertCustomCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (is_big = 'Y') as "isBig" from custom_company where is_big = 'Y'`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const selectAllBigCompanies = await connection.selectFrom(tCustomCompany)
        .where(tCustomCompany.isBig)
        .select({
            id: tCustomCompany.id,
            name: tCustomCompany.name,
            isBig: tCustomCompany.isBig
        }).executeSelectMany()
    
    assertEquals(selectAllBigCompanies, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as "firstName", customer.last_name as "lastName", customer.birthday as birthday, company.name as "companyName" from customer inner join company on customer.company_id = company.id where (customer.first_name ilike ($1 || '%') or (customer.last_name ilike ($2 || '%') and customer.last_name like ('%' || $3))) and company.name = $4 order by lower("firstName"), lower("lastName") asc`)
    expectedParams.push(`["John","Smi","th","ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    type FilterType = DynamicCondition<{
        id: 'int',
        firstName: 'string',
        lastName: 'string',
        birthday: 'localDate',
        companyName: 'string'
    }>
    
    const filter: FilterType = {
        or: [
            { firstName: { startsWithInsensitive: 'John' } },
            { lastName: { startsWithInsensitiveIfValue: 'Smi', endsWith: 'th' } }
        ],
        companyName: {equals: 'ACME'}
    }
    
    const selectFields = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyName: tCompany.name
    }
    
    const dynamicWhere = connection.dynamicConditionFor(selectFields).withValues(filter)
    
    const customersWithDynamicCondition = await connection.selectFrom(tCustomer)
        .innerJoin(tCompany).on(tCustomer.companyId.equals(tCompany.id))
        .where(dynamicWhere)
        .select(selectFields)
        .orderBy('firstName', 'insensitive')
        .orderBy('lastName', 'asc insensitive')
        .executeSelectMany()
    
    assertEquals(customersWithDynamicCondition, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as "name.firstName", customer.last_name as "name.lastName", customer.birthday as birthday, company.id as "company.id", company.name as "company.name" from customer inner join company on customer.company_id = company.id where (customer.first_name ilike ($1 || '%') or (customer.last_name ilike ($2 || '%') and customer.last_name like ('%' || $3))) and company.name = $4 order by lower("name.firstName"), lower("name.lastName") asc`)
    expectedParams.push(`["John","Smi","th","ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    type FilterType2 = DynamicCondition<{
        id: 'int',
        name: {
            firstName: 'string',
            lastName: 'string',
        }
        birthday: 'localDate',
        company: {
            id: 'int'
            name: 'string'
        }
    }>

    const filter2: FilterType2 = {
        or: [
            { name: { firstName: { startsWithInsensitive: 'John' } } },
            { name: { lastName: { startsWithInsensitiveIfValue: 'Smi', endsWith: 'th' } } }
        ],
        company: {
            name: { equals: 'ACME' }
        }
    }
    
    const selectFields2 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday,
        company: {
            id: tCompany.id,
            name: tCompany.name
        }
    }
    
    const dynamicWhere2 = connection.dynamicConditionFor(selectFields2).withValues(filter2)
    
    const customersWithDynamicCondition2 = await connection.selectFrom(tCustomer)
        .innerJoin(tCompany).on(tCustomer.companyId.equals(tCompany.id))
        .where(dynamicWhere2)
        .select(selectFields2)
        .orderBy('name.firstName', 'insensitive')
        .orderBy('name.lastName', 'asc insensitive')
        .executeSelectMany()
    
    assertEquals(customersWithDynamicCondition2, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || $1 || last_name as name, $2 as type from customer union all select id as id, name as name, $3 as type from company`)
    expectedParams.push(`[" ","customer","company"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const allDataWithName = await connection.selectFrom(tCustomer)
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            type: connection.const<'customer' | 'company'>('customer', 'enum', 'customerOrCompany')
        }).unionAll(
            connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name,
                type: connection.const<'customer' | 'company'>('company', 'enum', 'customerOrCompany')
            })
        ).executeSelectMany()
    
    assertEquals(allDataWithName, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        'company.id': 10,
        'company.name': 'ACME Inc.'
    })
    expectedQuery.push(`select customer.id as id, customer.first_name as "firstName", customer.last_name as "lastName", customer.birthday as birthday, company.id as "company.id", company.name as "company.name" from customer inner join company on company.id = customer.company_id where customer.id = $1`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customerWithCompanyInOneQuery2 = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                birthday: tCustomer.birthday,
                company: {
                    id: tCompany.id,
                    name: tCompany.name
                }
            }).where(
                tCustomer.id .equals(12)
            ).executeSelectOne()

    assertEquals(customerWithCompanyInOneQuery2, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        name: {
            firstName: 'John',
            lastName: 'Smith',
        },
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        'name.firstName': 'John',
        'name.lastName': 'Smith',
        birthday: new Date('1990/1/14'),
        'company.id': 10,
        'company.name': 'ACME Inc.'
    })
    expectedQuery.push(`select customer.id as id, customer.first_name as "name.firstName", customer.last_name as "name.lastName", customer.birthday as birthday, company.id as "company.id", company.name as "company.name" from customer inner join company on company.id = customer.company_id where company.name = $1 and (customer.first_name ilike ('%' || $2 || '%') or customer.last_name ilike ('%' || $3 || '%')) order by lower("company.name") asc, birthday desc`)
    expectedParams.push(`["ACME","John","Smi"]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    type QueryFilterType2 = DynamicCondition<{
        id: 'int',
        name: {
            firstName: 'string',
            lastName: 'string',
        },
        birthday: 'localDate',
        company: {
            id: 'int',
            name: 'string'
        }
    }>
    
    const queryFilter2: QueryFilterType2 = {
        company: { name: {equals: 'ACME'} },
        name: {
            or: [
                { firstName: { containsInsensitive: 'John' } },
                { lastName: { containsInsensitive: 'Smi' } }
            ]
        }
    }
    
    const queryOrderBy2 = 'company.name asc insensitive, birthday desc'
    
    const querySelectFields2 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday,
        company: {
            id: tCompany.id,
            name: tCompany.name
        }
    }
    
    const queryDynamicWhere2 = connection.dynamicConditionFor(querySelectFields2).withValues(queryFilter2)
    
    const customerWithCompanyObject2 = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select(querySelectFields2)
            .where(queryDynamicWhere2)
            .orderByFromString(queryOrderBy2)
            .executeSelectOne()
    
    assertEquals(customerWithCompanyObject2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = $1 union select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.parentId = company.id) select id as id, name as name, parentId as "parentId" from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const recursiveParentCompany = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(10))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        }).recursiveUnion((child) => {
            return connection.selectFrom(tCompany)
            .join(child).on(child.parentId.equals(tCompany.id))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                parentId: tCompany.parentId
            })
        }).executeSelectMany()
    
    assertEquals(recursiveParentCompany, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = $1 union select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.parentId = company.id) select id as id, name as name, parentId as "parentId" from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const recursiveOnParentCompany = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(10))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        }).recursiveUnionOn((child) => {
            return child.parentId.equals(tCompany.id)
        }).executeSelectMany()
    
    assertEquals(recursiveOnParentCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = $1 union all select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.id = company.parent_id) select id as id, name as name, parentId as "parentId" from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const recursiveChildrenCompany = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(10))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        }).recursiveUnionAll((parent) => {
            return connection.selectFrom(tCompany)
            .join(parent).on(parent.id.equals(tCompany.parentId))
            .select({
                id: tCompany.id,
                name: tCompany.name,
                parentId: tCompany.parentId
            })
        }).executeSelectMany()
    
    assertEquals(recursiveChildrenCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = $1 union all select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.id = company.parent_id) select id as id, name as name, parentId as "parentId" from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const recursiveOnChildrenCompany = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(10))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        }).recursiveUnionAllOn((parent) => {
            return parent.id.equals(tCompany.parentId)
        }).executeSelectMany()
    
    assertEquals(recursiveOnChildrenCompany, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        'parent.id': 18,
        'parent.name': 'name'
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as "parent.id", parent.name as "parent.name" from company left join company as parent on company.parent_id = parent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parent = tCompany.forUseInLeftJoinAs('parent')
    
    const leftJoinCompany2 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parent: {
                id: parent.id,
                name: parent.name
            }
        }).executeSelectMany()
    
    assertEquals(leftJoinCompany2, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName" from customer`)
    expectedParams.push(`[]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const availableFields = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday
    }
    
    const fieldsToPick = {
        firstName: true,
        lastName: true
    }
    
    // include allways id field as required
    const pickedFields = dynamicPick(availableFields, fieldsToPick, ['id'])
    
    const customerWithIdPeaking = await connection.selectFrom(tCustomer)
        .select(pickedFields)
        .executeSelectOne()
    
    assertEquals(customerWithIdPeaking, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName" from customer where id = $1`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields2 = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyId: tCompany.id,
        companyName: tCompany.name
    }
    
    const fieldsToPick2 = {
        firstName: true,
        lastName: true
    }
    
    // include allways id field as required
    const pickedFields2 = dynamicPick(availableFields2, fieldsToPick2, ['id'])
    
    const customerWithOptionalCompany = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields2)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as "firstName", customer.last_name as "lastName", company.name as "companyName" from customer inner join company on company.id = customer.company_id where customer.id = $1`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields3 = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyId: tCompany.id,
        companyName: tCompany.name
    }
    
    const fieldsToPick3 = {
        firstName: true,
        lastName: true,
        companyName: true
    }
    
    // include allways id field as required
    const pickedFields3 = dynamicPick(availableFields3, fieldsToPick3, ['id'])
    
    const customerWithOptionalCompany3 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields3)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany3, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: {
            firstName: 'First Name',
            lastName: 'Last Name'
        }
    }
    expectedResult.push({
        id: 1,
        'name.firstName': 'First Name',
        'name.lastName': 'Last Name'
    })
    expectedQuery.push(`select id as id, first_name as "name.firstName", last_name as "name.lastName" from customer`)
    expectedParams.push(`[]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const availableFields4 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday
    }
    
    const fieldsToPick4 = {
        name: {
            firstName: true,
            lastName: true
        }
    }
    
    // include allways id field as required
    const pickedFields4 = dynamicPick(availableFields4, fieldsToPick4, ['id'])
    
    const customerWithIdPeaking4 = await connection.selectFrom(tCustomer)
        .select(pickedFields4)
        .executeSelectOne()
    
    assertEquals(customerWithIdPeaking4, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "name.firstName", last_name as "name.lastName" from customer where id = $1`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields5 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday,
        company: {
            id: tCompany.id,
            name: tCompany.name
        }
    }
    
    const fieldsToPick5 = {
        name: {
            firstName: true,
            lastName: true
        }
    }
    
    // include allways id field as required
    const pickedFields5 = dynamicPick(availableFields5, fieldsToPick5, ['id'])
    
    const customerWithOptionalCompany5 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields5)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany5, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as "name.firstName", customer.last_name as "name.lastName", company.name as "company.name" from customer inner join company on company.id = customer.company_id where customer.id = $1`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields6 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday,
        company: {
            id: tCompany.id,
            name: tCompany.name
        }
    }
    
    const fieldsToPick6 = {
        name: {
            firstName: true,
            lastName: true,
        },
        company: {
            name: true
        }
    }
    
    // include allways id field as required
    const pickedFields6 = dynamicPick(availableFields6, fieldsToPick6, ['id'])
    
    const customerWithOptionalCompany6 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields6)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany6, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer for system_time between $1 and $2  where id = $3`)
    expectedParams.push(`["2019-01-01T00:00:00.000Z","2020-01-01T00:00:00.000Z",10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerIn2019 = connection.forSystemTimeBetween(tCustomer, 'customerIn2019', new Date('2019-01-01'), new Date('2020-01-01'))
    
    const customerInSystemTime = await connection.selectFrom(customerIn2019)
        .where(customerIn2019.id.equals(10))
        .select({
            id: customerIn2019.id,
            firstName: customerIn2019.firstName,
            lastName: customerIn2019.lastName,
            birthday: customerIn2019.birthday
        })
        .executeSelectMany()
    
    assertEquals(customerInSystemTime, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1 for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    let customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1 order by my_column, my_id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            beforeOrderByItems: connection.rawFragment`my_column`,
            afterOrderByItems: connection.rawFragment`my_id`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1 order by my_column for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            beforeOrderByItems: connection.rawFragment`my_column`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1 order by my_id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            afterOrderByItems: connection.rawFragment`my_id`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1 order by id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .orderBy('id')
        .customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1 order by my_column, id, my_id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .orderBy('id')
        .customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            beforeOrderByItems: connection.rawFragment`my_column`,
            afterOrderByItems: connection.rawFragment`my_id`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1 order by my_column, id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .orderBy('id')
        .customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            beforeOrderByItems: connection.rawFragment`my_column`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`BEFORE select /*+ some hints */ id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1 order by id, my_id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .orderBy('id')
        .customizeQuery({
            beforeQuery: connection.rawFragment`BEFORE`,
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            afterOrderByItems: connection.rawFragment`my_id`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`BEFORE update /*+ some hints */ customer set first_name = $1, last_name = $2 where id = $3 keep plan`)
    expectedParams.push(`["John","Smith",10]`)
    expectedType.push(`update`)
    
    /* *** Example ****************************************************************/

    const customizedUpdate = await connection.update(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith'
        }).where(tCustomer.id.equals(10))
        .customizeQuery({
            beforeQuery: connection.rawFragment`BEFORE`,
            afterUpdateKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`keep plan`,
        })
        .executeUpdate()
    
    assertEquals(customizedUpdate, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`BEFORE delete /*+ some hints */ from customer where id = $1 keep plan`)
    expectedParams.push(`[10]`)
    expectedType.push(`delete`)
    
    /* *** Example ****************************************************************/

    const customizedDelete = await connection.deleteFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .customizeQuery({
            beforeQuery: connection.rawFragment`BEFORE`,
            afterDeleteKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`keep plan`,
        })
        .executeDelete()
    
    assertEquals(customizedDelete, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`BEFORE insert /*+ some hints */ into customer (first_name, last_name, company_id) values ($1, $2, $3) log errors reject limit unlimited`)
    expectedParams.push(`["John","Smith",1]`)
    expectedType.push(`insert`)
    
    /* *** Example ****************************************************************/

    const customizedInsert = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }).customizeQuery({
            beforeQuery: connection.rawFragment`BEFORE`,
            afterInsertKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`log errors reject limit unlimited`
        }).executeInsert()

    assertEquals(customizedInsert, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 9,
        firstName: 'First Name',
        lastName: 'Last Name',
        companyId: 7
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName", birthday as birthday, company_id as "companyId" from customer where id = $1`)
    expectedParams.push(`[9]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const selectAll = await connection.selectFrom(tCustomer)
        .select(extractWritableColumnsFrom(tCustomer))
        .where(tCustomer.id.equals(9))
        .executeSelectOne()
    
    assertEquals(selectAll, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 9,
        firstName: 'First Name',
        lastName: 'Last Name',
        name: 'First Name Last Name',
        companyId: 7
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName", birthday as birthday, company_id as "companyId", first_name || $1 || last_name as name, calculateAge(birthday) as age from customer where id = $2`)
    expectedParams.push(`[" ",9]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const selectAll2 = await connection.selectFrom(tCustomer)
        .select(extractColumnsFrom(tCustomer))
        .where(tCustomer.id.equals(9))
        .executeSelectOne()
    
    assertEquals(selectAll2, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name',
            parentId: 8
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        'parent.id': 18,
        'parent.name': 'name',
        'parent.parentId': 8
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as "parent.id", parent.name as "parent.name", parent.parent_id as "parent.parentId" from company left join company as parent on company.parent_id = parent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parentCompany = tCompany.forUseInLeftJoinAs('parent')

    const companyPrefixed4 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parent: {
                id: parentCompany.id,
                name: parentCompany.name,
                parentId: parentCompany.parentId
            }
        }).executeSelectMany()
    
    assertEquals(companyPrefixed4, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }, {
        id: 20,
        name: 'name3',
        parent: {
            id: 19,
            name: 'name2',
            parent: {
                id: 18,
                name: 'name',
                parentId: 17
            }
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        'parent.id': 18,
        'parent.name': 'name'
    }, {
        id: 20,
        name: 'name3',
        'parent.id': 19,
        'parent.name': 'name2',
        'parent.parent.id': 18,
        'parent.parent.name': 'name',
        'parent.parent.parentId': 17
    }])
    expectedQuery.push(`select company.id as id, company.name as name, parent.id as "parent.id", parent.name as "parent.name", parentParent.id as "parent.parent.id", parentParent.name as "parent.parent.name", parentParent.parent_id as "parent.parent.parentId" from company left join company as parent on company.parent_id = parent.id left join company as parentParent on parent.parent_id = parentParent.id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parentParent = tCompany.forUseInLeftJoinAs('parentParent')
    
    const companyMultiSplit2 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .leftJoin(parentParent).on(parent.parentId.equals(parentParent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parent: {
                id: parent.id,
                name: parent.name,
                parent: {
                    id: parentParent.id,
                    name: parentParent.name,
                    parentId: parentParent.parentId,
                }
            }
        })
        .executeSelectMany()

    assertEquals(companyMultiSplit2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || $1 || last_name as name from customer where company_id = (select id as result from company where name = $2)`)
    expectedParams.push(`[" ","ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const acmeId = connection.selectFrom(tCompany)
        .where(tCompany.name.equals('ACME'))
        .selectOneColumn(tCompany.id)
        .forUseAsInlineQueryValue()

    const acmeCustomers = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.equals(acmeId))
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName)
        })
        .executeSelectMany()

    assertEquals(acmeCustomers, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 10,
        name: 'ACME'
    }
    expectedResult.push(result)
    expectedQuery.push(`delete from company where name = $1 returning id as id, name as name`)
    expectedParams.push(`["ACME"]`)
    expectedType.push(`deleteReturningOneRow`)
    
    /* *** Example ****************************************************************/

    const deletedAcmeCompany = await connection.deleteFrom(tCompany)
        .where(tCompany.name.equals('ACME'))
        .returning({
            id: tCompany.id,
            name: tCompany.name
        })
        .executeDeleteOne()

    assertEquals(deletedAcmeCompany, result)

    /* *** Preparation ************************************************************/

    result = 'Ron'
    expectedResult.push(result)
    expectedQuery.push(`update customer set first_name = $1 where id = $2 returning first_name as result`)
    expectedParams.push(`["Ron",1]`)
    expectedType.push(`updateReturningOneColumnOneRow`)

    /* *** Example ****************************************************************/

    const updatedSmithFirstName = await connection.update(tCustomer)
        .set({
            firstName: 'Ron'
        })
        .where(tCustomer.id.equals(1))
        .returningOneColumn(tCustomer.firstName)
        .executeUpdateOne()

    assertEquals(updatedSmithFirstName, result)

    /* *** Preparation ************************************************************/

    result = {
        oldLastName: 'Shith', 
        newLastName: 'Thomson'
    }
    expectedResult.push(result)
    expectedQuery.push(`update customer as _new_ set last_name = $1 from (select _old_.* from customer as _old_ where _old_.id = $2 for no key update of _old_) as _old_ where _new_.id = _old_.id returning _old_.last_name as "oldLastName", _new_.last_name as "newLastName"`)
    expectedParams.push(`["Thomson",2]`)
    expectedType.push(`updateReturningOneRow`)

    /* *** Example ****************************************************************/

    const oldCustomerValues = tCustomer.oldValues()
    const updatedLastNames = await connection.update(tCustomer)
        .set({
            lastName: 'Thomson'
        })
        .where(tCustomer.id.equals(2))
        .returning({
            oldLastName: oldCustomerValues.lastName,
            newLastName: tCustomer.lastName
        })
        .executeUpdateOne()
    
    assertEquals(updatedLastNames, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'John',
        lastName: 'Smith',
    }
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values ($1, $2, $3) returning id as id, first_name as "firstName", last_name as "lastName"`)
    expectedParams.push(`["John","Smith",1]`)
    expectedType.push(`insertReturningOneRow`)

    /* *** Example ****************************************************************/

    const insertReturningCustomerData = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }).returning({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .executeInsertOne()

    assertEquals(insertReturningCustomerData, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'John',
        lastName: 'Smith',
    }
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values ($1, $2, $3) on conflict do nothing returning id as id, first_name as "firstName", last_name as "lastName"`)
    expectedParams.push(`["John","Smith",1]`)
    expectedType.push(`insertReturningOneRow`)

    /* *** Example ****************************************************************/

    const insertReturningCustomerData2 = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        })
        .onConflictDoNothing()
        .returning({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .executeInsertNoneOrOne()

    assertEquals(insertReturningCustomerData2, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'John',
        lastName: 'Smith',
    }
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values ($1, $2, $3) on conflict do update set company_id = $4 returning id as id, first_name as "firstName", last_name as "lastName"`)
    expectedParams.push(`["John","Smith",1,1]`)
    expectedType.push(`insertReturningOneRow`)

    /* *** Example ****************************************************************/

    const insertReturningCustomerData3 = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        })
        .onConflictDoUpdateSet({
            companyId: 1
        })
        .returning({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .executeInsertOne()

    assertEquals(insertReturningCustomerData3, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update customer set last_name = customer.last_name || $1 || company.name from company where customer.company_id = company.id and company.name ilike ('%' || $2 || '%')`)
    expectedParams.push(`[" - ","ACME"]`)
    expectedType.push(`update`)

    /* *** Example ****************************************************************/

    const addACMECompanyNameToLastName = await connection.update(tCustomer)
        .from(tCompany)
        .set({
            lastName: tCustomer.lastName.concat(' - ').concat(tCompany.name)
        })
        .where(tCustomer.companyId.equals(tCompany.id))
        .and(tCompany.name.containsInsensitive('ACME'))
        .executeUpdate()

    assertEquals(addACMECompanyNameToLastName, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`delete from customer using company where customer.company_id = company.id and company.name ilike ('%' || $1 || '%')`)
    expectedParams.push(`["ACME"]`)
    expectedType.push(`delete`)

    /* *** Example ****************************************************************/

    const deleteACMECustomers = await connection.deleteFrom(tCustomer)
        .using(tCompany)
        .where(tCustomer.companyId.equals(tCompany.id))
        .and(tCompany.name.containsInsensitive('ACME'))
        .executeDelete()

    assertEquals(deleteACMECustomers, result)

    /* *** Preparation ************************************************************/

    result = {
        oldLastName: 'Smith 2', 
        newLastName: 'Smith'
    }
    expectedResult.push(result)
    expectedQuery.push(`update customer as _new_ set last_name = $1 from (select _old_.* from customer as _old_, company where _old_.company_id = company.id and company.name = $2 and _old_.first_name = $3 for no key update of _old_) as _old_ where _new_.id = _old_.id returning _old_.last_name as "oldLastName", _new_.last_name as "newLastName"`)
    expectedParams.push(`["Smith","ACME Cia.","Ron 2"]`)
    expectedType.push(`updateReturningOneRow`)

    /* *** Example ****************************************************************/

    const smithLastNameUpdate = await connection.update(tCustomer)
        .from(tCompany)
        .set({
            lastName: 'Smith'
        })
        .where(tCustomer.companyId.equals(tCompany.id))
        .and(tCompany.name.equals('ACME Cia.'))
        .and(tCustomer.firstName.equals('Ron 2'))
        .returning({
            oldLastName: oldCustomerValues.lastName,
            newLastName: tCustomer.lastName
        })
        .executeUpdateOne()

    assertEquals(smithLastNameUpdate, result)

    /* *** Preparation ************************************************************/

    result = {
        oldLastName: 'Smith', 
        newLastName: 'Smith - ACME Cia.'
    }
    expectedResult.push(result)
    expectedQuery.push(`update customer as _new_ set last_name = _new_.last_name || $1 || _old_.company__name from (select _old_.*, company.name as company__name from customer as _old_, company where _old_.company_id = company.id and company.name = $2 and _old_.first_name = $3 for no key update of _old_) as _old_ where _new_.id = _old_.id returning _old_.last_name as "oldLastName", _new_.last_name as "newLastName"`)
    expectedParams.push(`[" - ","ACME Cia.","Ron 2"]`)
    expectedType.push(`updateReturningOneRow`)

    /* *** Example ****************************************************************/

    const smithLastNameUpdate2 = await connection.update(tCustomer)
        .from(tCompany)
        .set({
            lastName: tCustomer.lastName.concat(' - ').concat(tCompany.name)
        })
        .where(tCustomer.companyId.equals(tCompany.id))
        .and(tCompany.name.equals('ACME Cia.'))
        .and(tCustomer.firstName.equals('Ron 2'))
        .returning({
            oldLastName: oldCustomerValues.lastName,
            newLastName: tCustomer.lastName
        })
        .executeUpdateOne()

    assertEquals(smithLastNameUpdate2, result)

    /* *** Preparation ************************************************************/

    result = {
        oldLastName: 'Smith - ACME Cia.', 
        newLastName: 'Smith/ACME Cia.'
    }
    expectedResult.push(result)
    expectedQuery.push(`update customer as _new_ set last_name = $1 from (select _old_.*, company.name as company__name from customer as _old_, company where _old_.company_id = company.id and company.name = $2 and _old_.first_name = $3 for no key update of _old_) as _old_ where _new_.id = _old_.id returning _old_.last_name as "oldLastName", _new_.last_name || $4 || _old_.company__name as "newLastName"`)
    expectedParams.push(`["Smith","ACME Cia.","Ron 2","/"]`)
    expectedType.push(`updateReturningOneRow`)

    /* *** Example ****************************************************************/

    const smithLastNameUpdate3 = await connection.update(tCustomer)
        .from(tCompany)
        .set({
            lastName: 'Smith'
        })
        .where(tCustomer.companyId.equals(tCompany.id))
        .and(tCompany.name.equals('ACME Cia.'))
        .and(tCustomer.firstName.equals('Ron 2'))
        .returning({
            oldLastName: oldCustomerValues.lastName,
            newLastName: tCustomer.lastName.concat('/').concat(tCompany.name)
        })
        .executeUpdateOne()

    assertEquals(smithLastNameUpdate3, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_agg(json_build_object('id', id, 'firstName', first_name, 'lastName', last_name)) as result from customer where company_id = company.id) as customers from company where id = $1`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(connection.aggregateAsArray({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        }))
        .forUseAsInlineQueryValue()

    const acmeCompanyWithCustomers = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme
        })
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select company.id as id, company.name as name, json_agg(json_build_object('id', customer.id, 'firstName', customer.first_name, 'lastName', customer.last_name)) as customers from company left join customer on customer.company_id = company.id where company.id = $1 group by company.id`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const tCustomerLeftJoin = tCustomer.forUseInLeftJoin()
    const acmeCompanyWithCustomers2 = await connection.selectFrom(tCompany).leftJoin(tCustomerLeftJoin).on(tCustomerLeftJoin.companyId.equals(tCompany.id))
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: connection.aggregateAsArray({
                id: tCustomerLeftJoin.id,
                firstName: tCustomerLeftJoin.firstName,
                lastName: tCustomerLeftJoin.lastName
            }).asOptionalNonEmptyArray()
        })
        .groupBy('id')
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers2, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_agg(first_name || $1 || last_name) as result from customer where company_id = company.id) as customers from company where id = $2`)
    expectedParams.push(`[" ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme3 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(connection.aggregateAsArrayOfOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName)))
        .forUseAsInlineQueryValue()

    const acmeCompanyWithCustomers3 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme3.useEmptyArrayForNoValue()
        })
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers3, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select company.id as id, company.name as name, json_agg(customer.first_name || $1 || customer.last_name) as customers from company left join customer on customer.company_id = company.id where company.id = $2 group by company.id`)
    expectedParams.push(`[" ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    // const tCustomerLeftJoin = tCustomer.forUseInLeftJoin()
    const acmeCompanyWithCustomers3_1 = await connection.selectFrom(tCompany).leftJoin(tCustomerLeftJoin).on(tCustomerLeftJoin.companyId.equals(tCompany.id))
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: connection.aggregateAsArrayOfOneColumn(tCustomerLeftJoin.firstName.concat(' ').concat(tCustomerLeftJoin.lastName))
        })
        .groupBy('id')
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers3_1, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as "customerId", first_name as "customerFirstName", last_name as "customerLastName" from customer where company_id in (with inner2 as (select id as id, name as name from custom_company where id = customer.company_id) select inner2.id as result from company inner join inner2 on company.id = inner2.id where company.name like ('%' || $1 || '%'))`)
    expectedParams.push(`["Cia."]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const inner2 = connection.subSelectUsing(tCustomer).from(tCustomCompany).where(tCustomCompany.id.equals(tCustomer.companyId)).select({id: tCustomCompany.id, name: tCustomCompany.name}).forUseInQueryAs('inner2')
    
    const customerWithSelectedCompanies2 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.in(
            connection.selectFrom(tCompany).innerJoin(inner2).on(tCompany.id.equals(inner2.id))
                .where(tCompany.name.contains('Cia.'))
                .selectOneColumn(inner2.id)
        )).select({
            customerId: tCustomer.id,
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        })
        .executeSelectMany()
    
    assertEquals(customerWithSelectedCompanies2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with inner3 as (select id as id, name as name from custom_company) select id as "customerId", first_name as "customerFirstName", last_name as "customerLastName" from customer where company_id in (select inner3.id as result from company inner join inner3 on company.id = inner3.id where company.name like ('%' || $1 || '%'))`)
    expectedParams.push(`["Cia."]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const inner3 = connection.selectFrom(tCustomCompany).select({id: tCustomCompany.id, name: tCustomCompany.name}).forUseInQueryAs('inner3')
    
    const customerWithSelectedCompanies3 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.in(
            connection.selectFrom(tCompany).innerJoin(inner3).on(tCompany.id.equals(inner3.id))
                .where(tCompany.name.contains('Cia.'))
                .selectOneColumn(inner3.id)
        )).select({
            customerId: tCustomer.id,
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        })
        .executeSelectMany()
    
    assertEquals(customerWithSelectedCompanies3, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with innerInner4 as (select id as id, name as name from custom_company), inner4 as (select id as id, name as name from innerInner4) select id as "customerId", first_name as "customerFirstName", last_name as "customerLastName" from customer where company_id in (select inner4.id as result from company inner join inner4 on company.id = inner4.id where company.name like ('%' || $1 || '%'))`)
    expectedParams.push(`["Cia."]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const innerInner4 = connection.selectFrom(tCustomCompany).select({id: tCustomCompany.id, name: tCustomCompany.name}).forUseInQueryAs('innerInner4')
    const inner4 = connection.selectFrom(innerInner4).select({id: innerInner4.id, name: innerInner4.name}).forUseInQueryAs('inner4')
    
    const customerWithSelectedCompanies4 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.in(
            connection.selectFrom(tCompany).innerJoin(inner4).on(tCompany.id.equals(inner4.id))
                .where(tCompany.name.contains('Cia.'))
                .selectOneColumn(inner4.id)
        )).select({
            customerId: tCustomer.id,
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        })
        .executeSelectMany()
    
    assertEquals(customerWithSelectedCompanies4, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_agg(json_build_object('id', id, 'firstName', first_name, 'lastName', last_name)) from customer where company_id = company.id) as customers from company where id = $1`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme4 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers4 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme4
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers4, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_agg(json_build_object('id', a_1_.id, 'firstName', a_1_.firstName, 'lastName', a_1_.lastName)) from (select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id order by id) as a_1_) as customers from company where id = $1`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme5 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .orderBy('id')
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers5 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme5
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers5, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_agg(first_name || $1 || last_name) from customer where company_id = company.id) as customers from company where id = $2`)
    expectedParams.push(`[" ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme6 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers6 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme6.useEmptyArrayForNoValue()
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers6, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_agg(a_1_.result) from (select first_name || $1 || last_name as result from customer where company_id = company.id order by result) as a_1_) as customers from company where id = $2`)
    expectedParams.push(`[" ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme7 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        .orderBy('result')
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers7 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme7.useEmptyArrayForNoValue()
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers7, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_agg(json_build_object('id', a_1_.id, 'firstName', a_1_.firstName, 'lastName', a_1_.lastName)) from (select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id union select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id) as a_1_) as customers from company where id = $1`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme8 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        }).union(
            connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            })
        )
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers8 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme8
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers8, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_agg(json_build_object('id', a_1_.id, 'firstName', a_1_.firstName, 'lastName', a_1_.lastName)) from (select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id union select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id order by id) as a_1_) as customers from company where id = $1`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme9 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        }).union(
            connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            })
        ).orderBy('id')
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers9 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme9
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers9, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_agg(a_1_.result) from (select first_name || $1 || last_name as result from customer where company_id = company.id union select first_name || $2 || last_name as result from customer where company_id = company.id) as a_1_) as customers from company where id = $3`)
    expectedParams.push(`[" "," ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme10 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        .union(
            connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        )
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers10 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme10.useEmptyArrayForNoValue()
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers10, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select json_agg(a_1_.result) from (select first_name || $1 || last_name as result from customer where company_id = company.id union select first_name || $2 || last_name as result from customer where company_id = company.id order by result) as a_1_) as customers from company where id = $3`)
    expectedParams.push(`[" "," ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme11 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        .union(
            connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        ).orderBy('result')
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers11 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme11.useEmptyArrayForNoValue()
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers11, result)

    /* *** Preparation ************************************************************/

    result = { 
        id: 10, 
        name: 'Low Company', 
        parentId: 9, 
        parents: [
            { id: 9, name: 'Mic Company', parentId: 8 }, 
            { id: 8, name: 'Top Company' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, parent_id as "parentId", (with recursive recursive_select_1 as (select parentCompany.id as id, parentCompany.name as name, parentCompany.parent_id as parentId from company as parentCompany where parentCompany.id = company.parent_id union all select parentCompany.id as id, parentCompany.name as name, parentCompany.parent_id as parentId from company as parentCompany join recursive_select_1 on recursive_select_1.parentId = parentCompany.id) select json_agg(json_build_object('id', id, 'name', name, 'parentId', parentId)) from recursive_select_1) as parents from company where id = $1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const parentCompany2 = tCompany.as('parentCompany')

    const parentCompanies = connection.subSelectUsing(tCompany)
        .from(parentCompany2)
        .select({
            id: parentCompany2.id,
            name: parentCompany2.name,
            parentId: parentCompany2.parentId
        })
        .where(parentCompany2.id.equals(tCompany.parentId))
        .recursiveUnionAllOn((child) => {
            return child.parentId.equals(parentCompany2.id)
        })
        .forUseAsInlineAggregatedArrayValue()

    const lowCompany = await connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId,
            parents: parentCompanies
        })
        .where(tCompany.id.equals(10))
        .executeSelectOne()
    
    assertEquals(lowCompany, result)

    /* *** Preparation ************************************************************/

    result = { 
        id: 10, 
        name: 'Low Company', 
        parentId: 9, 
        parents: [
            { id: 9, name: 'Mic Company', parentId: 8 }, 
            { id: 8, name: 'Top Company' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select parentCompany.id as id, parentCompany.name as name, parentCompany.parent_id as parentId from company as parentCompany where parentCompany.id = $1 union all select parentCompany.id as id, parentCompany.name as name, parentCompany.parent_id as parentId from company as parentCompany join recursive_select_1 on recursive_select_1.parentId = parentCompany.id) select id as id, name as name, parent_id as "parentId", (select json_agg(json_build_object('id', id, 'name', name, 'parentId', parentId)) from recursive_select_1) as parents from company where id = $2`)
    expectedParams.push(`[9,10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const parentCompanies2 = connection.selectFrom(parentCompany2)
        .select({
            id: parentCompany2.id,
            name: parentCompany2.name,
            parentId: parentCompany2.parentId
        })
        .where(parentCompany2.id.equals(9))
        .recursiveUnionAllOn((child) => {
            return child.parentId.equals(parentCompany2.id)
        })
        .forUseAsInlineAggregatedArrayValue()

    const lowCompany2 = await connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId,
            parents: parentCompanies2
        })
        .where(tCompany.id.equals(10))
        .executeSelectOne()
    
    assertEquals(lowCompany2, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2)`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    let insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        }).executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = { id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, title as title from record where id::text like ('%' || $1 || '%')`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const selectUuid = await connection.selectFrom(tRecord)
        .select({
            id: tRecord.id,
            title: tRecord.title
        })
        .where(tRecord.id.asString().contains('7002'))
        .executeSelectOne()

    assertEquals(selectUuid, result)

    /* *** Preparation ************************************************************/

    result = { id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }
    expectedResult.push(result)
    expectedQuery.push(`with with_uuit as (select id as id, title as title from record) select id as id, title as title from with_uuit where id::text like ('%' || $1 || '%')`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const withSselectUuid = await connection.selectFrom(tRecord)
        .select({
            id: tRecord.id,
            title: tRecord.title
        })
        .forUseInQueryAs('with_uuit');

    const selectUuid2 = await connection.selectFrom(withSselectUuid)
        .select({
            id: withSselectUuid.id,
            title: withSselectUuid.title
        })
        .where(withSselectUuid.id.asString().contains('7002'))
        .executeSelectOne()

    assertEquals(selectUuid2, result)

    /* *** Preparation ************************************************************/

    result = { records: [{ id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }] }
    expectedResult.push(result)
    expectedQuery.push(`select (select json_agg(json_build_object('id', id, 'title', title)) from record where id::text like ('%' || $1 || '%')) as records`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedUuid = await connection.selectFrom(tRecord)
        .select({
            id: tRecord.id,
            title: tRecord.title
        })
        .where(tRecord.id.asString().contains('7002'))
        .forUseAsInlineAggregatedArrayValue()

    const selectUuid3 = await connection.selectFromNoTable()
        .select({
            records: aggregatedUuid,
        })
        .executeSelectOne()

    assertEquals(selectUuid3, result)

    /* *** Preparation ************************************************************/

    result = { records: [{ id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }] }
    expectedResult.push(result)
    expectedQuery.push(`select (select json_agg(json_build_object('id', a_1_.id, 'title', a_1_.title)) from (select id as id, title as title from record where id::text like ('%' || $1 || '%') order by id) as a_1_) as records`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedUuid2 = await connection.selectFrom(tRecord)
        .select({
            id: tRecord.id,
            title: tRecord.title
        })
        .where(tRecord.id.asString().contains('7002'))
        .orderBy('id')
        .forUseAsInlineAggregatedArrayValue()

    const selectUuid4 = await connection.selectFromNoTable()
        .select({
            records: aggregatedUuid2,
        })
        .executeSelectOne()

    assertEquals(selectUuid4, result)

    /* *** Preparation ************************************************************/

    result = { records: [{ id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }] }
    expectedResult.push(result)
    expectedQuery.push(`select json_agg(json_build_object('id', id, 'title', title)) as records from record where id::text like ('%' || $1 || '%')`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const selectUuid5 = await connection.selectFrom(tRecord)
        .select({
            records: connection.aggregateAsArray({
                id: tRecord.id,
                title: tRecord.title
            })
        })
        .where(tRecord.id.asString().contains('7002'))
        .executeSelectOne()

    assertEquals(selectUuid5, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict do nothing`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictDoNothing()
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict on constraint $3 do nothing`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","title_constraint"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOnConstraint('title_constraint')
        .doNothing()
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict (title) do nothing`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOn(tRecord.title)
        .doNothing()
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict (title) where title ilike ('%' || $3 || '%') do nothing`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","memo"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOn(tRecord.title)
        .where(tRecord.title.containsInsensitive('memo'))
        .doNothing()
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict do update set title = $3`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","My voice memo 2"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictDoUpdateSet({
            title: 'My voice memo 2'
        })
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict on constraint $3 do update set title = $4`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","title_constraint","My voice memo 2"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOnConstraint('title_constraint')
        .doUpdateSet({
            title: 'My voice memo 2'
        })
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict (title) do update set title = $3`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","My voice memo 2"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOn(tRecord.title)
        .doUpdateSet({
            title: 'My voice memo 2'
        })
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict (title) where title ilike ('%' || $3 || '%') do update set title = $4`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","memo","My voice memo 2"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOn(tRecord.title)
        .where(tRecord.title.containsInsensitive('memo'))
        .doUpdateSet({
            title: 'My voice memo 2'
        })
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict do update set title = $3 where record.title ilike ('%' || $4 || '%')`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","My voice memo 2","My"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictDoUpdateSet({
            title: 'My voice memo 2'
        })
        .where(tRecord.title.containsInsensitive('My'))
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict on constraint $3 do update set title = $4 where record.title ilike ('%' || $5 || '%')`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","title_constraint","My voice memo 2","My"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOnConstraint('title_constraint')
        .doUpdateSet({
            title: 'My voice memo 2'
        })
        .where(tRecord.title.containsInsensitive('My'))
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict (title) do update set title = $3 where record.title ilike ('%' || $4 || '%')`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","My voice memo 2","My"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOn(tRecord.title)
        .doUpdateSet({
            title: 'My voice memo 2'
        })
        .where(tRecord.title.containsInsensitive('My'))
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict (title) where title ilike ('%' || $3 || '%') do update set title = $4 where record.title ilike ('%' || $5 || '%')`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","memo","My voice memo 2","My"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictOn(tRecord.title)
        .where(tRecord.title.containsInsensitive('memo'))
        .doUpdateSet({
            title: 'My voice memo 2'
        })
        .where(tRecord.title.containsInsensitive('My'))
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values ($1, $2) on conflict do update set title = record.title || $3 || excluded.title`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo"," - "]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    const tRecordForInsert = tRecord.valuesForInsert()
    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictDoUpdateSet({
            title: tRecord.title.concat(' - ').concat(tRecordForInsert.title)
        })
        .executeInsert()
    assertEquals(insertUuid, result)/* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'John',
        lastName: 'Smith',
    }
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values ($1, $2, $3) on conflict do update set first_name = customer.first_name || $4 || excluded.first_name, last_name = customer.last_name || $5 || excluded.last_name returning id as id, first_name as "firstName", last_name as "lastName"`)
    expectedParams.push(`["John","Smith",1," - "," - "]`)
    expectedType.push(`insertReturningOneRow`)

    /* *** Example ****************************************************************/

    const tCustomerForInsert = tCustomer.valuesForInsert()
    const insertReturningCustomerData4 = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        })
        .onConflictDoUpdateSet({
            firstName: tCustomer.firstName.concat(' - ').concat(tCustomerForInsert.firstName),
            lastName: tCustomer.lastName.concat(' - ').concat(tCustomerForInsert.lastName)
        })
        .returning({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .executeInsertOne()

    assertEquals(insertReturningCustomerData4, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName", birthday as birthday, company_id as "companyId" from customer`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    let companyName: string | undefined = undefined

    let customers = await connection.selectFrom(tCustomer)
        .optionalJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .where(tCompany.name.equalsIfValue(companyName))
        .select(extractWritableColumnsFrom(tCustomer))
        .executeSelectMany()
    assertEquals(customers, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as "firstName", customer.last_name as "lastName", customer.birthday as birthday, customer.company_id as "companyId" from customer join company on company.id = customer.company_id where company.name = $1`)
    expectedParams.push(`["My company name"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    companyName = 'My company name'

    customers = await connection.selectFrom(tCustomer)
        .optionalJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .where(tCompany.name.equalsIfValue(companyName))
        .select(extractWritableColumnsFrom(tCustomer))
        .executeSelectMany()
    assertEquals(customers, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select company.name as result from customer join company on company.id = customer.company_id`)
    expectedParams.push(`[]`)
    expectedType.push(`selectOneColumnManyRows`)

    /* *** Example ****************************************************************/

    const companiesName = await connection.selectFrom(tCustomer)
        .optionalJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .selectOneColumn(tCompany.name)
        .executeSelectMany()
    assertEquals(companiesName, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select first_name as "firstName", last_name as "lastName", birthday as birthday from customer where company_id = $1`)
    expectedParams.push(`[16]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const userCompanyId = 16
    let onlyCustomersOfUserCompany = true

    let customers2 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.equals(userCompanyId).onlyWhen(onlyCustomersOfUserCompany))
        .select({
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .executeSelectMany()
    assertEquals(customers2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select first_name as "firstName", last_name as "lastName", birthday as birthday from customer`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    onlyCustomersOfUserCompany = false

    customers2 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.equals(userCompanyId).onlyWhen(onlyCustomersOfUserCompany))
        .select({
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .executeSelectMany()
    assertEquals(customers2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name || $1 || last_name as name, calculateAge(birthday) as age from customer`)
    expectedParams.push(`[" "]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const customersWithAge = await connection.selectFrom(tCustomer)
        .select({
            id: tCustomer.id,
            name: tCustomer.name,
            age: tCustomer.age,
        })
        .executeSelectMany()
    assertEquals(customersWithAge, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as companyId, id as companyName, parent_id as companyParentId, parent_id as favouriteCustomerId from company where id = $1 union all select company.id as companyId, company.id as companyName, company.parent_id as companyParentId, company.parent_id as favouriteCustomerId from company join recursive_select_1 on recursive_select_1.companyParentId = company.id) select companyId as "companyId", companyName as "companyName", companyParentId as "companyParentId", favouriteCustomerId as "favouriteCustomerId" from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)

    expectedResult.push(0)
    expectedQuery.push(`with recursive recursive_select_1 as (select id as companyId, id as companyName, parent_id as companyParentId, parent_id as favouriteCustomerId from company where id = $1 union all select company.id as companyId, company.id as companyName, company.parent_id as companyParentId, company.parent_id as favouriteCustomerId from company join recursive_select_1 on recursive_select_1.companyParentId = company.id) select count(*) from recursive_select_1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneColumnOneRow`)

    // const tCustomerLeftJoin = tCustomer.forUseInLeftJoin()
    
    const availableFields7 = {
        companyId: tCompany.id,
        companyName: tCompany.id,
        companyParentId: tCompany.parentId,
        favouriteCustomerId: tCompany.favouriteCustomerId,
        favouriteCustomerName: tCustomerLeftJoin.name
    };
    const fieldsToPick7 = [ 'companyName' as const, 'favouriteCustomerId' as const];
    const pickedFields7 = dynamicPickPaths(availableFields7, fieldsToPick7, ['companyId', 'companyParentId']);
    
    const companyTreeWithFavouriteCustomer = await connection.selectFrom(tCompany)
        .optionalLeftJoin(tCustomerLeftJoin).on(tCompany.favouriteCustomerId.equals(tCustomerLeftJoin.id))
        .where(tCompany.id.equals(10))
        .select(pickedFields7)
        .recursiveUnionAll((child) => {
            return connection.selectFrom(tCompany)
                .optionalLeftJoin(tCustomerLeftJoin).on(tCompany.favouriteCustomerId.equals(tCustomerLeftJoin.id))
                .join(child).on(child.companyParentId.equals(tCompany.id))
                .select(pickedFields7)
        })
        .executeSelectPage()
    assertEquals(companyTreeWithFavouriteCustomer, { data: result, count: 0})

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as "companyId", id as "companyName", parent_id as "companyParentId", parent_id as "favouriteCustomerId" from company where id = $1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)

    expectedResult.push(0)
    expectedQuery.push(`select count(*) from company where id = $1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneColumnOneRow`)

    // const tCustomerLeftJoin = tCustomer.forUseInLeftJoin()
    
    const availableFields8 = {
        companyId: tCompany.id,
        companyName: tCompany.id,
        companyParentId: tCompany.parentId,
        favouriteCustomerId: tCompany.favouriteCustomerId,
        favouriteCustomerName: tCustomerLeftJoin.name
    };
    const fieldsToPick8 = [ 'companyName' as const, 'favouriteCustomerId' as const];
    const pickedFields8 = dynamicPickPaths(availableFields8, fieldsToPick8, ['companyId', 'companyParentId']);
    
    const companyWithFavouriteCustomer = await connection.selectFrom(tCompany)
        .optionalLeftJoin(tCustomerLeftJoin).on(tCompany.favouriteCustomerId.equals(tCustomerLeftJoin.id))
        .where(tCompany.id.equals(10))
        .select(pickedFields8)
        .executeSelectPage()
    assertEquals(companyWithFavouriteCustomer, { data: result, count: 0})

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`with customerForUpdate(id, firstName, lastName) as (values ($1::int4, $2::text, $3::text)) update customer set first_name = customerForUpdate.firstName, last_name = customerForUpdate.lastName from customerForUpdate where customer.id = customerForUpdate.id`)
    expectedParams.push(`[1,"First Name","Last Name"]`)
    expectedType.push(`update`)

    /* *** Example ****************************************************************/

    class VCustomerForUpdate extends Values<DBConnection, 'customerForUpdate'> {
        id = this.column('int')
        firstName = this.column('string')
        lastName = this.column('string')
    }
    const customerForUpdate = Values.create(VCustomerForUpdate, 'customerForUpdate', [{
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }])
    
    updateCustomer = await connection.update(tCustomer)
        .from(customerForUpdate)
        .set({
            firstName: customerForUpdate.firstName,
            lastName: customerForUpdate.lastName
        })
        .where(tCustomer.id.equals(customerForUpdate.id))
        .executeUpdate()
    
    assertEquals(updateCustomer, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`with customerForDelete(firstName, lastName) as (values ($1::text, $2::text)) delete from customer using customerForDelete where customer.first_name = customerForDelete.firstName and customer.last_name = customerForDelete.lastName`)
    expectedParams.push(`["First Name","Last Name"]`)
    expectedType.push(`delete`)

    /* *** Example ****************************************************************/

    class VCustomerForDelete extends Values<DBConnection, 'customerForDelete'> {
        firstName = this.column('string')
        lastName = this.column('string')
    }
    const customerForDelete = Values.create(VCustomerForDelete, 'customerForDelete', [{
        firstName: 'First Name',
        lastName: 'Last Name'
    }])
    
    deleteCustomer = await connection.deleteFrom(tCustomer)
        .using(customerForDelete)
        .where(tCustomer.firstName.equals(customerForDelete.firstName))
        .and(tCustomer.lastName.equals(customerForDelete.lastName))
        .executeDelete()
    
    assertEquals(deleteCustomer, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, coalesce((select count(*) as result from customer where company_id = company.id), $1) as "numberOfCustomers" from company`)
    expectedParams.push(`[0]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const numberOfCustomers = connection
        .subSelectUsing(tCompany)
        .from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(connection.countAll())
        .forUseAsInlineQueryValue()  // At this point is a value that you can use in other query
        .valueWhenNull(0)

    const companiesWithNumberOfCustomers = await connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name,
            numberOfCustomers: numberOfCustomers
        })
        .executeSelectMany()

    assertEquals(companiesWithNumberOfCustomers, result)

    /* *** Preparation ************************************************************/

    result = 0
    expectedResult.push(result)
    expectedQuery.push(`select count(*) as result from customer where company_id = $1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneColumnOneRow`)

    /* *** Example ****************************************************************/

    companyId = 10

    const numberOfCustomers1 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.equals(companyId))
        .selectCountAll()
        .executeSelectOne()

    assertEquals(numberOfCustomers1, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, (select count(*) as result from customer where company_id = company.id) as "numberOfCustomers" from company`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const numberOfCustomers2 = connection
        .subSelectUsing(tCompany)
        .from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectCountAll()
        .forUseAsInlineQueryValue()  // At this point is a value that you can use in other query

    const companiesWithNumberOfCustomers2 = await connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name,
            numberOfCustomers: numberOfCustomers2
        })
        .executeSelectMany()

    assertEquals(companiesWithNumberOfCustomers2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with customerCountPerCompany as BEFORE (select company.id as companyId, company.name as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.name) AFTER select companyId as "acmeCompanyId", companyName as "acmeCompanyName", customerCount as "acmeCustomerCount" from customerCountPerCompany where companyName ilike ('%' || $1 || '%')`)
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompanyWith2 = connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        }).groupBy('companyId', 'companyName')
        .customizeQuery({
            beforeWithQuery: connection.rawFragment`BEFORE`,
            afterWithQuery: connection.rawFragment`AFTER`
        })
        .forUseInQueryAs('customerCountPerCompany')
    
    const customerCountPerAcmeCompanies2 = await connection.selectFrom(customerCountPerCompanyWith2)
        .where(customerCountPerCompanyWith2.companyName.containsInsensitive('ACME'))
        .select({
            acmeCompanyId: customerCountPerCompanyWith2.companyId,
            acmeCompanyName: customerCountPerCompanyWith2.companyName,
            acmeCustomerCount: customerCountPerCompanyWith2.customerCount
        })
        .executeSelectMany()
    
    assertEquals(customerCountPerAcmeCompanies2, result)

    /* *** Preparation ************************************************************/

    result = [ 'id', 'firstName', 'lastName', 'birthday', 'companyId', 'name', 'age' ]

    /* *** Example ****************************************************************/

    const tCustomerColumnNames = extractColumnNamesFrom(tCustomer)

    assertEquals(tCustomerColumnNames, result)

    /* *** Preparation ************************************************************/

    result = [ 'id', 'firstName', 'lastName', 'birthday', 'companyId' ]

    /* *** Example ****************************************************************/

    const tCustomerWritableColumnNames = extractWritableColumnNamesFrom(tCustomer)

    assertEquals(tCustomerWritableColumnNames, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", null::text as "lastName", birthday as birthday from customer where id = $1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    // const customerId = 10
    
    const customerWithIdWithRules = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName.onlyWhenOrNull(true),
            lastName: tCustomer.lastName.onlyWhenOrNull(false),
            birthday: tCustomer.birthday
        })
        .executeSelectOne()
    
    assertEquals(customerWithIdWithRules, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", null::text as "lastName", birthday as birthday from customer where id = $1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    // const customerId = 10
    
    const customerWithIdWithRules2 = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName.ignoreWhenAsNull(false),
            lastName: tCustomer.lastName.ignoreWhenAsNull(true),
            birthday: tCustomer.birthday
        })
        .executeSelectOne()
    
    assertEquals(customerWithIdWithRules2, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    // const customerId = 10
    let diaplayNames = true
    
    const customerWithIdWithRules3 = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName.onlyWhenOrNull(diaplayNames),
            lastName: tCustomer.lastName.onlyWhenOrNull(diaplayNames),
            birthday: tCustomer.birthday
        })
        .executeSelectOne()
    
    assertEquals(customerWithIdWithRules3, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, null::text as "firstName", null::text as "lastName", birthday as birthday from customer where id = $1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    // const customerId = 10
    diaplayNames = false
    
    const customerWithIdWithRules4 = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName.onlyWhenOrNull(diaplayNames),
            lastName: tCustomer.lastName.onlyWhenOrNull(diaplayNames),
            birthday: tCustomer.birthday
        })
        .executeSelectOne()
    
    assertEquals(customerWithIdWithRules4, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName", birthday as birthday, null::int4 as "companyId", null::text as "companyName" from customer where id = $1`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    let canSeeCompanyInfo = false

    const customerWithOptionalCompany7 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday,
            companyId: tCompany.id.onlyWhenOrNull(canSeeCompanyInfo),
            companyName: tCompany.name.onlyWhenOrNull(canSeeCompanyInfo)
        })
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany7, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select customer.id as id, customer.first_name as "firstName", customer.last_name as "lastName", customer.birthday as birthday, company.id as "companyId", company.name as "companyName" from customer inner join company on company.id = customer.company_id where customer.id = $1`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    canSeeCompanyInfo = true

    const customerWithOptionalCompany8 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday,
            companyId: tCompany.id.onlyWhenOrNull(canSeeCompanyInfo),
            companyName: tCompany.name.onlyWhenOrNull(canSeeCompanyInfo)
        })
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany8, result)
    
    /* *** Preparation ************************************************************/

    result = {
        data: [],
        count: 0
    }
    expectedResult.push([])
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName" from customer where first_name ilike ($1 || '%') or last_name ilike ($2 || '%') group by id order by "firstName", "lastName" limit $3 offset $4`)
    expectedParams.push(`["Smi","Smi",10,20]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push(0)
    expectedQuery.push(`with result_for_count as (select id as id, first_name as firstName, last_name as lastName from customer where first_name ilike ($1 || '%') or last_name ilike ($2 || '%') group by id order by firstName, lastName) select count(*) from result_for_count`)
    expectedParams.push(`["Smi","Smi"]`)
    expectedType.push(`selectOneColumnOneRow`)
    
    /* *** Example ****************************************************************/

    const customerName2 = 'Smi'
    const customerPageWithName2 = await connection.selectFrom(tCustomer)
        .where(
            tCustomer.firstName.startsWithInsensitive(customerName2)
        ).or(
            tCustomer.lastName.startsWithInsensitive(customerName2)
        ).select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .groupBy(tCustomer.id)
        .orderBy('firstName')
        .orderBy('lastName')
        .limit(10)
        .offset(20)
        .executeSelectPage()
    
    assertEquals(customerPageWithName2, result)

    /* *** Preparation ************************************************************/

    result = {
        data: [],
        count: 0
    }
    expectedResult.push([])
    expectedQuery.push(`select distinct id as id, first_name as "firstName", last_name as "lastName" from customer where first_name ilike ($1 || '%') or last_name ilike ($2 || '%') order by "firstName", "lastName" limit $3 offset $4`)
    expectedParams.push(`["Smi","Smi",10,20]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push(0)
    expectedQuery.push(`with result_for_count as (select distinct id as id, first_name as firstName, last_name as lastName from customer where first_name ilike ($1 || '%') or last_name ilike ($2 || '%') order by firstName, lastName) select count(*) from result_for_count`)
    expectedParams.push(`["Smi","Smi"]`)
    expectedType.push(`selectOneColumnOneRow`)
    
    /* *** Example ****************************************************************/

    const customerName3 = 'Smi'
    const customerPageWithName3 = await connection.selectDistinctFrom(tCustomer)
        .where(
            tCustomer.firstName.startsWithInsensitive(customerName3)
        ).or(
            tCustomer.lastName.startsWithInsensitive(customerName3)
        ).select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .orderBy('firstName')
        .orderBy('lastName')
        .limit(10)
        .offset(20)
        .executeSelectPage()
    
    assertEquals(customerPageWithName3, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update customer set first_name = $1, last_name = $2 where id = $3`)
    expectedParams.push(`["John","Smith",12]`)
    expectedType.push(`update`)

    /* *** Example ****************************************************************/

    const shapedUpdateCustomerName = {
        id: 12,
        customerFirstName: 'John',
        customerLastName: 'Smith',
    }
    
    const shapedUpdateCustomerNameResult = await connection.update(tCustomer)
        .shapedAs({
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        })
        .set(shapedUpdateCustomerName)
        .where(tCustomer.id.equals(shapedUpdateCustomerName.id))
        .executeUpdate()

    assertEquals(shapedUpdateCustomerNameResult, result)

    // /* *** Preparation ************************************************************/

    // result = 1
    // expectedResult.push(result)
    // expectedQuery.push(`update customer inner join company on customer.company_id = company.id set customer.first_name = ?, customer.last_name = ?, company.name = ? where customer.id = ?`)
    // expectedParams.push(`["John","Smith","ACME Inc.",12]`)
    // expectedType.push(`update`)

    // /* *** Example ****************************************************************/

    // const shapedUpdateCustomerNameAndCompanyName = {
    //     id: 12,
    //     customerFirstName: 'John',
    //     customerLastName: 'Smith',
    //     companyName: 'ACME Inc.'
    // }
    
    // const shapedUpdateCustomerNameAndCompanyNameResult = await connection.update(tCustomer)
    //     .innerJoin(tCompany).on(tCustomer.companyId.equals(tCompany.id))
    //     .shapedAs({
    //         customerFirstName: tCustomer.firstName,
    //         customerLastName: tCustomer.lastName,
    //         companyName: tCompany.name
    //     })
    //     .set(shapedUpdateCustomerNameAndCompanyName)
    //     .where(tCustomer.id.equals(shapedUpdateCustomerName.id))
    //     .executeUpdate()

    // assertEquals(shapedUpdateCustomerNameAndCompanyNameResult, result)

    /* *** Definition ****************************************************************/

    function buildComanyAvailableFields<CUSTOMER extends TableOrViewLeftJoinOf<typeof tCustomer, 'favouriteCoustomer'>>(_connection: DBConnection, favouriteCoustomerRef: CUSTOMER) {
        const favouriteCoustomer = fromRef(tCustomer, favouriteCoustomerRef);

        return {
            id: tCompany.id,
            name: tCompany.name,
            favouriteCustomer: {
                id: favouriteCoustomer.id,
                name: favouriteCoustomer.firstName.concat(' ').concat(favouriteCoustomer.lastName)
            }
        }
    }

    interface CustomerRules {
        anyCustomerNameContains?: string
        anyCustomerWithBirthdayOn?: Date
    }

    function buildCompanyConditionExtention<CUSTOMER extends TableOrViewLeftJoinOf<typeof tCustomer, 'favouriteCoustomer'>>(connection: DBConnection, favouriteCoustomerRef: CUSTOMER) {
        const favouriteCoustomer = fromRef(tCustomer, favouriteCoustomerRef);

        return {
            customers: (rules: CustomerRules) => {
                let result = connection.dynamicBooleanExpressionUsing(tCompany)
    
                if (rules.anyCustomerNameContains) {
                    const query = connection.subSelectUsing(tCompany)
                        .from(tCustomer)
                        .where(tCustomer.firstName.concat(' ').concat(tCustomer.lastName).containsInsensitive(rules.anyCustomerNameContains))
                        .selectOneColumn(tCustomer.id)
                    
                    result = result.and(connection.exists(query))
                }
    
                if (rules.anyCustomerWithBirthdayOn) {
                    const query = connection.subSelectUsing(tCompany)
                        .from(tCustomer)
                        .where(tCustomer.birthday.equals(rules.anyCustomerWithBirthdayOn))
                        .selectOneColumn(tCustomer.id)
                    
                    result = result.and(connection.exists(query))
                }
    
                return result
            },
            favouriteCustomer: {
                isInAnotherCompanyWithName: (name: string) => {
                    const query = connection.selectFrom(tCompany)
                        .where(tCompany.name.containsInsensitive(name))
                        .selectOneColumn(tCompany.favouriteCustomerId)
    
                    return favouriteCoustomer.id.in(query)
                }
            }
        }
    }

    type CompanyFields = DynamicPickPaths<ReturnType<typeof buildComanyAvailableFields>, 'id'>
    type CompanyDynamicCondition = DynamicCondition<ReturnType<typeof buildComanyAvailableFields>, ReturnType<typeof buildCompanyConditionExtention>>
    type CompanyInformation<FIELDS extends CompanyFields> = PickValuesPath<ReturnType<typeof buildComanyAvailableFields>, FIELDS | 'id'>
    
    async function getSubcompanies<FIELDS extends CompanyFields>(connection: DBConnection, parentCompanyId: number, fields: FIELDS[], condition: CompanyDynamicCondition): Promise<CompanyInformation<FIELDS>[]> {
        const favouriteCoustomer = tCustomer.forUseInLeftJoinAs('favouriteCoustomer')

        const avaliableFields = buildComanyAvailableFields(connection, favouriteCoustomer)
        const conditionExtention = buildCompanyConditionExtention(connection, favouriteCoustomer)
    
        const dynamicCondition = connection.dynamicConditionFor(avaliableFields, conditionExtention).withValues(condition)
        const selectedFields = dynamicPickPaths(avaliableFields, fields, ['id'])
        
        const companies = await connection
            .selectFrom(tCompany)
            .optionalLeftOuterJoin(favouriteCoustomer).on(tCompany.favouriteCustomerId.equals(favouriteCoustomer.id))
            .where(dynamicCondition)
            .and(tCompany.parentId.equals(parentCompanyId))
            .select(selectedFields)
            .executeSelectMany()
    
        return expandTypeFromDynamicPickPaths(avaliableFields, fields, companies, ['id'])
    }

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name from company where name ilike ('%' || $1 || '%') and parent_id = $2`)
    expectedParams.push(`["ACME",23]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    companyId = 23
    const result1 = await getSubcompanies(connection, companyId, ['name'], {name: { containsInsensitive: 'ACME' }})

    assertEquals(result1, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select company.id as id, company.name as name, favouriteCoustomer.first_name || $1 || favouriteCoustomer.last_name as "favouriteCustomer.name" from company left outer join customer as favouriteCoustomer on company.parent_id = favouriteCoustomer.id where exists(select id as result from customer where (first_name || $2 || last_name) ilike ('%' || $3 || '%')) and company.parent_id = $4`)
    expectedParams.push(`[" "," ","smith",23]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    companyId = 23
    const result2 = await getSubcompanies(connection, companyId, ['name', 'favouriteCustomer.name'], { customers: { anyCustomerNameContains: 'smith'} })

    assertEquals(result2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select company.id as id, company.name as name from company left outer join customer as favouriteCoustomer on company.parent_id = favouriteCoustomer.id where favouriteCoustomer.id in (select parent_id as result from company where name ilike ('%' || $1 || '%')) and company.parent_id = $2`)
    expectedParams.push(`["ACME Inc.",23]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    companyId = 23
    const result3 = await getSubcompanies(connection, companyId, ['name'], { favouriteCustomer: { isInAnotherCompanyWithName: 'ACME Inc.' } })

    assertEquals(result3, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name from company where (exists(select id as result from customer where (first_name || $1 || last_name) ilike ('%' || $2 || '%')) or exists(select id as result from customer where birthday = $3)) and parent_id = $4`)
    expectedParams.push(`[" ","John","2000-03-01T00:00:00.000Z",23]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    companyId = 23
    const result4 = await getSubcompanies(connection, companyId, ['name'], { 
        or: [ 
            { customers: { anyCustomerNameContains: 'John' }}, 
            { customers: { anyCustomerWithBirthdayOn: new Date('2000-03-01')} } 
        ] 
    })

    assertEquals(result4, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name',
        birthday: null
    }
    expectedResult.push({
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name',
    })
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    //let customerId = 10
    
    let customerWithId3 = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .projectingOptionalValuesAsNullable()
        .executeSelectOne()
    
    assertEquals(customerWithId3, result)

    let typeValidation3: {
        id: number;
        firstName: string;
        lastName: string;
        birthday: Date | null;
    } = null as any

    customerWithId3 = typeValidation3
    typeValidation3 = customerWithId3

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'John',
        lastName: 'Smith',
    }
    expectedResult.push({...result, birthday: null})
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values ($1, $2, $3) returning id as id, first_name as "firstName", last_name as "lastName", birthday as birthday`)
    expectedParams.push(`["John","Smith",1]`)
    expectedType.push(`insertReturningOneRow`)

    /* *** Example ****************************************************************/

    let insertReturningCustomerData5 = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }).returning({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .executeInsertOne()

    assertEquals(insertReturningCustomerData5, result)

    let typeValidation4: {
        id: number;
        firstName: string;
        lastName: string;
        birthday?: Date;
    } = null as any

    insertReturningCustomerData5 = typeValidation4
    typeValidation4 = insertReturningCustomerData5

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'John',
        lastName: 'Smith',
        birthday: null
    }
    expectedResult.push({
        id: 1,
        firstName: 'John',
        lastName: 'Smith',
    })
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) values ($1, $2, $3) returning id as id, first_name as "firstName", last_name as "lastName", birthday as birthday`)
    expectedParams.push(`["John","Smith",1]`)
    expectedType.push(`insertReturningOneRow`)

    /* *** Example ****************************************************************/

    let insertReturningCustomerData6 = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }).returning({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .projectingOptionalValuesAsNullable()
        .executeInsertOne()

    assertEquals(insertReturningCustomerData6, result)

    let typeValidation5: {
        id: number;
        firstName: string;
        lastName: string;
        birthday: Date | null;
    } = null as any

    insertReturningCustomerData6 = typeValidation5
    typeValidation5 = insertReturningCustomerData6

    /* *** Preparation ************************************************************/

    result = { firstName: 'Ron' }
    expectedResult.push(result)
    expectedQuery.push(`update customer set first_name = $1 where id = $2 returning first_name as "firstName", birthday as birthday`)
    expectedParams.push(`["Ron",1]`)
    expectedType.push(`updateReturningOneRow`)

    /* *** Example ****************************************************************/

    let updatedSmithFirstName2 = await connection.update(tCustomer)
        .set({
            firstName: 'Ron'
        })
        .where(tCustomer.id.equals(1))
        .returning({
            firstName: tCustomer.firstName,
            birthday: tCustomer.birthday
        })
        .executeUpdateOne()

    assertEquals(updatedSmithFirstName2, result)

    let typeValidation6: {
        firstName: string;
        birthday?: Date;
    } = null as any

    updatedSmithFirstName2 = typeValidation6
    typeValidation6 = updatedSmithFirstName2

    /* *** Preparation ************************************************************/

    result = { firstName: 'Ron', birthday: null }
    expectedResult.push({ firstName: 'Ron' })
    expectedQuery.push(`update customer set first_name = $1 where id = $2 returning first_name as "firstName", birthday as birthday`)
    expectedParams.push(`["Ron",1]`)
    expectedType.push(`updateReturningOneRow`)

    /* *** Example ****************************************************************/

    let updatedSmithFirstName3 = await connection.update(tCustomer)
        .set({
            firstName: 'Ron'
        })
        .where(tCustomer.id.equals(1))
        .returning({
            firstName: tCustomer.firstName,
            birthday: tCustomer.birthday
        })
        .projectingOptionalValuesAsNullable()
        .executeUpdateOne()

    assertEquals(updatedSmithFirstName3, result)

    let typeValidation7: {
        firstName: string;
        birthday: Date | null;
    } = null as any

    updatedSmithFirstName3 = typeValidation7
    typeValidation7 = updatedSmithFirstName3

    /* *** Preparation ************************************************************/

    result = { firstName: 'Ron' }
    expectedResult.push(result)
    expectedQuery.push(`delete from customer where id = $1 returning first_name as "firstName", birthday as birthday`)
    expectedParams.push(`[1]`)
    expectedType.push(`deleteReturningOneRow`)

    /* *** Example ****************************************************************/

    let deleteSmithFirstName = await connection.deleteFrom(tCustomer)
        .where(tCustomer.id.equals(1))
        .returning({
            firstName: tCustomer.firstName,
            birthday: tCustomer.birthday
        })
        .executeDeleteOne()

    assertEquals(deleteSmithFirstName, result)

    let typeValidation8: {
        firstName: string;
        birthday?: Date;
    } = null as any

    deleteSmithFirstName = typeValidation8
    typeValidation8 = deleteSmithFirstName

    /* *** Preparation ************************************************************/

    result = { firstName: 'Ron', birthday: null }
    expectedResult.push({ firstName: 'Ron' })
    expectedQuery.push(`delete from customer where id = $1 returning first_name as "firstName", birthday as birthday`)
    expectedParams.push(`[1]`)
    expectedType.push(`deleteReturningOneRow`)

    /* *** Example ****************************************************************/

    let deleteSmithFirstName2 = await connection.deleteFrom(tCustomer)
        .where(tCustomer.id.equals(1))
        .returning({
            firstName: tCustomer.firstName,
            birthday: tCustomer.birthday
        })
        .projectingOptionalValuesAsNullable()
        .executeDeleteOne()

    assertEquals(deleteSmithFirstName2, result)

    let typeValidation9: {
        firstName: string;
        birthday: Date | null;
    } = null as any

    deleteSmithFirstName2 = typeValidation9
    typeValidation9 = deleteSmithFirstName2

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, name as name, parent_id as "parentId", (select json_agg(json_build_object('id', id, 'firstName', first_name, 'lastName', last_name, 'birthday', birthday)) as result from customer where company_id = company.id) as customers from company where id = $1`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme12 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(connection.aggregateAsArray({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }))
        .forUseAsInlineQueryValue()

    let acmeCompanyWithCustomers12 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId,
            customers: aggregatedCustomersOfAcme12
        })
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers12, result)

    let typeValidation10: {
        id: number;
        name: string;
        parentId?: number;
        customers?: {
            id: number;
            firstName: string;
            lastName: string;
            birthday?: Date;
        }[];
    } = null as any

    acmeCompanyWithCustomers12 = typeValidation10
    typeValidation10 = acmeCompanyWithCustomers12

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith', birthday: null },
            { id: 2, firstName: 'Other', lastName: 'Person', birthday: null },
            { id: 3, firstName: 'Jane', lastName: 'Doe', birthday: null }
        ]
    }
    expectedResult.push({
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    })
    expectedQuery.push(`select id as id, name as name, parent_id as "parentId", (select json_agg(json_build_object('id', id, 'firstName', first_name, 'lastName', last_name, 'birthday', birthday)) as result from customer where company_id = company.id) as customers from company where id = $1`)
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme13 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(connection.aggregateAsArray({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).projectingOptionalValuesAsNullable())
        .forUseAsInlineQueryValue()

    let acmeCompanyWithCustomers13 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId,
            customers: aggregatedCustomersOfAcme13
        })
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers13, result)

    let typeValidation11: {
        id: number;
        name: string;
        parentId?: number;
        customers?: {
            id: number;
            firstName: string;
            lastName: string;
            birthday: Date | null;
        }[];
    } = null as any

    acmeCompanyWithCustomers13 = typeValidation11
    typeValidation11 = acmeCompanyWithCustomers13
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerWitnNotUsedCompanyOptionalJoin = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .where(tCustomer.id.equals(12))
        .and(tCompany.id.inIfValue([]))
        .executeSelectMany()
    
    assertEquals(customerWitnNotUsedCompanyOptionalJoin, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`with companySubQuery as (select id as id, name as name from company) select customer.id as id, customer.first_name as "firstName", customer.last_name as "lastName", companySubQuery.id as "company.id", companySubQuery.name as "company.name" from customer inner join companySubQuery on customer.company_id = companySubQuery.id where companySubQuery.name = $1 union all select customer.id as id, customer.first_name as "firstName", customer.last_name as "lastName", companySubQuery.id as "company.id", companySubQuery.name as "company.name" from customer inner join companySubQuery on customer.company_id = companySubQuery.id where companySubQuery.name = $2`)
    expectedParams.push(`["ACME","FOO"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const companySubQuery = connection
        .selectFrom(tCompany)
        .select({id: tCompany.id, name: tCompany.name})
        .forUseInQueryAs('companySubQuery')
    
    const customerWithCompanyInfo = await connection.selectFrom(tCustomer)
        .innerJoin(companySubQuery).on(tCustomer.companyId.equals(companySubQuery.id))
        .where(companySubQuery.name.equals('ACME'))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            company: {
                id: companySubQuery.id,
                name: companySubQuery.name
            }
        }).unionAll(
            connection.selectFrom(tCustomer)
            .innerJoin(companySubQuery).on(tCustomer.companyId.equals(companySubQuery.id))
            .where(companySubQuery.name.equals('FOO'))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                company: {
                    id: companySubQuery.id,
                    name: companySubQuery.name
                }
            })  
        )
        .executeSelectMany()
    
    assertEquals(customerWithCompanyInfo, result)

}

main().then(() => {
    console.log('All ok')
    process.exit(0)
}).catch((e) => {
    console.error(e)
    process.exit(1)
})
