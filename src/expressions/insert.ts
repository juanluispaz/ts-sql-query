import type { IExecutableSelectQuery, RemapIValueSourceType, ValueSourceValueType, AnyValueSource, ValueSourceOf, ValueSourceValueTypeForResult, RemapIValueSourceTypeWithOptionalType, IExecutableInsertQuery, IIfValueSource, IBooleanValueSource, IStringValueSource, ITypeSafeStringValueSource } from "./values"
import type { ITableOrView, NoTableOrViewRequired, NoTableOrViewRequiredView, ResolvedShape, VALUES_FOR_INSERT } from "../utils/ITableOrView"
import type { AnyDB, TypeSafeDB, NoopDB, PostgreSql, SqlServer, Oracle, Sqlite, MariaDB, MySql, TypeWhenSafeDB } from "../databases"
import type { int } from "ts-extended-types"
import type { database, tableOrView, tableOrViewRef } from "../utils/symbols"
import type { ColumnWithDefaultValue } from "../utils/Column"
import type { RawFragment } from "../utils/RawFragment"
import type { Default } from "./Default"
import type { AutogeneratedPrimaryKeyColumnsTypesOf, ColumnsForSetOf, ColumnsForSetOfWithShape, ColumnsOf, OptionalColumnsForSetOf, OptionalColumnsForSetOfWithShape, RequiredColumnsForSetOf, RequiredColumnsForSetOfWithShape, ResolveShape } from "../utils/tableOrViewUtils"
import type { ColumnGuard, GuidedObj, GuidedPropName, RequiredKeysOfPickingColumns, ResultObjectValues, FixOptionalProperties, ValueOf } from "../utils/resultUtils"

export interface InsertCustomization<DB extends AnyDB> {
    afterInsertKeyword?: RawFragment<DB>
    afterQuery?: RawFragment<DB>
}

export interface InsertExpressionOf<DB extends AnyDB> {
    [database]: DB
}

export interface InsertExpressionBase<TABLE extends ITableOrView<any>> extends InsertExpressionOf<TABLE[typeof database]> {
    [tableOrView]: TABLE
}

export interface ExecutableInsert<TABLE extends ITableOrView<any>> extends InsertExpressionBase<TABLE>, IExecutableInsertQuery<TABLE, number> {
    executeInsert(this: InsertExpressionOf<TypeSafeDB>, min?: number, max?: number): Promise<int>
    executeInsert(min?: number, max?: number): Promise<number>
    query(): string
    params(): any[]
}

export interface ExecutableInsertReturningLastInsertedId<TABLE extends ITableOrView<any>, RESULT> extends InsertExpressionBase<TABLE>, IExecutableInsertQuery<TABLE, RESULT> {
    executeInsert(min?: number, max?: number): Promise<RESULT>
    query(): string
    params(): any[]
}

export interface CustomizableExecutableInsert<TABLE extends ITableOrView<any>> extends ExecutableInsert<TABLE> {
    customizeQuery(customization: InsertCustomization<TABLE[typeof database]>): ExecutableInsert<TABLE>
}

export interface CustomizableExecutableInsertReturningLastInsertedId<TABLE extends ITableOrView<any>, RESULT> extends ExecutableInsertReturningLastInsertedId<TABLE, RESULT> {
    customizeQuery(customization: InsertCustomization<TABLE[typeof database]>): ExecutableInsertReturningLastInsertedId<TABLE, RESULT>
}

export interface CustomizableExecutableInsertFromSelectOnConflict<TABLE extends ITableOrView<any>> extends CustomizableExecutableInsert<TABLE> {
    returningLastInsertedId: ReturningLastInsertedIdFromSelectType<TABLE>
    returning: ReturningFromSelectFnType<TABLE>
    returningOneColumn: ReturningOneColumnFromSelectFnType<TABLE>
}

export interface CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE extends ITableOrView<any>> extends CustomizableExecutableInsert<TABLE> {
    returningLastInsertedId: ReturningLastInsertedIdFromSelectOptionalType<TABLE>
    returning: ReturningFromSelectOptionalFnType<TABLE>
    returningOneColumn: ReturningOneColumnFromSelectOptionalFnType<TABLE>
}

export interface CustomizableExecutableInsertFromSelect<TABLE extends ITableOrView<any>, SHAPE> extends CustomizableExecutableInsert<TABLE> {
    returningLastInsertedId: ReturningLastInsertedIdFromSelectType<TABLE>
    returning: ReturningFromSelectFnType<TABLE>
    returningOneColumn: ReturningOneColumnFromSelectFnType<TABLE>
    onConflictDoNothing: OnConflictDoNothingFnType<TABLE, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE>>
    onConflictDoUpdateDynamicSet: OnConflictDoUpdateDynamicSetFnType<TABLE, SHAPE, CustomizableExecutableInsertFromSelectOnConflict<TABLE>, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE>>
    onConflictDoUpdateSet: OnConflictDoUpdateSetFnType<TABLE, SHAPE, CustomizableExecutableInsertFromSelectOnConflict<TABLE>, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE>>
    onConflictDoUpdateSetIfValue: OnConflictDoUpdateSetFnType<TABLE, SHAPE, CustomizableExecutableInsertFromSelectOnConflict<TABLE>, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE>>
    onConflictOn: OnConflictOnColumnFnType<TABLE, OnConflictDoInsertFromSelect<TABLE, SHAPE>>
    onConflictOnConstraint: OnConflictOnConstraintFnType<TABLE, OnConflictDoInsertFromSelect<TABLE, SHAPE>>
}

export interface OnConflictDoInsertFromSelect<TABLE extends ITableOrView<any>, SHAPE> {
    doNothing: OnConflictDoNothingFnType<TABLE, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE>>
    doUpdateDynamicSet: OnConflictDoUpdateDynamicSetFnType<TABLE, SHAPE, CustomizableExecutableInsertFromSelectOnConflict<TABLE>, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE>>
    doUpdateSet: OnConflictDoUpdateSetFnType<TABLE, SHAPE, CustomizableExecutableInsertFromSelectOnConflict<TABLE>, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE>>
    doUpdateSetIfValue: OnConflictDoUpdateSetFnType<TABLE, SHAPE, CustomizableExecutableInsertFromSelectOnConflict<TABLE>, CustomizableExecutableInsertFromSelectOnConflictOptional<TABLE>>
}

export interface CustomizableExecutableSimpleInsertOnConflict<TABLE extends ITableOrView<any>> extends CustomizableExecutableInsert<TABLE> {
    returningLastInsertedId: OnConflictReturningLastInsertedIdType<TABLE>
    returning: ReturningFnType<TABLE>
    returningOneColumn: ReturningOneColumnFnType<TABLE>
}

export interface CustomizableExecutableSimpleInsertOnConflictOptional<TABLE extends ITableOrView<any>> extends CustomizableExecutableInsert<TABLE> {
    returningLastInsertedId: OnConflictReturningLastInsertedIdOptionalType<TABLE>
    returning: ReturningOptionalFnType<TABLE>
    returningOneColumn: ReturningOneColumnOptionalFnType<TABLE>
}

export interface CustomizableExecutableSimpleInsert<TABLE extends ITableOrView<any>, SHAPE> extends CustomizableExecutableInsert<TABLE> {
    returningLastInsertedId: ReturningLastInsertedIdType<TABLE>
    returning: ReturningFnType<TABLE>
    returningOneColumn: ReturningOneColumnFnType<TABLE>
    onConflictDoNothing: OnConflictDoNothingFnType<TABLE, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE>>
    onConflictDoUpdateDynamicSet: OnConflictDoUpdateDynamicSetFnType<TABLE, SHAPE, CustomizableExecutableSimpleInsertOnConflict<TABLE>, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE>>
    onConflictDoUpdateSet: OnConflictDoUpdateSetFnType<TABLE, SHAPE, CustomizableExecutableSimpleInsertOnConflict<TABLE>, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE>>
    onConflictDoUpdateSetIfValue: OnConflictDoUpdateSetFnType<TABLE, SHAPE, CustomizableExecutableSimpleInsertOnConflict<TABLE>, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE>>
    onConflictOn: OnConflictOnColumnFnType<TABLE, OnConflictDoSimpleInsert<TABLE, SHAPE>>
    onConflictOnConstraint: OnConflictOnConstraintFnType<TABLE, OnConflictDoSimpleInsert<TABLE, SHAPE>>
}

export interface OnConflictDoSimpleInsert<TABLE extends ITableOrView<any>, SHAPE> {
    doNothing: OnConflictDoNothingFnType<TABLE, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE>>
    doUpdateDynamicSet: OnConflictDoUpdateDynamicSetFnType<TABLE, SHAPE, CustomizableExecutableSimpleInsertOnConflict<TABLE>, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE>>
    doUpdateSet: OnConflictDoUpdateSetFnType<TABLE, SHAPE, CustomizableExecutableSimpleInsertOnConflict<TABLE>, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE>>
    doUpdateSetIfValue: OnConflictDoUpdateSetFnType<TABLE, SHAPE, CustomizableExecutableSimpleInsertOnConflict<TABLE>, CustomizableExecutableSimpleInsertOnConflictOptional<TABLE>>
}

export interface CustomizableExecutableMultipleInsertOnConfict<TABLE extends ITableOrView<any>> extends CustomizableExecutableInsert<TABLE> {
    returningLastInsertedId: ReturningMultipleLastInsertedIdType<TABLE>
    returning: ReturningFnType<TABLE>
    returningOneColumn: ReturningOneColumnFnType<TABLE>
}

export interface CustomizableExecutableMultipleInsertOnConfictOptional<TABLE extends ITableOrView<any>> extends CustomizableExecutableInsert<TABLE> {
    returningLastInsertedId: ReturningMultipleLastInsertedIdOptionalType<TABLE>
    returning: ReturningOptionalFnType<TABLE>
    returningOneColumn: ReturningOneColumnOptionalFnType<TABLE>
}

export interface CustomizableExecutableMultipleInsert<TABLE extends ITableOrView<any>, SHAPE> extends CustomizableExecutableInsert<TABLE> {
    returningLastInsertedId: ReturningMultipleLastInsertedIdType<TABLE>
    returning: ReturningFnType<TABLE>
    returningOneColumn: ReturningOneColumnFnType<TABLE>
    onConflictDoNothing: OnConflictDoNothingFnType<TABLE, CustomizableExecutableMultipleInsertOnConfict<TABLE>>
    onConflictDoUpdateDynamicSet: OnConflictDoUpdateDynamicSetFnType<TABLE, SHAPE, CustomizableExecutableMultipleInsertOnConfict<TABLE>, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE>>
    onConflictDoUpdateSet: OnConflictDoUpdateSetFnType<TABLE, SHAPE, CustomizableExecutableMultipleInsertOnConfict<TABLE>, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE>>
    onConflictDoUpdateSetIfValue: OnConflictDoUpdateSetFnType<TABLE, SHAPE, CustomizableExecutableMultipleInsertOnConfict<TABLE>, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE>>
    onConflictOn: OnConflictOnColumnFnType<TABLE, OnConflictDoMultipleInsert<TABLE, SHAPE>>
    onConflictOnConstraint: OnConflictOnConstraintFnType<TABLE, OnConflictDoMultipleInsert<TABLE, SHAPE>>
}

export interface OnConflictDoMultipleInsert<TABLE extends ITableOrView<any>, SHAPE> {
    doNothing: OnConflictDoNothingFnType<TABLE, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE>>
    doUpdateDynamicSet: OnConflictDoUpdateDynamicSetFnType<TABLE, SHAPE, CustomizableExecutableMultipleInsertOnConfict<TABLE>, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE>>
    doUpdateSet: OnConflictDoUpdateSetFnType<TABLE, SHAPE, CustomizableExecutableMultipleInsertOnConfict<TABLE>, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE>>
    doUpdateSetIfValue: OnConflictDoUpdateSetFnType<TABLE, SHAPE, CustomizableExecutableMultipleInsertOnConfict<TABLE>, CustomizableExecutableMultipleInsertOnConfictOptional<TABLE>>
}

export interface ExecutableInsertExpression<TABLE extends ITableOrView<any>> extends CustomizableExecutableSimpleInsert<TABLE, undefined> {
    set(columns: InsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    setIfValue(columns: OptionalInsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    setIfSet(columns: InsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    setIfSetIfValue(columns: OptionalInsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    setIfNotSet(columns: InsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    setIfNotSetIfValue(columns: OptionalInsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    ignoreIfSet<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MaybeExecutableInsertExpression<TABLE, COLUMNS & RequiredColumnsForSetOf<TABLE>>
    keepOnly<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MaybeExecutableInsertExpression<TABLE, Exclude<RequiredColumnsForSetOf<TABLE>, COLUMNS>>

    setIfHasValue(columns: InsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    setIfHasValueIfValue(columns: OptionalInsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    setIfHasNoValue(columns: InsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    setIfHasNoValueIfValue(columns: OptionalInsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOf<TABLE>[]): ExecutableInsertExpression<TABLE>
    ignoreAnySetWithNoValue(): ExecutableInsertExpression<TABLE>
}

export interface ShapedExecutableInsertExpression<TABLE extends ITableOrView<any>, SHAPE> extends CustomizableExecutableSimpleInsert<TABLE, SHAPE> {
    extendShape<EXTEND_SHAPE extends InsertShape<TABLE>>(shape: EXTEND_SHAPE): MaybeShapedExecutableInsertExpression<TABLE, SHAPE & ResolveShape<TABLE, EXTEND_SHAPE>, keyof EXTEND_SHAPE, never>
    set(columns: InsertSets<TABLE, SHAPE>): ShapedExecutableInsertExpression<TABLE, SHAPE>
    setIfValue(columns: OptionalInsertSets<TABLE, SHAPE>): ShapedExecutableInsertExpression<TABLE, SHAPE>
    setIfSet(columns: InsertSets<TABLE, SHAPE>): ShapedExecutableInsertExpression<TABLE, SHAPE>
    setIfSetIfValue(columns: OptionalInsertSets<TABLE, SHAPE>): ShapedExecutableInsertExpression<TABLE, SHAPE>
    setIfNotSet(columns: InsertSets<TABLE, SHAPE>): ShapedExecutableInsertExpression<TABLE, SHAPE>
    setIfNotSetIfValue(columns: OptionalInsertSets<TABLE, SHAPE>): ShapedExecutableInsertExpression<TABLE, SHAPE>
    ignoreIfSet<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, COLUMNS & RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, never>
    keepOnly<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, COLUMNS>, never>

    setIfHasValue(columns: InsertSets<TABLE, SHAPE>): ShapedExecutableInsertExpression<TABLE, SHAPE>
    setIfHasValueIfValue(columns: OptionalInsertSets<TABLE, SHAPE>): ShapedExecutableInsertExpression<TABLE, SHAPE>
    setIfHasNoValue(columns: InsertSets<TABLE, SHAPE>): ShapedExecutableInsertExpression<TABLE, SHAPE>
    setIfHasNoValueIfValue(columns: OptionalInsertSets<TABLE, SHAPE>): ShapedExecutableInsertExpression<TABLE, SHAPE>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, SHAPE>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableInsertExpression<TABLE, SHAPE>
    ignoreAnySetWithNoValue(): ShapedExecutableInsertExpression<TABLE, SHAPE>
}

export interface MissingKeysInsertExpression<TABLE extends ITableOrView<any>, MISSING_KEYS> extends InsertExpressionBase<TABLE> {
    set<COLUMNS extends InsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setIfValue<COLUMNS extends OptionalInsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setIfSet<COLUMNS extends InsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setIfSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setIfNotSet<COLUMNS extends InsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setIfNotSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    ignoreIfSet<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MissingKeysInsertExpression<TABLE, (COLUMNS & RequiredColumnsForSetOf<TABLE>) | MISSING_KEYS>
    keepOnly<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MissingKeysInsertExpression<TABLE, Exclude<RequiredColumnsForSetOf<TABLE>, COLUMNS> | MISSING_KEYS>
    
    setIfHasValue<COLUMNS extends InsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setIfHasValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setIfHasNoValue<COLUMNS extends InsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setIfHasNoValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, MISSING_KEYS>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOf<TABLE>[]): MissingKeysInsertExpression<TABLE, MISSING_KEYS>
    ignoreAnySetWithNoValue(): MissingKeysInsertExpression<TABLE, MISSING_KEYS>
}

export interface ShapedMissingKeysInsertExpression<TABLE extends ITableOrView<any>, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE> extends InsertExpressionBase<TABLE> {
    extendShape<EXTEND_SHAPE extends InsertShape<TABLE>>(shape: EXTEND_SHAPE): ShapedMissingKeysInsertExpression<TABLE, SHAPE & ResolveShape<TABLE, EXTEND_SHAPE>, MISSING_KEYS | keyof EXTEND_SHAPE, Exclude<MISSING_KEYS_IN_SHAPE, EXTEND_SHAPE[keyof EXTEND_SHAPE]>>
    set<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setIfValue<COLUMNS extends OptionalInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setIfSet<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setIfSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setIfNotSet<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setIfNotSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    ignoreIfSet<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): ShapedMissingKeysInsertExpression<TABLE, SHAPE, (COLUMNS & RequiredColumnsForSetOfWithShape<TABLE, SHAPE>) | MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    keepOnly<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): ShapedMissingKeysInsertExpression<TABLE, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, COLUMNS> | MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    
    setIfHasValue<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setIfHasValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setIfHasNoValue<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setIfHasNoValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysInsertExpression<TABLE, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreAnySetWithNoValue(): ShapedMissingKeysInsertExpression<TABLE, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
}

export interface ExecutableMultipleInsertExpression<TABLE extends ITableOrView<any>> extends CustomizableExecutableMultipleInsert<TABLE, undefined> {
    setForAll(columns: InsertSets<TABLE, undefined>): ExecutableMultipleInsertExpression<TABLE>
    setForAllIfValue(columns: OptionalInsertSets<TABLE, undefined>): ExecutableMultipleInsertExpression<TABLE>
    setForAllIfSet(columns: InsertSets<TABLE, undefined>): ExecutableMultipleInsertExpression<TABLE>
    setForAllIfSetIfValue(columns: OptionalInsertSets<TABLE, undefined>): ExecutableMultipleInsertExpression<TABLE>
    setForAllIfNotSet(columns: InsertSets<TABLE, undefined>): ExecutableMultipleInsertExpression<TABLE>
    setForAllIfNotSetIfValue(columns: OptionalInsertSets<TABLE, undefined>): ExecutableMultipleInsertExpression<TABLE>
    ignoreIfSet<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MaybeExecutableMultipleInsertExpression<TABLE, COLUMNS & RequiredColumnsForSetOf<TABLE>>
    keepOnly<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MaybeExecutableMultipleInsertExpression<TABLE, Exclude<RequiredColumnsForSetOf<TABLE>, COLUMNS>>

    setForAllIfHasValue(columns: InsertSets<TABLE, undefined>): ExecutableMultipleInsertExpression<TABLE>
    setForAllIfHasValueIfValue(columns: OptionalInsertSets<TABLE, undefined>): ExecutableMultipleInsertExpression<TABLE>
    setForAllIfHasNoValue(columns: InsertSets<TABLE, undefined>): ExecutableMultipleInsertExpression<TABLE>
    setForAllIfHasNoValueIfValue(columns: OptionalInsertSets<TABLE, undefined>): ExecutableMultipleInsertExpression<TABLE>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOf<TABLE>[]): ExecutableMultipleInsertExpression<TABLE>
    ignoreAnySetWithNoValue(): ExecutableMultipleInsertExpression<TABLE>
}

export interface ShapedExecutableMultipleInsertExpression<TABLE extends ITableOrView<any>, SHAPE> extends CustomizableExecutableMultipleInsert<TABLE, SHAPE> {
    extendShape<EXTEND_SHAPE extends InsertShape<TABLE>>(shape: EXTEND_SHAPE): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE & ResolveShape<TABLE, EXTEND_SHAPE>, keyof EXTEND_SHAPE, never>
    setForAll(columns: InsertSets<TABLE, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
    setForAllIfValue(columns: OptionalInsertSets<TABLE, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
    setForAllIfSet(columns: InsertSets<TABLE, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
    setForAllIfSetIfValue(columns: OptionalInsertSets<TABLE, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
    setForAllIfNotSet(columns: InsertSets<TABLE, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
    setForAllIfNotSetIfValue(columns: OptionalInsertSets<TABLE, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
    ignoreIfSet<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, COLUMNS & RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, never>
    keepOnly<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, COLUMNS>, never>

    setForAllIfHasValue(columns: InsertSets<TABLE, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
    setForAllIfHasValueIfValue(columns: OptionalInsertSets<TABLE, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
    setForAllIfHasNoValue(columns: InsertSets<TABLE, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
    setForAllIfHasNoValueIfValue(columns: OptionalInsertSets<TABLE, SHAPE>): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
    ignoreAnySetWithNoValue(): ShapedExecutableMultipleInsertExpression<TABLE, SHAPE>
}

export interface MissingKeysMultipleInsertExpression<TABLE extends ITableOrView<any>, MISSING_KEYS> extends InsertExpressionBase<TABLE> {
    setForAll<COLUMNS extends InsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setForAllIfValue<COLUMNS extends OptionalInsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setForAllIfSet<COLUMNS extends InsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setForAllIfSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setForAllIfNotSet<COLUMNS extends InsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setForAllIfNotSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    ignoreIfSet<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MissingKeysMultipleInsertExpression<TABLE, (COLUMNS & RequiredColumnsForSetOf<TABLE>) | MISSING_KEYS>
    keepOnly<COLUMNS extends ColumnsForSetOf<TABLE>>(...columns: COLUMNS[]): MissingKeysMultipleInsertExpression<TABLE, Exclude<RequiredColumnsForSetOf<TABLE>, COLUMNS> | MISSING_KEYS>
    
    setForAllIfHasValue<COLUMNS extends InsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setForAllIfHasValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setForAllIfHasNoValue<COLUMNS extends InsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    setForAllIfHasNoValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableMultipleInsertExpression<TABLE, Exclude<MISSING_KEYS, keyof COLUMNS>>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, MISSING_KEYS>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOf<TABLE>[]): MissingKeysMultipleInsertExpression<TABLE, MISSING_KEYS>
    ignoreAnySetWithNoValue(): MissingKeysMultipleInsertExpression<TABLE, MISSING_KEYS>
}

export interface ShapedMissingKeysMultipleInsertExpression<TABLE extends ITableOrView<any>, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE> extends InsertExpressionBase<TABLE> {
    extendShape<EXTEND_SHAPE extends InsertShape<TABLE>>(shape: EXTEND_SHAPE): ShapedMissingKeysMultipleInsertExpression<TABLE, SHAPE & ResolveShape<TABLE, EXTEND_SHAPE>, MISSING_KEYS | keyof EXTEND_SHAPE, Exclude<MISSING_KEYS_IN_SHAPE, EXTEND_SHAPE[keyof EXTEND_SHAPE]>>
    setForAll<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setForAllIfValue<COLUMNS extends OptionalInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setForAllIfSet<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setForAllIfSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setForAllIfNotSet<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setForAllIfNotSetIfValue<COLUMNS extends OptionalInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    ignoreIfSet<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): ShapedMissingKeysMultipleInsertExpression<TABLE, SHAPE, (COLUMNS & RequiredColumnsForSetOfWithShape<TABLE, SHAPE>) | MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    keepOnly<COLUMNS extends ColumnsForSetOfWithShape<TABLE, SHAPE>>(...columns: COLUMNS[]): ShapedMissingKeysMultipleInsertExpression<TABLE, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, COLUMNS> | MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    
    setForAllIfHasValue<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setForAllIfHasValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setForAllIfHasNoValue<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setForAllIfHasNoValueIfValue<COLUMNS extends OptionalInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<MISSING_KEYS, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    ignoreIfHasValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreIfHasNoValue(...columns: OptionalColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedMissingKeysMultipleInsertExpression<TABLE, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ignoreAnySetWithNoValue(): ShapedMissingKeysMultipleInsertExpression<TABLE, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
}

export interface InsertExpression<TABLE extends ITableOrView<any>> extends InsertExpressionBase<TABLE> {
    shapedAs<SHAPE extends InsertShape<TABLE>>(shape: SHAPE): ShapedInsertExpression<TABLE, ResolveShape<TABLE, SHAPE>, Exclude<RequiredColumnsForSetOf<TABLE>, SHAPE[keyof SHAPE]>>
    dynamicSet(): MissingKeysInsertExpression<TABLE, RequiredColumnsForSetOf<TABLE>>
    dynamicSet<COLUMNS extends InsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, Exclude<RequiredColumnsForSetOf<TABLE>, keyof COLUMNS>>
    set(columns: MandatoryInsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    setIfValue(columns: MandatoryOptionalInsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    values(columns: MandatoryInsertSets<TABLE, undefined>): ExecutableInsertExpression<TABLE>
    values(columns: Array<MandatoryInsertSets<TABLE, undefined>>): CustomizableExecutableMultipleInsert<TABLE, undefined>
    dynamicValues<COLUMNS extends InsertSets<TABLE, undefined>>(columns: COLUMNS): MaybeExecutableInsertExpression<TABLE, Exclude<RequiredColumnsForSetOf<TABLE>, keyof COLUMNS>>
    dynamicValues<COLUMNS extends InsertSets<TABLE, undefined>>(columns: Array<COLUMNS>): MaybeExecutableMultipleInsertExpression<TABLE, Exclude<RequiredColumnsForSetOf<TABLE>, keyof COLUMNS>>
    defaultValues: DefaultValueType<TABLE>
    from(select: IExecutableSelectQuery<TABLE[typeof database], SelectForInsertResultType<TABLE>, SelectForInsertColumns<TABLE>, NoTableOrViewRequiredView<TABLE[typeof database]>>): CustomizableExecutableInsertFromSelect<TABLE, undefined>
}

export interface ShapedInsertExpression<TABLE extends ITableOrView<any>, SHAPE, MISSING_KEYS_IN_SHAPE> extends InsertExpressionBase<TABLE> {
    extendShape<EXTEND_SHAPE extends InsertShape<TABLE>>(shape: EXTEND_SHAPE): ShapedInsertExpression<TABLE, SHAPE & ResolveShape<TABLE, EXTEND_SHAPE>, Exclude<MISSING_KEYS_IN_SHAPE, EXTEND_SHAPE[keyof EXTEND_SHAPE]>>
    dynamicSet(): ShapedMissingKeysInsertExpression<TABLE, SHAPE, RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, MISSING_KEYS_IN_SHAPE>
    dynamicSet<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    set<COLUMNS extends MandatoryInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    setIfValue<COLUMNS extends MandatoryInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    values<COLUMNS extends MandatoryInsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    values<COLUMNS extends MandatoryInsertSets<TABLE, SHAPE>>(columns: Array<COLUMNS>): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    dynamicValues<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: COLUMNS): MaybeShapedExecutableInsertExpression<TABLE, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
    dynamicValues<COLUMNS extends InsertSets<TABLE, SHAPE>>(columns: Array<COLUMNS>): MaybeShapedExecutableMultipleInsertExpression<TABLE, SHAPE, Exclude<RequiredColumnsForSetOfWithShape<TABLE, SHAPE>, keyof COLUMNS>, MISSING_KEYS_IN_SHAPE>
}




export interface ExecutableInsertReturning<TABLE extends ITableOrView<any>, COLUMNS, RESULT> extends InsertExpressionBase<TABLE>, IExecutableInsertQuery<TABLE, RESULT> {
    executeInsertNoneOrOne(): Promise<( COLUMNS extends AnyValueSource ? RESULT : { [P in keyof RESULT]: RESULT[P] }) | null>
    executeInsertOne(): Promise<( COLUMNS extends AnyValueSource ? RESULT : { [P in keyof RESULT]: RESULT[P] })>
    executeInsertMany(min?: number, max?: number): Promise<( COLUMNS extends AnyValueSource ? RESULT : { [P in keyof RESULT]: RESULT[P] })[]>

    query(): string
    params(): any[]
}

export interface ComposableExecutableInsert<TABLE extends ITableOrView<any>, COLUMNS, RESULT> extends ExecutableInsertReturning<TABLE, COLUMNS, RESULT> {
    compose<EXTERNAL_PROP extends keyof RESULT & ColumnGuard<COLUMNS>, INTERNAL_PROP extends string, RESULT_PROP extends string>(config: {
        externalProperty: EXTERNAL_PROP,
        internalProperty: INTERNAL_PROP,
        propertyName: RESULT_PROP
    }): ComposeExpression<EXTERNAL_PROP, INTERNAL_PROP, RESULT_PROP, TABLE, COLUMNS, RESULT>
    composeDeletingInternalProperty<EXTERNAL_PROP extends keyof RESULT & ColumnGuard<COLUMNS>, INTERNAL_PROP extends string, RESULT_PROP extends string>(config: {
        externalProperty: EXTERNAL_PROP,
        internalProperty: INTERNAL_PROP,
        propertyName: RESULT_PROP
    }): ComposeExpressionDeletingInternalProperty<EXTERNAL_PROP, INTERNAL_PROP, RESULT_PROP, TABLE, COLUMNS, RESULT>
    composeDeletingExternalProperty<EXTERNAL_PROP extends keyof RESULT & ColumnGuard<COLUMNS>, INTERNAL_PROP extends string, RESULT_PROP extends string>(config: {
        externalProperty: EXTERNAL_PROP,
        internalProperty: INTERNAL_PROP,
        propertyName: RESULT_PROP
    }): ComposeExpressionDeletingExternalProperty<EXTERNAL_PROP, INTERNAL_PROP, RESULT_PROP, TABLE, COLUMNS, RESULT>

    // Note: { [Q in keyof SelectResult<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>]: SelectResult<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>[Q] } is used to define the internal object because { [P in keyof MAPPING]: RESULT[MAPPING[P]] } doesn't respect the optional typing of the props
    splitRequired<RESULT_PROP extends string, MAPPED_PROPS extends keyof RESULT & ColumnGuard<COLUMNS>, MAPPING extends { [P: string]: MAPPED_PROPS }>(propertyName: RESULT_PROP, mappig: MAPPING): ComposableExecutableInsert<TABLE, COLUMNS, Omit<RESULT, ValueOf<MAPPING>> & { [key in RESULT_PROP]: { [Q in keyof FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>]: FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>[Q] }}>
    splitOptional<RESULT_PROP extends string, MAPPED_PROPS extends keyof RESULT & ColumnGuard<COLUMNS>, MAPPING extends { [P: string]: MAPPED_PROPS }>(propertyName: RESULT_PROP, mappig: MAPPING): ComposableExecutableInsert<TABLE, COLUMNS, Omit<RESULT, ValueOf<MAPPING>> & { [key in RESULT_PROP]?: { [Q in keyof FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>]: FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>[Q] }}>
    split<RESULT_PROP extends string, MAPPED_PROPS extends keyof RESULT & ColumnGuard<COLUMNS>, MAPPING extends { [P: string]: MAPPED_PROPS }>(propertyName: RESULT_PROP, mappig: MAPPING): ComposableExecutableInsert<TABLE, COLUMNS, Omit<RESULT, ValueOf<MAPPING>> & ( {} extends FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }> ? { [key in RESULT_PROP]?: { [Q in keyof FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>]: FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>[Q] }} : { [key in RESULT_PROP]: { [Q in keyof FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>]: FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>[Q] }})>

    guidedSplitRequired<RESULT_PROP extends string, MAPPED_PROPS extends keyof GuidedObj<RESULT> & ColumnGuard<COLUMNS>, MAPPING extends { [P: string]: MAPPED_PROPS }>(propertyName: RESULT_PROP, mappig: MAPPING): ComposableExecutableInsert<TABLE, COLUMNS, Omit<RESULT, GuidedPropName<ValueOf<MAPPING>>> & { [key in RESULT_PROP]: { [Q in keyof FixOptionalProperties<{ [P in keyof MAPPING]: GuidedObj<RESULT>[MAPPING[P]] }>]: FixOptionalProperties<{ [P in keyof MAPPING]: GuidedObj<RESULT>[MAPPING[P]] }>[Q] }}>
    guidedSplitOptional<RESULT_PROP extends string, MAPPED_PROPS extends keyof GuidedObj<RESULT> & ColumnGuard<COLUMNS>, MAPPING extends { [P: string]: MAPPED_PROPS }>(propertyName: RESULT_PROP, mappig: MAPPING): ComposableExecutableInsert<TABLE, COLUMNS, Omit<RESULT, GuidedPropName<ValueOf<MAPPING>>> & { [key in RESULT_PROP]?: { [Q in keyof FixOptionalProperties<{ [P in keyof MAPPING]: GuidedObj<RESULT>[MAPPING[P]] }>]: FixOptionalProperties<{ [P in keyof MAPPING]: GuidedObj<RESULT>[MAPPING[P]] }>[Q] }}>
}

export interface ComposeExpression<EXTERNAL_PROP extends keyof RESULT, INTERNAL_PROP extends string, RESULT_PROP extends string, TABLE extends ITableOrView<any>, COLUMNS, RESULT> {
    withNoneOrOne<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsert<TABLE, COLUMNS, RESULT & { [key in RESULT_PROP]?: INTERNAL }>
    withOne<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsert<TABLE, COLUMNS, RESULT & ( EXTERNAL_PROP extends RequiredKeysOfPickingColumns<COLUMNS> ? { [key in RESULT_PROP]: INTERNAL } : { [key in RESULT_PROP]?: INTERNAL })>
    withMany<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsert<TABLE, COLUMNS, RESULT & ( EXTERNAL_PROP extends RequiredKeysOfPickingColumns<COLUMNS> ? { [key in RESULT_PROP]: INTERNAL[] } : { [key in RESULT_PROP]?: INTERNAL[] })>
    withOptionalMany<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsert<TABLE, COLUMNS, RESULT & { [key in RESULT_PROP]?: INTERNAL[] }>
}
export interface ComposeExpressionDeletingInternalProperty<EXTERNAL_PROP extends keyof RESULT, INTERNAL_PROP extends string, RESULT_PROP extends string, TABLE extends ITableOrView<any>, COLUMNS, RESULT> {
    // Note: { [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] } is used to delete the internal prop because Omit<INTERNAL, INTERNAL_PROP> is not expanded in the editor (when see the type)
    withNoneOrOne<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsert<TABLE, COLUMNS, RESULT & { [key in RESULT_PROP]?: { [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] }}>
    withOne<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsert<TABLE, COLUMNS, RESULT & ( EXTERNAL_PROP extends RequiredKeysOfPickingColumns<COLUMNS> ? { [key in RESULT_PROP]: { [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] }} : { [key in RESULT_PROP]?: { [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] }} )>
    withMany<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsert<TABLE, COLUMNS, RESULT & ( EXTERNAL_PROP extends RequiredKeysOfPickingColumns<COLUMNS> ? { [key in RESULT_PROP]: Array<{ [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] }> } : { [key in RESULT_PROP]?: Array<{ [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] }> })>
    withOptionalMany<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsert<TABLE, COLUMNS, RESULT & { [key in RESULT_PROP]?: Array<{ [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] }> }>
}

export interface ComposeExpressionDeletingExternalProperty<EXTERNAL_PROP extends keyof RESULT, INTERNAL_PROP extends string, RESULT_PROP extends string, TABLE extends ITableOrView<any>, COLUMNS, RESULT> {
    withNoneOrOne<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsert<TABLE, COLUMNS, Omit<RESULT, EXTERNAL_PROP> & { [key in RESULT_PROP]?: INTERNAL }>
    withOne<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsert<TABLE, COLUMNS, Omit<RESULT, EXTERNAL_PROP> & ( EXTERNAL_PROP extends RequiredKeysOfPickingColumns<COLUMNS> ? { [key in RESULT_PROP]: INTERNAL } : { [key in RESULT_PROP]?: INTERNAL })>
    withMany<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsert<TABLE, COLUMNS, Omit<RESULT, EXTERNAL_PROP> & ( EXTERNAL_PROP extends RequiredKeysOfPickingColumns<COLUMNS> ? { [key in RESULT_PROP]: INTERNAL[] } : { [key in RESULT_PROP]?: INTERNAL[] })>
    withOptionalMany<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsert<TABLE, COLUMNS, Omit<RESULT, EXTERNAL_PROP> & { [key in RESULT_PROP]?: INTERNAL[] }>
}

export interface ComposableCustomizableExecutableInsert<TABLE extends ITableOrView<any>, COLUMNS, RESULT> extends ComposableExecutableInsert<TABLE, COLUMNS, RESULT> {
    customizeQuery(customization: InsertCustomization<TABLE[typeof database]>): ComposableExecutableInsert<TABLE, COLUMNS, RESULT>
}









export interface ExecutableInsertReturningOptional<TABLE extends ITableOrView<any>, COLUMNS, RESULT> extends InsertExpressionBase<TABLE>, IExecutableInsertQuery<TABLE, RESULT> {
    executeInsertNoneOrOne(): Promise<( COLUMNS extends AnyValueSource ? RESULT : { [P in keyof RESULT]: RESULT[P] }) | null>
    executeInsertMany(min?: number, max?: number): Promise<( COLUMNS extends AnyValueSource ? RESULT : { [P in keyof RESULT]: RESULT[P] })[]>

    query(): string
    params(): any[]
}

export interface ComposableExecutableInsertOptional<TABLE extends ITableOrView<any>, COLUMNS, RESULT> extends ExecutableInsertReturningOptional<TABLE, COLUMNS, RESULT> {
    compose<EXTERNAL_PROP extends keyof RESULT & ColumnGuard<COLUMNS>, INTERNAL_PROP extends string, RESULT_PROP extends string>(config: {
        externalProperty: EXTERNAL_PROP,
        internalProperty: INTERNAL_PROP,
        propertyName: RESULT_PROP
    }): ComposeExpressionOptional<EXTERNAL_PROP, INTERNAL_PROP, RESULT_PROP, TABLE, COLUMNS, RESULT>
    composeDeletingInternalProperty<EXTERNAL_PROP extends keyof RESULT & ColumnGuard<COLUMNS>, INTERNAL_PROP extends string, RESULT_PROP extends string>(config: {
        externalProperty: EXTERNAL_PROP,
        internalProperty: INTERNAL_PROP,
        propertyName: RESULT_PROP
    }): ComposeExpressionDeletingInternalPropertyOptional<EXTERNAL_PROP, INTERNAL_PROP, RESULT_PROP, TABLE, COLUMNS, RESULT>
    composeDeletingExternalProperty<EXTERNAL_PROP extends keyof RESULT & ColumnGuard<COLUMNS>, INTERNAL_PROP extends string, RESULT_PROP extends string>(config: {
        externalProperty: EXTERNAL_PROP,
        internalProperty: INTERNAL_PROP,
        propertyName: RESULT_PROP
    }): ComposeExpressionDeletingExternalPropertyOptional<EXTERNAL_PROP, INTERNAL_PROP, RESULT_PROP, TABLE, COLUMNS, RESULT>

    // Note: { [Q in keyof SelectResult<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>]: SelectResult<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>[Q] } is used to define the internal object because { [P in keyof MAPPING]: RESULT[MAPPING[P]] } doesn't respect the optional typing of the props
    splitRequired<RESULT_PROP extends string, MAPPED_PROPS extends keyof RESULT & ColumnGuard<COLUMNS>, MAPPING extends { [P: string]: MAPPED_PROPS }>(propertyName: RESULT_PROP, mappig: MAPPING): ComposableExecutableInsertOptional<TABLE, COLUMNS, Omit<RESULT, ValueOf<MAPPING>> & { [key in RESULT_PROP]: { [Q in keyof FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>]: FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>[Q] }}>
    splitOptional<RESULT_PROP extends string, MAPPED_PROPS extends keyof RESULT & ColumnGuard<COLUMNS>, MAPPING extends { [P: string]: MAPPED_PROPS }>(propertyName: RESULT_PROP, mappig: MAPPING): ComposableExecutableInsertOptional<TABLE, COLUMNS, Omit<RESULT, ValueOf<MAPPING>> & { [key in RESULT_PROP]?: { [Q in keyof FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>]: FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>[Q] }}>
    split<RESULT_PROP extends string, MAPPED_PROPS extends keyof RESULT & ColumnGuard<COLUMNS>, MAPPING extends { [P: string]: MAPPED_PROPS }>(propertyName: RESULT_PROP, mappig: MAPPING): ComposableExecutableInsertOptional<TABLE, COLUMNS, Omit<RESULT, ValueOf<MAPPING>> & ( {} extends FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }> ? { [key in RESULT_PROP]?: { [Q in keyof FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>]: FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>[Q] }} : { [key in RESULT_PROP]: { [Q in keyof FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>]: FixOptionalProperties<{ [P in keyof MAPPING]: RESULT[MAPPING[P]] }>[Q] }})>

    guidedSplitRequired<RESULT_PROP extends string, MAPPED_PROPS extends keyof GuidedObj<RESULT> & ColumnGuard<COLUMNS>, MAPPING extends { [P: string]: MAPPED_PROPS }>(propertyName: RESULT_PROP, mappig: MAPPING): ComposableExecutableInsertOptional<TABLE, COLUMNS, Omit<RESULT, GuidedPropName<ValueOf<MAPPING>>> & { [key in RESULT_PROP]: { [Q in keyof FixOptionalProperties<{ [P in keyof MAPPING]: GuidedObj<RESULT>[MAPPING[P]] }>]: FixOptionalProperties<{ [P in keyof MAPPING]: GuidedObj<RESULT>[MAPPING[P]] }>[Q] }}>
    guidedSplitOptional<RESULT_PROP extends string, MAPPED_PROPS extends keyof GuidedObj<RESULT> & ColumnGuard<COLUMNS>, MAPPING extends { [P: string]: MAPPED_PROPS }>(propertyName: RESULT_PROP, mappig: MAPPING): ComposableExecutableInsertOptional<TABLE, COLUMNS, Omit<RESULT, GuidedPropName<ValueOf<MAPPING>>> & { [key in RESULT_PROP]?: { [Q in keyof FixOptionalProperties<{ [P in keyof MAPPING]: GuidedObj<RESULT>[MAPPING[P]] }>]: FixOptionalProperties<{ [P in keyof MAPPING]: GuidedObj<RESULT>[MAPPING[P]] }>[Q] }}>
}

export interface ComposeExpressionOptional<EXTERNAL_PROP extends keyof RESULT, INTERNAL_PROP extends string, RESULT_PROP extends string, TABLE extends ITableOrView<any>, COLUMNS, RESULT> {
    withNoneOrOne<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, RESULT & { [key in RESULT_PROP]?: INTERNAL }>
    withOne<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, RESULT & ( EXTERNAL_PROP extends RequiredKeysOfPickingColumns<COLUMNS> ? { [key in RESULT_PROP]: INTERNAL } : { [key in RESULT_PROP]?: INTERNAL })>
    withMany<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, RESULT & ( EXTERNAL_PROP extends RequiredKeysOfPickingColumns<COLUMNS> ? { [key in RESULT_PROP]: INTERNAL[] } : { [key in RESULT_PROP]?: INTERNAL[] })>
    withOptionalMany<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, RESULT & { [key in RESULT_PROP]?: INTERNAL[] }>
}
export interface ComposeExpressionDeletingInternalPropertyOptional<EXTERNAL_PROP extends keyof RESULT, INTERNAL_PROP extends string, RESULT_PROP extends string, TABLE extends ITableOrView<any>, COLUMNS, RESULT> {
    // Note: { [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] } is used to delete the internal prop because Omit<INTERNAL, INTERNAL_PROP> is not expanded in the editor (when see the type)
    withNoneOrOne<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, RESULT & { [key in RESULT_PROP]?: { [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] }}>
    withOne<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, RESULT & ( EXTERNAL_PROP extends RequiredKeysOfPickingColumns<COLUMNS> ? { [key in RESULT_PROP]: { [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] }} : { [key in RESULT_PROP]?: { [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] }} )>
    withMany<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, RESULT & ( EXTERNAL_PROP extends RequiredKeysOfPickingColumns<COLUMNS> ? { [key in RESULT_PROP]: Array<{ [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] }> } : { [key in RESULT_PROP]?: Array<{ [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] }> })>
    withOptionalMany<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, RESULT & { [key in RESULT_PROP]?: Array<{ [P in keyof Omit<INTERNAL, INTERNAL_PROP>]: Omit<INTERNAL, INTERNAL_PROP>[P] }> }>
}

export interface ComposeExpressionDeletingExternalPropertyOptional<EXTERNAL_PROP extends keyof RESULT, INTERNAL_PROP extends string, RESULT_PROP extends string, TABLE extends ITableOrView<any>, COLUMNS, RESULT> {
    withNoneOrOne<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, Omit<RESULT, EXTERNAL_PROP> & { [key in RESULT_PROP]?: INTERNAL }>
    withOne<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, Omit<RESULT, EXTERNAL_PROP> & ( EXTERNAL_PROP extends RequiredKeysOfPickingColumns<COLUMNS> ? { [key in RESULT_PROP]: INTERNAL } : { [key in RESULT_PROP]?: INTERNAL })>
    withMany<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, Omit<RESULT, EXTERNAL_PROP> & ( EXTERNAL_PROP extends RequiredKeysOfPickingColumns<COLUMNS> ? { [key in RESULT_PROP]: INTERNAL[] } : { [key in RESULT_PROP]?: INTERNAL[] })>
    withOptionalMany<INTERNAL extends {[key in INTERNAL_PROP]: RESULT[EXTERNAL_PROP]}>(fn: (ids: Array<NonNullable<RESULT[EXTERNAL_PROP]>>) => Promise<INTERNAL[]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, Omit<RESULT, EXTERNAL_PROP> & { [key in RESULT_PROP]?: INTERNAL[] }>
}

export interface ComposableCustomizableExecutableInsertOptional<TABLE extends ITableOrView<any>, COLUMNS, RESULT> extends ComposableExecutableInsertOptional<TABLE, COLUMNS, RESULT> {
    customizeQuery(customization: InsertCustomization<TABLE[typeof database]>): ComposableExecutableInsertOptional<TABLE, COLUMNS, RESULT>
}







type ReturningFnType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | SqlServer | Sqlite | MariaDB | Oracle)
    ? <COLUMNS extends InsertColumns<TABLE>>(columns: COLUMNS) => ComposableCustomizableExecutableInsert<TABLE, COLUMNS, ResultObjectValues<COLUMNS>>
    : never

type ReturningOneColumnFnType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | SqlServer | Sqlite | MariaDB | Oracle)
    ? <COLUMN extends ValueSourceOf<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>>>(column: COLUMN) => ComposableCustomizableExecutableInsert<TABLE, COLUMN, ValueSourceValueTypeForResult<COLUMN>>
    : never

type ReturningFromSelectFnType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | SqlServer | Sqlite | MariaDB)
    ? <COLUMNS extends InsertColumns<TABLE>>(columns: COLUMNS) => ComposableCustomizableExecutableInsert<TABLE, COLUMNS, ResultObjectValues<COLUMNS>>
    : never

type ReturningOneColumnFromSelectFnType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | SqlServer | Sqlite | MariaDB)
    ? <COLUMN extends ValueSourceOf<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>>>(column: COLUMN) => ComposableCustomizableExecutableInsert<TABLE, COLUMN, ValueSourceValueTypeForResult<COLUMN>>
    : never

type ReturningMultipleLastInsertedIdType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | SqlServer | Oracle | Sqlite | MariaDB)
    ? [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>[]>
    : never

type ReturningLastInsertedIdType<TABLE extends ITableOrView<any>> =
    [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>>

type OnConflictReturningLastInsertedIdType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql /*| SqlServer | Oracle not suported yet*/ | Sqlite | MariaDB)
    ? [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>>
    : never

type ReturningLastInsertedIdFromSelectType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | SqlServer | Sqlite | MariaDB)
    ? [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>[]>
    : never




type ReturningOptionalFnType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | SqlServer | Sqlite | MariaDB | Oracle)
    ? <COLUMNS extends InsertColumns<TABLE>>(columns: COLUMNS) => ComposableCustomizableExecutableInsertOptional<TABLE, COLUMNS, ResultObjectValues<COLUMNS>>
    : never

type ReturningOneColumnOptionalFnType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | SqlServer | Sqlite | MariaDB | Oracle)
    ? <COLUMN extends ValueSourceOf<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>>>(column: COLUMN) => ComposableCustomizableExecutableInsertOptional<TABLE, COLUMN, ValueSourceValueTypeForResult<COLUMN> | null>
    : never

type ReturningFromSelectOptionalFnType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | SqlServer | Sqlite | MariaDB)
    ? <COLUMNS extends InsertColumns<TABLE>>(columns: COLUMNS) => ComposableCustomizableExecutableInsertOptional<TABLE, COLUMNS, ResultObjectValues<COLUMNS> | null>
    : never

type ReturningOneColumnFromSelectOptionalFnType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | SqlServer | Sqlite | MariaDB)
    ? <COLUMN extends ValueSourceOf<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>>>(column: COLUMN) => ComposableCustomizableExecutableInsertOptional<TABLE, COLUMN, ValueSourceValueTypeForResult<COLUMN> | null>
    : never

type ReturningMultipleLastInsertedIdOptionalType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | SqlServer | Oracle | Sqlite | MariaDB)
    ? [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>[]>
    : never

type OnConflictReturningLastInsertedIdOptionalType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql /*| SqlServer | Oracle not suported yet*/ | Sqlite | MariaDB)
    ? [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE> | null>
    : never

type ReturningLastInsertedIdFromSelectOptionalType<TABLE extends ITableOrView<any>> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | SqlServer | Sqlite | MariaDB)
    ? [AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>] extends [never] ? never : () =>  CustomizableExecutableInsertReturningLastInsertedId<TABLE, AutogeneratedPrimaryKeyColumnsTypesOf<TABLE>[]>
    : never





export interface InsertOnConflictSetsExpression<TABLE extends ITableOrView<any>, NEXT, NEXT_WHERE> {
    set(columns: OnConflictUpdateSets<TABLE, undefined>): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    setIfValue(columns: OnConflictOptionalUpdateSets<TABLE, undefined>): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    setIfSet(columns: OnConflictUpdateSets<TABLE, undefined>): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    setIfSetIfValue(columns: OnConflictOptionalUpdateSets<TABLE, undefined>): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    setIfNotSet(columns: OnConflictUpdateSets<TABLE, undefined>): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    setIfNotSetIfValue(columns: OnConflictOptionalUpdateSets<TABLE, undefined>): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    ignoreIfSet(...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    keepOnly(...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT

    setIfHasValue(columns: OnConflictUpdateSets<TABLE, undefined>): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    setIfHasValueIfValue(columns: OnConflictOptionalUpdateSets<TABLE, undefined>): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    setIfHasNoValue(columns: OnConflictUpdateSets<TABLE, undefined>): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    setIfHasNoValueIfValue(columns: OnConflictOptionalUpdateSets<TABLE, undefined>): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    ignoreIfHasValue(...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    ignoreIfHasNoValue(...columns: ColumnsForSetOf<TABLE>[]): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    ignoreAnySetWithNoValue(): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT

    dynamicWhere: OnConflictDoUpdateDynamicWhereFnType<TABLE, NEXT_WHERE>
    where: OnConflictDoUpdateWhereFnType<TABLE, NEXT_WHERE>
}

export interface ShapedInsertOnConflictSetsExpression<TABLE extends ITableOrView<any>, SHAPE, NEXT, NEXT_WHERE> {
    extendShape<EXTEND_SHAPE extends InsertShape<TABLE>>(shape: EXTEND_SHAPE): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE & ResolveShape<TABLE, EXTEND_SHAPE>, NEXT, NEXT_WHERE>
    set(columns: OnConflictUpdateSets<TABLE, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfValue(columns: OnConflictOptionalUpdateSets<TABLE, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfSet(columns: OnConflictUpdateSets<TABLE, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfSetIfValue(columns: OnConflictOptionalUpdateSets<TABLE, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfNotSet(columns: OnConflictUpdateSets<TABLE, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfNotSetIfValue(columns: OnConflictOptionalUpdateSets<TABLE, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    ignoreIfSet(...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    keepOnly(...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT

    setIfHasValue(columns: OnConflictUpdateSets<TABLE, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfHasValueIfValue(columns: OnConflictOptionalUpdateSets<TABLE, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfHasNoValue(columns: OnConflictUpdateSets<TABLE, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    setIfHasNoValueIfValue(columns: OnConflictOptionalUpdateSets<TABLE, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    ignoreIfHasValue(...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    ignoreIfHasNoValue(...columns: ColumnsForSetOfWithShape<TABLE, SHAPE>[]): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    ignoreAnySetWithNoValue(): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT

    dynamicWhere: OnConflictDoUpdateDynamicWhereFnType<TABLE, NEXT_WHERE>
    where: OnConflictDoUpdateWhereFnType<TABLE, NEXT_WHERE>
}

export interface DynamicOnConflictWhereExpression<TABLE extends ITableOrView<any>, NEXT> {
    and(condition: IIfValueSource<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>, any>): DynamicOnConflictWhereExpression<TABLE, NEXT> & NEXT
    and(condition: IBooleanValueSource<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>, any>): DynamicOnConflictWhereExpression<TABLE, NEXT> & NEXT
    or(condition: IIfValueSource<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>, any>): DynamicOnConflictWhereExpression<TABLE, NEXT> & NEXT
    or(condition: IBooleanValueSource<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>, any>): DynamicOnConflictWhereExpression<TABLE, NEXT> & NEXT
}

export interface OnConflictOnColumnWhere<TABLE extends ITableOrView<any>, NEXT> {
    dynamicWhere() : DynamicOnConflictWhereExpression<TABLE, NEXT> & NEXT
    where(condition: IIfValueSource<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>, any>): DynamicOnConflictWhereExpression<TABLE, NEXT> & NEXT
    where(condition: IBooleanValueSource<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>, any>): DynamicOnConflictWhereExpression<TABLE, NEXT> & NEXT
}

type OnConflictDoNothingFnType<TABLE extends ITableOrView<any>, NEXT> =
    TABLE[typeof database] extends (NoopDB | PostgreSql | Sqlite | MariaDB | MySql)
    ? () => NEXT
    : never

type OnConflictDoUpdateDynamicSetFn<TABLE extends ITableOrView<any>, NEXT, NEXT_WHERE> = {
    (): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
    (columns: OnConflictUpdateSets<TABLE, undefined>): InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
}

type ShapedOnConflictDoUpdateDynamicSetFn<TABLE extends ITableOrView<any>, SHAPE, NEXT, NEXT_WHERE> = {
    (): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
    (columns: OnConflictUpdateSets<TABLE, SHAPE>): ShapedInsertOnConflictSetsExpression<TABLE, SHAPE, NEXT, NEXT_WHERE> & NEXT
}

type OnConflictDoUpdateDynamicSetFnType<TABLE extends ITableOrView<any>, SHAPE, NEXT, NEXT_WHERE> =
        TABLE[typeof database] extends (NoopDB | PostgreSql | Sqlite | MariaDB | MySql)
        ? (
            SHAPE extends ResolvedShape<TABLE>
            ? ShapedOnConflictDoUpdateDynamicSetFn<TABLE, SHAPE, NEXT, NEXT_WHERE>
            : OnConflictDoUpdateDynamicSetFn<TABLE, NEXT, NEXT_WHERE>
        )
        : never

type OnConflictDoUpdateSetFnType<TABLE extends ITableOrView<any>, SHAPE, NEXT, NEXT_WHERE> =
        TABLE[typeof database] extends (NoopDB | PostgreSql | Sqlite | MariaDB | MySql)
        ? (columns: OnConflictUpdateSets<TABLE, SHAPE>) => InsertOnConflictSetsExpression<TABLE, NEXT, NEXT_WHERE> & NEXT
        : never

type OnConflictDoUpdateDynamicWhereFnType<TABLE extends ITableOrView<any>, NEXT> =
        TABLE[typeof database] extends (NoopDB | PostgreSql | Sqlite)
        ? () => DynamicOnConflictWhereExpression<TABLE, NEXT> & NEXT
        : never

type OnConflictDoUpdateWhereFnType<TABLE extends ITableOrView<any>, NEXT> =
        TABLE[typeof database] extends (NoopDB | PostgreSql | Sqlite)
        ? OnConflictDoUpdateWhereFnTypeInterface<TABLE, NEXT>
        : never

interface OnConflictDoUpdateWhereFnTypeInterface<TABLE extends ITableOrView<any>, NEXT> {
    (condition: IIfValueSource<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>, any>): DynamicOnConflictWhereExpression<TABLE, NEXT> & NEXT
    (condition: IBooleanValueSource<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>, any>): DynamicOnConflictWhereExpression<TABLE, NEXT> & NEXT
}

type OnConflictOnColumnFnType<TABLE extends ITableOrView<any>, NEXT> =
        TABLE[typeof database] extends (NoopDB | PostgreSql | Sqlite)
        ? (column: ValueSourceOf<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>>, ...columns: ValueSourceOf<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>>[]) => NEXT & OnConflictOnColumnWhere<TABLE, NEXT>
        : never

type OnConflictOnConstraintFnType<TABLE extends ITableOrView<any>, NEXT> =
        TABLE[typeof database] extends (NoopDB | PostgreSql)
        ? OnConflictOnConstraintFnTypeInterface<TABLE, NEXT>
        : never

interface OnConflictOnConstraintFnTypeInterface<TABLE extends ITableOrView<any>, NEXT> {
    (constraint: string): NEXT
    (constraint: TypeWhenSafeDB<TABLE[typeof database], IStringValueSource<NoTableOrViewRequired<TABLE[typeof database]>, 'required'>, ITypeSafeStringValueSource<NoTableOrViewRequired<TABLE[typeof database]>, 'required'>>): NEXT
    (constraint: RawFragment<TABLE[typeof database]>): NEXT
}







export type InsertColumns<TABLE extends ITableOrView<any>> = {
    [P: string]: ValueSourceOf<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>> | InsertColumns<TABLE>
    [P: number | symbol]: never
}







type DefaultValueType<TABLE extends ITableOrView<any>> =
    unknown extends TABLE ? () => CustomizableExecutableSimpleInsertOnConflict<TABLE> : // this is the case when TABLE is any
    [RequiredColumnsForSetOf<TABLE>] extends [never] ? () => CustomizableExecutableSimpleInsertOnConflict<TABLE> : never

type MaybeExecutableInsertExpression<TABLE extends ITableOrView<any>, MISSING_KEYS> =
    [MISSING_KEYS] extends [never] ? ExecutableInsertExpression<TABLE> :  MissingKeysInsertExpression<TABLE, MISSING_KEYS>

type MaybeShapedExecutableInsertExpression<TABLE extends ITableOrView<any>, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE> =
    [MISSING_KEYS] extends [never] 
    ? (
        [MISSING_KEYS_IN_SHAPE] extends [never] 
        ? ShapedExecutableInsertExpression<TABLE, SHAPE>
        : ShapedMissingKeysInsertExpression<TABLE, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ) : ShapedMissingKeysInsertExpression<TABLE, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>

type MaybeExecutableMultipleInsertExpression<TABLE extends ITableOrView<any>, MISSING_KEYS> =
    [MISSING_KEYS] extends [never] ? ExecutableMultipleInsertExpression<TABLE> :  MissingKeysMultipleInsertExpression<TABLE, MISSING_KEYS>

type MaybeShapedExecutableMultipleInsertExpression<TABLE extends ITableOrView<any>, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE> =
    [MISSING_KEYS] extends [never] 
    ? (
        [MISSING_KEYS_IN_SHAPE] extends [never] 
        ? ShapedExecutableMultipleInsertExpression<TABLE, SHAPE> 
        : ShapedMissingKeysMultipleInsertExpression<TABLE, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>
    ) : ShapedMissingKeysMultipleInsertExpression<TABLE, SHAPE, MISSING_KEYS, MISSING_KEYS_IN_SHAPE>

type SelectForInsertResultType<TABLE extends ITableOrView<any>> = {
    [P in RequiredColumnsForSetOf<TABLE>]: ValueSourceValueType<TABLE[P]>
} & {
    [P in OptionalColumnsForSetOf<TABLE>]?: ValueSourceValueType<TABLE[P]>
}

type SelectForInsertColumns<TABLE extends ITableOrView<any>> = {
    [P in RequiredColumnsForSetOf<TABLE>]: RemapIValueSourceType<any, TABLE[P]>
} & {
    [P in OptionalColumnsForSetOf<TABLE>]?: RemapIValueSourceTypeWithOptionalType<any, TABLE[P], any>
}

export type InsertShape<TABLE extends ITableOrView<any>> = {
    [key: string]: ColumnsForSetOf<TABLE>
}

export type InsertSets<TABLE extends ITableOrView<any>, SHAPE> = 
    SHAPE extends ResolvedShape<TABLE>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]?: InputTypeOfColumn<SHAPE, P>
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: InputTypeOfOptionalColumn<SHAPE, P>
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<TABLE>]?: InputTypeOfColumn<TABLE, P>
        } & {
            [P in OptionalColumnsForSetOf<TABLE>]?: InputTypeOfOptionalColumn<TABLE, P>
        }
    )

export type OptionalInsertSets<TABLE extends ITableOrView<any>, SHAPE> = 
    SHAPE extends ResolvedShape<TABLE>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]?: InputTypeOfColumn<SHAPE, P> | null | undefined
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: InputTypeOfOptionalColumn<SHAPE, P> | null | undefined
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<TABLE>]?: InputTypeOfColumn<TABLE, P> | null | undefined
        } & {
            [P in OptionalColumnsForSetOf<TABLE>]?: InputTypeOfOptionalColumn<TABLE, P> | null | undefined
        }
    )

export type MandatoryInsertSets<TABLE extends ITableOrView<any>, SHAPE> = 
    SHAPE extends ResolvedShape<TABLE>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]: InputTypeOfColumn<SHAPE, P>
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: InputTypeOfOptionalColumn<SHAPE, P>
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<TABLE>]: InputTypeOfColumn<TABLE, P>
        } & {
            [P in OptionalColumnsForSetOf<TABLE>]?: InputTypeOfOptionalColumn<TABLE, P>
        }
    )

export type MandatoryInsertValues<TABLE extends ITableOrView<any>, SHAPE> = 
    SHAPE extends ResolvedShape<TABLE>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]: ValueSourceValueType<SHAPE[P]>
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: ValueSourceValueType<SHAPE[P]>
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<TABLE>]: ValueSourceValueType<TABLE[P]>
        } & {
            [P in OptionalColumnsForSetOf<TABLE>]?: ValueSourceValueType<TABLE[P]>
        }
    )

type MandatoryOptionalInsertSets<TABLE extends ITableOrView<any>, SHAPE> = 
    SHAPE extends ResolvedShape<TABLE>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]: InputTypeOfColumn<SHAPE, P>
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: InputTypeOfOptionalColumn<SHAPE, P> | null | undefined
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<TABLE>]: InputTypeOfColumn<TABLE, P>
        } & {
            [P in OptionalColumnsForSetOf<TABLE>]?: InputTypeOfOptionalColumn<TABLE, P> | null | undefined
        }
    )

type InputTypeOfColumn<TABLE extends ITableOrView<any>, K extends ColumnsOf<TABLE>> =
    TABLE[K] extends ValueSourceOf<TABLE[typeof tableOrViewRef]> ?
    (TABLE[K] extends ColumnWithDefaultValue ? (
        ValueSourceValueType<TABLE[K]> | RemapIValueSourceType<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>, TABLE[K]> | Default
    ) : (
        ValueSourceValueType<TABLE[K]> | RemapIValueSourceType<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>, TABLE[K]>
    ))
    : never

type InputTypeOfOptionalColumn<TABLE extends ITableOrView<any>, K extends ColumnsOf<TABLE>> =
    TABLE[K] extends ValueSourceOf<TABLE[typeof tableOrViewRef]> ?
    (TABLE[K] extends ColumnWithDefaultValue ? (
        ValueSourceValueType<TABLE[K]> | RemapIValueSourceTypeWithOptionalType<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>, TABLE[K], any> | Default
    ) : (
        ValueSourceValueType<TABLE[K]> | RemapIValueSourceTypeWithOptionalType<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]>, TABLE[K], any>
    ))
    : never

export type OnConflictUpdateSets<TABLE extends ITableOrView<any>, SHAPE> = 
    SHAPE extends ResolvedShape<TABLE>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]?: OnConflictInputTypeOfColumn<SHAPE, P>
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: OnConflictInputTypeOfOptionalColumn<SHAPE, P>
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<TABLE>]?: OnConflictInputTypeOfColumn<TABLE, P>
        } & {
            [P in OptionalColumnsForSetOf<TABLE>]?: OnConflictInputTypeOfOptionalColumn<TABLE, P>
        }
    )

export type OnConflictUpdateValues<TABLE extends ITableOrView<any>, SHAPE> = 
    SHAPE extends ResolvedShape<TABLE>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]?: ValueSourceValueType<SHAPE[P]>
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: ValueSourceValueType<SHAPE[P]>
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<TABLE>]?: ValueSourceValueType<TABLE[P]>
        } & {
            [P in OptionalColumnsForSetOf<TABLE>]?: ValueSourceValueType<TABLE[P]>
        }
    )

type OnConflictOptionalUpdateSets<TABLE extends ITableOrView<any>, SHAPE> = 
    SHAPE extends ResolvedShape<TABLE>
    ? (
        {
            [P in RequiredColumnsForSetOf<SHAPE>]?: OnConflictInputTypeOfColumn<SHAPE, P> | null | undefined
        } & {
            [P in OptionalColumnsForSetOf<SHAPE>]?: OnConflictInputTypeOfOptionalColumn<SHAPE, P> | null | undefined
        }
    ) : (
        {
            [P in RequiredColumnsForSetOf<TABLE>]?: OnConflictInputTypeOfColumn<TABLE, P> | null | undefined
        } & {
            [P in OptionalColumnsForSetOf<TABLE>]?: OnConflictInputTypeOfOptionalColumn<TABLE, P> | null | undefined
        }
    )

type OnConflictInputTypeOfColumn<TABLE extends ITableOrView<any>, K extends ColumnsOf<TABLE>> =
    TABLE[K] extends ValueSourceOf<TABLE[typeof tableOrViewRef]> ?
    (TABLE[K] extends ColumnWithDefaultValue ? (
        ValueSourceValueType<TABLE[K]> | RemapIValueSourceType<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]> | VALUES_FOR_INSERT<TABLE[typeof tableOrViewRef]>, TABLE[K]> | Default
    ) : (
        ValueSourceValueType<TABLE[K]> | RemapIValueSourceType<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]> | VALUES_FOR_INSERT<TABLE[typeof tableOrViewRef]>, TABLE[K]>
    ))
    : never

type OnConflictInputTypeOfOptionalColumn<TABLE extends ITableOrView<any>, K extends ColumnsOf<TABLE>> =
    TABLE[K] extends ValueSourceOf<TABLE[typeof tableOrViewRef]> ?
    (TABLE[K] extends ColumnWithDefaultValue ? (
        ValueSourceValueType<TABLE[K]> | RemapIValueSourceTypeWithOptionalType<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]> | VALUES_FOR_INSERT<TABLE[typeof tableOrViewRef]>, TABLE[K], any> | Default
    ) : (
        ValueSourceValueType<TABLE[K]> | RemapIValueSourceTypeWithOptionalType<TABLE[typeof tableOrViewRef] | NoTableOrViewRequired<TABLE[typeof database]> | VALUES_FOR_INSERT<TABLE[typeof tableOrViewRef]>, TABLE[K], any>
    ))
    : never
