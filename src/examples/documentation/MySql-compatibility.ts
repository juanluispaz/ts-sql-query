import { MySqlConnection } from "../../connections/MySqlConnection"
import { DynamicCondition, dynamicPick } from "../../dynamicCondition"
import { extractColumnsFrom, mapForGuidedSplit, mergeType, prefixCapitalized, prefixDotted, prefixMapForGuidedSplitCapitalized, prefixMapForGuidedSplitDotted, prefixMapForSplitCapitalized, prefixMapForSplitDotted } from "../../extras/utils"
import { ConsoleLogQueryRunner } from "../../queryRunners/ConsoleLogQueryRunner"
import { MockQueryRunner } from "../../queryRunners/MockQueryRunner"
import { Table } from "../../Table"
import { CustomBooleanTypeAdapter } from "../../TypeAdapter"
import { View } from "../../View"
import { assertEquals } from "../assertEquals"

class DBConection extends MySqlConnection<'DBConnection'> { 
    // insesitiveCollation = 'acs'
    compatibilityMode = true

    bitwiseShiftLeft = this.buildFragmentWithArgs(
        this.arg('int', 'required'),
        this.arg('int', 'required')
    ).as((left, right) => {
        // The fragment here is: ${left} << ${right}
        // Could be another fragment like a function call: myFunction(${left}, ${right})
        return this.fragmentWithType('int', 'required').sql`${left} << ${right}`
    })

    valuePlusOneEqualsIfValue = this.buildFragmentWithArgsIfValue(
        this.arg('int', 'required'),
        this.valueArg('int', 'optional')
    ).as((left, right) => {
        // The fragment here is: ${left} + 1 = ${right}
        // Could be another fragment like a function call: myFunction(${left}, ${right})
        return this.fragmentWithType('boolean', 'required').sql`${left} + 1 = ${right}`
    })

    forSystemTimeBetween = this.createTableOrViewCustomization<Date, Date>((table, alias, fromDate, toDate) => {
        const from = this.const(fromDate, 'localDateTime')
        const to = this.const(toDate, 'localDateTime')
        return this.rawFragment`${table} for system_time between ${from} and ${to} ${alias}`
    })
}

const tCompany = new class TCompany extends Table<DBConection, 'TCompany'> {
    id = this.autogeneratedPrimaryKey('id', 'int')
    name = this.column('name', 'string')
    parentId = this.optionalColumn('parent_id', 'int')
    ubicationLatitude = this.optionalColumn('ubication_latitude', 'string')
    ubicationLongitude = this.optionalColumn('ubication_longitude', 'string')
    ubicationComment = this.optionalColumn('ubication_comment', 'string')
    constructor() {
        super('company'); // table name in the database
    }
}()

const tCustomer = new class TCustomer extends Table<DBConection, 'TCustomer'> {
    id = this.autogeneratedPrimaryKey('id', 'int')
    firstName = this.column('first_name', 'string')
    lastName = this.column('last_name', 'string')
    birthday = this.optionalColumn('birthday', 'localDate')
    companyId = this.column('company_id', 'int')
    constructor() {
        super('customer'); // table name in the database
    }
}()

const vCustomerAndCompany = new class VCustomerAndCompany extends View<DBConection, 'VCustomerAndCompany'> {
    companyId = this.column('company_id', 'int')
    companyName = this.column('company_name', 'string')
    customerId = this.column('customer_id', 'int')
    customerFirstName = this.column('customer_first_name', 'string')
    customerLastName = this.column('customer_last_name', 'string')
    customerBirthday = this.optionalColumn('customer_birthday', 'localDate')
    constructor() {
        super('customer_company')
    }
}()
vCustomerAndCompany.as('testView')

const tCustomCompany = new class TCustomCompany extends Table<DBConection, 'TCustomCompany'> {
    id = this.autogeneratedPrimaryKey('id', 'int');
    name = this.column('name', 'string');
    isBig = this.column('is_big', 'boolean', new CustomBooleanTypeAdapter('Y', 'N'));
    constructor() {
        super('custom_company'); // table name in the database
    }
}()

const tRecord = new class TRecord extends Table<DBConection, 'TRecord'> {
    id = this.primaryKey('id', 'uuid');
    title = this.column('title', 'string');
    constructor() {
        super('record'); // table name in the database
    }
}()

async function main() {
    let result: any
    const expectedResult: any[] = []
    const expectedQuery: string[] = []
    const expectedParams: string[] = []
    const expectedType: string[] = []
    const mockQueryRunner = new MockQueryRunner(
        (type, query, params, index) => {
            assertEquals(query, expectedQuery[index])
            assertEquals(JSON.stringify(params), expectedParams[index])
            assertEquals(type, expectedType[index])
            return expectedResult[index]
        }
    )

    const connection = new DBConection(new ConsoleLogQueryRunner(mockQueryRunner))

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, parent_id as parentId, ubication_latitude as `ubication.latitude`, ubication_longitude as `ubication.longitude`, ubication_comment as `ubication.comment` from company")
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const companies = await connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId,
            ubication: {
                latitude: tCompany.ubicationLatitude.asRequiredInOptionalObject(),
                longitude: tCompany.ubicationLongitude.asRequiredInOptionalObject(),
                comment: tCompany.ubicationComment
            }
        })
        .executeSelectMany()
    
    assertEquals(companies, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const customerId = 10
    
    const customerWithId = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(customerId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .executeSelectOne()
    
    assertEquals(customerWithId, result)

    /* *** Preparation ************************************************************/

    result = [{
        id: 1,
        name: {
            firstName: 'First Name',
            lastName: 'Last Name'
        }
    }]
    expectedResult.push([{
        id: 1,
        'name.firstName': 'First Name',
        'name.lastName': 'Last Name'
    }])
    expectedQuery.push("select id as id, first_name as `name.firstName`, last_name as `name.lastName`, birthday as birthday from customer where company_id = ? order by `name.firstName`, `name.lastName`")
    expectedParams.push(`[24]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const companyId = 24

    const customersOfCompany = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.equals(companyId))
        .select({
            id: tCustomer.id,
            name: {
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
            },
            birthday: tCustomer.birthday
        })
        .orderBy('name.firstName')
        .orderBy('name.lastName')
        .executeSelectMany()
    
    assertEquals(customersOfCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as id, concat(first_name, ?, last_name) as `name`, birthday as birthday from customer where first_name like concat('%', ?, '%') order by lower(`name`), birthday is null, birthday asc")
    expectedParams.push(`[" ","ohn"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const firstNameContains = 'ohn'
    const lastNameContains = null
    const birthdayIs = null
    const searchOrderBy = 'name insensitive, birthday asc nulls last'
    
    const searchedCustomers = await connection.selectFrom(tCustomer)
        .where(
                    tCustomer.firstName.containsIfValue(firstNameContains)
                .or(tCustomer.lastName.containsIfValue(lastNameContains))
            ).and(
                tCustomer.birthday.equalsIfValue(birthdayIs)
            )
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            birthday: tCustomer.birthday
        })
        .orderByFromString(searchOrderBy)
        .executeSelectMany()
    
    assertEquals(searchedCustomers, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as id, concat(first_name, ?, last_name) as `name`, birthday as birthday from customer where first_name like concat('%', ?, '%') order by lower(`name`), birthday is null, birthday asc")
    expectedParams.push(`[" ","ohn"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    let searchedCustomersWhere = connection.dynamicBooleanExpressionUsing(tCustomer)
    if (firstNameContains) {
        searchedCustomersWhere = searchedCustomersWhere.and(tCustomer.firstName.contains(firstNameContains))
    }
    if (lastNameContains) {
        searchedCustomersWhere = searchedCustomersWhere.or(tCustomer.lastName.contains(lastNameContains))
    }
    if (birthdayIs) {
        searchedCustomersWhere = searchedCustomersWhere.and(tCustomer.birthday.equals(birthdayIs))
    }
    
    const searchedCustomers2 = await connection.selectFrom(tCustomer)
        .where(searchedCustomersWhere)
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            birthday: tCustomer.birthday
        })
        .orderByFromString(searchOrderBy)
        .executeSelectMany()
    
    assertEquals(searchedCustomers2, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as id, concat(first_name, ?, last_name) as `name`, birthday as birthday from customer where first_name like concat('%', ?, '%') order by lower(`name`), birthday is null, birthday asc")
    expectedParams.push(`[" ","ohn"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const hideId = false

    let searchedCustomersWhere3
    if (firstNameContains) {
        searchedCustomersWhere3 = tCustomer.firstName.contains(firstNameContains)
    } else {
        searchedCustomersWhere3 = connection.noValueBoolean()
    }
    if (lastNameContains) {
        searchedCustomersWhere3 = mergeType(searchedCustomersWhere3).or(tCustomer.lastName.contains(lastNameContains))
    }
    if (birthdayIs) {
        searchedCustomersWhere3 = mergeType(searchedCustomersWhere3).and(tCustomer.birthday.equals(birthdayIs))
    }
    searchedCustomersWhere3 = mergeType(searchedCustomersWhere3)
    
    let idColumn
    if (hideId) {
        idColumn = connection.optionalConst(null, 'int')
    } else {
        idColumn = tCustomer.id
    }
    idColumn = mergeType(idColumn)
    
    const searchedCustomers3 = await connection.selectFrom(tCustomer)
        .where(searchedCustomersWhere3)
        .select({
            id: idColumn,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            birthday: tCustomer.birthday
        })
        .orderByFromString(searchOrderBy)
        .executeSelectMany()
    
    assertEquals(searchedCustomers3, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, comp.`name` as companyName from customer inner join company as comp on customer.company_id = comp.id where lower(customer.first_name) like concat(lower(?), '%') order by lower(firstName), lower(lastName) asc")
    expectedParams.push(`["John"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const firstName = 'John'
    const lastName = null
    
    const company = tCompany.as('comp')
    const customersWithCompanyName = await connection.selectFrom(tCustomer)
        .innerJoin(company).on(tCustomer.companyId.equals(company.id))
        .where(tCustomer.firstName.startsWithInsensitive(firstName))
            .and(tCustomer.lastName.startsWithInsensitiveIfValue(lastName))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday,
            companyName: company.name
        })
        .orderBy('firstName', 'insensitive')
        .orderBy('lastName', 'asc insensitive')
        .executeSelectMany()
    
    assertEquals(customersWithCompanyName, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as customerId, first_name as customerFirstName, last_name as customerLastName from customer where company_id in (select id as result from company where `name` like concat('%', ?, '%')) order by customerFirstName asc, customerLastName")
    expectedParams.push(`["Cia."]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/
    
    const orderBy = 'customerFirstName asc nulls first, customerLastName'
    const customerWithSelectedCompanies = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.in(
            connection.selectFrom(tCompany)
                .where(tCompany.name.contains('Cia.'))
                .selectOneColumn(tCompany.id)
        )).select({
            customerId: tCustomer.id,
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        }).orderByFromString(orderBy)
        .executeSelectMany()
    
    assertEquals(customerWithSelectedCompanies, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select company.id as companyId, company.`name` as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.`name`")
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompany = await connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        }).groupBy('companyId', 'companyName')
        .executeSelectMany()
    
    assertEquals(customerCountPerCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select company.id as companyId, company.`name` as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.`name`")
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompany2 = await connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .groupBy(tCompany.id, tCompany.name)
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        })
        .executeSelectMany()
    
    assertEquals(customerCountPerCompany2, result)
    
    /* *** Preparation ************************************************************/

    result = {
        data: [],
        count: 0
    }
    expectedResult.push([])
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName from customer where lower(first_name) like concat(lower(?), '%') or lower(last_name) like concat(lower(?), '%') order by firstName, lastName limit ? offset ?`)
    expectedParams.push(`["Smi","Smi",10,20]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push(0)
    expectedQuery.push(`select count(*) from customer where lower(first_name) like concat(lower(?), '%') or lower(last_name) like concat(lower(?), '%')`)
    expectedParams.push(`["Smi","Smi"]`)
    expectedType.push(`selectOneColumnOneRow`)
    
    /* *** Example ****************************************************************/

    const customerName = 'Smi'
    const customerPageWithName = await connection.selectFrom(tCustomer)
        .where(
            tCustomer.firstName.startsWithInsensitive(customerName)
        ).or(
            tCustomer.lastName.startsWithInsensitive(customerName)
        ).select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .orderBy('firstName')
        .orderBy('lastName')
        .limit(10)
        .offset(20)
        .executeSelectPage()
    
    assertEquals(customerPageWithName, result)
    
    /* *** Preparation ************************************************************/

    result = null
    expectedResult.push(result)
    expectedQuery.push("select id::varchar as idAsString, concat(first_name, ?, last_name) as `name` from customer where !!id = !!?")
    expectedParams.push(`[" ",10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const id = 10
    const customersUsingCustomFragment = await connection.selectFrom(tCustomer)
        .where(connection.fragmentWithType('boolean', 'required').sql`!!${tCustomer.id} = !!${connection.const(id, 'int')}`)
        .select({
            idAsString: connection.fragmentWithType('string', 'required').sql`${tCustomer.id}::varchar`,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName)
        })
        .executeSelectNoneOrOne()
    
    assertEquals(customersUsingCustomFragment, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, id << ? as idMultiplyBy2 from company where (id * ?) = (id << ?)")
    expectedParams.push(`[1,2,1]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const bitwiseMovements = 1
    const multiplier = 2
    const companiesUsingCustomFunctionFragment = await connection.selectFrom(tCompany)
        .where(tCompany.id.multiply(multiplier).equals(connection.bitwiseShiftLeft(tCompany.id, bitwiseMovements)))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            idMultiplyBy2: connection.bitwiseShiftLeft(tCompany.id, bitwiseMovements)
        })
        .executeSelectMany()
    
    assertEquals(companiesUsingCustomFunctionFragment, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name` from company where id + 1 = ?")
    expectedParams.push(`[2]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const noValue = null
    const withValue = 2
    const companiesUsingCustomFunctionFragmentIfValue = await connection.selectFrom(tCompany)
        .where(connection.valuePlusOneEqualsIfValue(tCompany.id, noValue))
            .or(connection.valuePlusOneEqualsIfValue(tCompany.id, withValue))
        .select({
            id: tCompany.id,
            name: tCompany.name,
        })
        .executeSelectMany()
    
    assertEquals(companiesUsingCustomFunctionFragmentIfValue, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id, birthday) values (?, ?, ?, ?)`)
    expectedParams.push(`["John","Smith",1,"2000-03-01T00:00:00.000Z"]`)
    expectedType.push(`insertReturningLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const insertCustomer = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }).setIfNotSet({
            birthday: new Date('2000-03-01')
        }).returningLastInsertedId()
        .executeInsert()
    
    assertEquals(insertCustomer, result)
    
    // Example not supported
    // /* *** Preparation ************************************************************/

    // result = [2, 3]
    // expectedResult.push(result)
    // expectedQuery.push(`insert into customer (first_name, last_name, company_id) values (?, ?, ?), (?, ?, ?) returning id`)
    // expectedParams.push(`["John","Smith",1,"Other","Person",1]`)
    // expectedType.push(`insertReturningMultipleLastInsertedId`)
    
    // /* *** Example ****************************************************************/

    // const valuesToInsert = [
    //     {
    //         firstName: 'John',
    //         lastName: 'Smith',
    //         companyId: 1
    //     },
    //     {
    //         firstName: 'Other',
    //         lastName: 'Person',
    //         companyId: 1
    //     }
    // ]
    
    // const insertMultipleCustomers = await connection.insertInto(tCustomer)
    //     .values(valuesToInsert)
    //     .returningLastInsertedId()
    //     .executeInsert();
    
    // assertEquals(insertMultipleCustomers, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into customer (first_name, last_name, company_id) select first_name as firstName, last_name as lastName, company_id as companyId from customer where company_id = ?`)
    expectedParams.push(`[1]`)
    expectedType.push(`insert`)
    
    /* *** Example ****************************************************************/

    const insertCustomersFromSelect = await connection.insertInto(tCustomer)
        .from(
            connection.selectFrom(tCustomer)
            .where(
                tCustomer.companyId.equals(1)
            )
            .select({
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                companyId: tCustomer.companyId
            })
        )
        .executeInsert();
    
    assertEquals(insertCustomersFromSelect, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update customer set first_name = ?, last_name = ? where id = ?`)
    expectedParams.push(`["John","Smith",10]`)
    expectedType.push(`update`)
    
    /* *** Example ****************************************************************/

    const updateCustomer = await connection.update(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('2000-03-01')
        }).ignoreIfSet('birthday')
        .where(tCustomer.id.equals(10))
        .executeUpdate()
    
    assertEquals(updateCustomer, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`delete from customer where id = ?`)
    expectedParams.push(`[10]`)
    expectedType.push(`delete`)
    
    /* *** Example ****************************************************************/

    const deleteCustomer = await connection.deleteFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .executeDelete()
    
    assertEquals(deleteCustomer, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select customerCountPerCompany.companyId as acmeCompanyId, customerCountPerCompany.companyName as acmeCompanyName, customerCountPerCompany.customerCount as acmeCustomerCount from (select company.id as companyId, company.`name` as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.`name`) as customerCountPerCompany where lower(customerCountPerCompany.companyName) like concat('%', lower(?), '%')")
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerCountPerCompanyWith = connection.selectFrom(tCompany)
        .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
        .select({
            companyId: tCompany.id,
            companyName: tCompany.name,
            customerCount: connection.count(tCustomer.id)
        }).groupBy('companyId', 'companyName')
        .forUseInQueryAs('customerCountPerCompany')
    
    const customerCountPerAcmeCompanies = await connection.selectFrom(customerCountPerCompanyWith)
        .where(customerCountPerCompanyWith.companyName.containsInsensitive('ACME'))
        .select({
            acmeCompanyId: customerCountPerCompanyWith.companyId,
            acmeCompanyName: customerCountPerCompanyWith.companyName,
            acmeCustomerCount: customerCountPerCompanyWith.customerCount
        })
        .executeSelectMany()
    
    assertEquals(customerCountPerAcmeCompanies, result)
    
    /* *** Preparation ************************************************************/
    
    result = 1
    expectedResult.push(result)
    expectedQuery.push("insert into custom_company (`name`, is_big) values (?, case when ? then 'Y' else 'N' end)")
    expectedParams.push(`["My Big Company",true]`)
    expectedType.push(`insertReturningLastInsertedId`)
    
    /* *** Example ****************************************************************/

    const insertCustomCompany = await connection.insertInto(tCustomCompany).set({
            name: 'My Big Company',
            isBig: true
        }).returningLastInsertedId()
        .executeInsert()
    
    assertEquals(insertCustomCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, (is_big = 'Y') as isBig from custom_company where is_big = 'Y'")
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const selectAllBigCompanies = await connection.selectFrom(tCustomCompany)
        .where(tCustomCompany.isBig)
        .select({
            id: tCustomCompany.id,
            name: tCustomCompany.name,
            isBig: tCustomCompany.isBig
        }).executeSelectMany()
    
    assertEquals(selectAllBigCompanies, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, company.`name` as companyName from customer inner join company on customer.company_id = company.id where (lower(customer.first_name) like concat(lower(?), '%') or (lower(customer.last_name) like concat(lower(?), '%') and customer.last_name like concat('%', ?))) and company.`name` = ? order by lower(firstName), lower(lastName) asc")
    expectedParams.push(`["John","Smi","th","ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    type FilterType = DynamicCondition<{
        id: 'int',
        firstName: 'string',
        lastName: 'string',
        birthday: 'localDate',
        companyName: 'string'
    }>
    
    const filter: FilterType = {
        or: [
            { firstName: { startsWithInsensitive: 'John' } },
            { lastName: { startsWithInsensitiveIfValue: 'Smi', endsWith: 'th' } }
        ],
        companyName: {equals: 'ACME'}
    }
    
    const selectFields = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyName: tCompany.name
    }
    
    const dynamicWhere = connection.dynamicConditionFor(selectFields).withValues(filter)
    
    const customersWithDynamicCondition = await connection.selectFrom(tCustomer)
        .innerJoin(tCompany).on(tCustomer.companyId.equals(tCompany.id))
        .where(dynamicWhere)
        .select(selectFields)
        .orderBy('firstName', 'insensitive')
        .orderBy('lastName', 'asc insensitive')
        .executeSelectMany()
    
    assertEquals(customersWithDynamicCondition, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select customer.id as id, customer.first_name as `name.firstName`, customer.last_name as `name.lastName`, customer.birthday as birthday, company.id as `company.id`, company.`name` as `company.name` from customer inner join company on customer.company_id = company.id where (lower(customer.first_name) like concat(lower(?), '%') or (lower(customer.last_name) like concat(lower(?), '%') and customer.last_name like concat('%', ?))) and company.`name` = ? order by lower(`name.firstName`), lower(`name.lastName`) asc")
    expectedParams.push(`["John","Smi","th","ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    type FilterType2 = DynamicCondition<{
        id: 'int',
        name: {
            firstName: 'string',
            lastName: 'string',
        }
        birthday: 'localDate',
        company: {
            id: 'int'
            name: 'string'
        }
    }>

    const filter2: FilterType2 = {
        or: [
            { name: { firstName: { startsWithInsensitive: 'John' } } },
            { name: { lastName: { startsWithInsensitiveIfValue: 'Smi', endsWith: 'th' } } }
        ],
        company: {
            name: { equals: 'ACME' }
        }
    }
    
    const selectFields2 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday,
        company: {
            id: tCompany.id,
            name: tCompany.name
        }
    }
    
    const dynamicWhere2 = connection.dynamicConditionFor(selectFields2).withValues(filter2)
    
    const customersWithDynamicCondition2 = await connection.selectFrom(tCustomer)
        .innerJoin(tCompany).on(tCustomer.companyId.equals(tCompany.id))
        .where(dynamicWhere2)
        .select(selectFields2)
        .orderBy('name.firstName', 'insensitive')
        .orderBy('name.lastName', 'asc insensitive')
        .executeSelectMany()
    
    assertEquals(customersWithDynamicCondition2, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as id, concat(first_name, ?, last_name) as `name`, ? as `type` from customer union all select id as id, `name` as `name`, ? as `type` from company")
    expectedParams.push(`[" ","customer","company"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const allDataWithName = await connection.selectFrom(tCustomer)
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
            type: connection.const<'customer' | 'company'>('customer', 'enum', 'customerOrCompany')
        }).unionAll(
            connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name,
                type: connection.const<'customer' | 'company'>('company', 'enum', 'customerOrCompany')
            })
        ).executeSelectMany()
    
    assertEquals(allDataWithName, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 10,
        name: 'ACME Inc.',
        customers: [{
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14Z')
        }, {
            id: 13,
            firstName: 'Jorge',
            lastName: 'Justo',
            birthday: new Date('1991/2/16Z')
        }]
    }, {
        id: 11,
        name: 'ACME Corp.',
        customers: [{
            id: 14,
            firstName: 'Maria',
            lastName: 'Rodriguez',
            birthday: new Date('1992/3/18Z')
        }]
    }]
    expectedResult.push([{
        id: 10,
        name: 'ACME Inc.'
    }, {
        id: 11,
        name: 'ACME Corp.'
    }])
    expectedQuery.push("select id as id, `name` as `name` from company where lower(`name`) like concat('%', lower(?), '%')")
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push([{
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14Z'),
        companyId: 10
    }, {
        id: 13,
        firstName: 'Jorge',
        lastName: 'Justo',
        birthday: new Date('1991/2/16Z'),
        companyId: 10
    }, {
        id: 14,
        firstName: 'Maria',
        lastName: 'Rodriguez',
        birthday: new Date('1992/3/18Z'),
        companyId: 11
    }])
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where company_id in (?, ?)`)
    expectedParams.push(`[10,11]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const companiesWithCustomers = await connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name
            }).where(
                tCompany.name.containsInsensitive('ACME')
            ).composeDeletingInternalProperty({
                externalProperty: 'id',
                internalProperty: 'companyId',
                propertyName: 'customers'
            }).withMany((ids) => {
                return connection.selectFrom(tCustomer)
                    .select({
                        id: tCustomer.id,
                        firstName: tCustomer.firstName,
                        lastName: tCustomer.lastName,
                        birthday: tCustomer.birthday,
                        companyId: tCustomer.companyId
                    }).where(
                        tCustomer.companyId.in(ids)
                    ).executeSelectMany()
            }).executeSelectMany()
    
    assertEquals(companiesWithCustomers, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 10,
        name: 'ACME Inc.',
        customers: [{
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14Z')
        }, {
            id: 13,
            firstName: 'Jorge',
            lastName: 'Justo',
            birthday: new Date('1991/2/16Z')
        }]
    }, {
        id: 11,
        name: 'ACME Corp.'
    }]
    expectedResult.push([{
        id: 10,
        name: 'ACME Inc.'
    }, {
        id: 11,
        name: 'ACME Corp.'
    }])
    expectedQuery.push("select id as id, `name` as `name` from company where lower(`name`) like concat('%', lower(?), '%')")
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push([{
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14Z'),
        companyId: 10
    }, {
        id: 13,
        firstName: 'Jorge',
        lastName: 'Justo',
        birthday: new Date('1991/2/16Z'),
        companyId: 10
    }])
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where company_id in (?, ?)`)
    expectedParams.push(`[10,11]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const companiesWithCustomers2 = await connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name
            }).where(
                tCompany.name.containsInsensitive('ACME')
            ).composeDeletingInternalProperty({
                externalProperty: 'id',
                internalProperty: 'companyId',
                propertyName: 'customers'
            }).withOptionalMany((ids) => {
                return connection.selectFrom(tCustomer)
                    .select({
                        id: tCustomer.id,
                        firstName: tCustomer.firstName,
                        lastName: tCustomer.lastName,
                        birthday: tCustomer.birthday,
                        companyId: tCustomer.companyId
                    }).where(
                        tCustomer.companyId.in(ids)
                    ).executeSelectMany()
            }).executeSelectMany()
    
    assertEquals(companiesWithCustomers2, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 10,
        name: 'ACME Inc.',
        customers: [{
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14Z')
        }, {
            id: 13,
            firstName: 'Jorge',
            lastName: 'Justo',
            birthday: new Date('1991/2/16Z')
        }]
    }, {
        id: 11,
        name: 'ACME Corp.',
        customers: []
    }]
    expectedResult.push([{
        id: 10,
        name: 'ACME Inc.'
    }, {
        id: 11,
        name: 'ACME Corp.'
    }])
    expectedQuery.push("select id as id, `name` as `name` from company where lower(`name`) like concat('%', lower(?), '%')")
    expectedParams.push(`["ACME"]`)
    expectedType.push(`selectManyRows`)
    expectedResult.push([{
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14Z'),
        companyId: 10
    }, {
        id: 13,
        firstName: 'Jorge',
        lastName: 'Justo',
        birthday: new Date('1991/2/16Z'),
        companyId: 10
    }])
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where company_id in (?, ?)`)
    expectedParams.push(`[10,11]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const companiesWithCustomers3 = await connection.selectFrom(tCompany)
            .select({
                id: tCompany.id,
                name: tCompany.name
            }).where(
                tCompany.name.containsInsensitive('ACME')
            ).composeDeletingInternalProperty({
                externalProperty: 'id',
                internalProperty: 'companyId',
                propertyName: 'customers'
            }).withMany((ids) => {
                return connection.selectFrom(tCustomer)
                    .select({
                        id: tCustomer.id,
                        firstName: tCustomer.firstName,
                        lastName: tCustomer.lastName,
                        birthday: tCustomer.birthday,
                        companyId: tCustomer.companyId
                    }).where(
                        tCustomer.companyId.in(ids)
                    ).executeSelectMany()
            }).executeSelectMany()
    
    assertEquals(companiesWithCustomers3, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        companyId: 10
    })
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    expectedResult.push([{
        id: 10,
        name: 'ACME Inc.'
    }])
    expectedQuery.push("select id as id, `name` as `name` from company where id in (?)")
    expectedParams.push(`[10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerWithCompany = await connection.selectFrom(tCustomer)
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                birthday: tCustomer.birthday,
                companyId: tCustomer.companyId
            }).where(
                tCustomer.id .equals(12)
            ).composeDeletingExternalProperty({
                externalProperty: 'companyId',
                internalProperty: 'id',
                propertyName: 'company'
            }).withOne((ids) => {
                return connection.selectFrom(tCompany)
                    .select({
                        id: tCompany.id,
                        name: tCompany.name
                    }).where(
                        tCompany.id.in(ids)
                    ).executeSelectMany()
            }).executeSelectOne()
    
    assertEquals(customerWithCompany, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        companyId: 10,
        companyName: 'ACME Inc.'
    })
    expectedQuery.push("select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, company.id as companyId, company.`name` as companyName from customer inner join company on company.id = customer.company_id where customer.id = ?")
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customerWithCompanyInOneQuery = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                birthday: tCustomer.birthday,
                companyId: tCompany.id,
                companyName: tCompany.name
            }).where(
                tCustomer.id .equals(12)
            ).split('company', {
                id: 'companyId',
                name: 'companyName'
            }).executeSelectOne()

    assertEquals(customerWithCompanyInOneQuery, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        'company.id': 10,
        'company.name': 'ACME Inc.'
    })
    expectedQuery.push("select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, company.id as `company.id`, company.`name` as `company.name` from customer inner join company on company.id = customer.company_id where customer.id = ?")
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customerWithCompanyInOneQuery2 = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName,
                birthday: tCustomer.birthday,
                company: {
                    id: tCompany.id,
                    name: tCompany.name
                }
            }).where(
                tCustomer.id .equals(12)
            ).executeSelectOne()

    assertEquals(customerWithCompanyInOneQuery2, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date('1990/1/14'),
        'company.id': 10,
        'company.name': 'ACME Inc.'
    })
    expectedQuery.push("select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, company.id as `company.id`, company.`name` as `company.name` from customer inner join company on company.id = customer.company_id where company.`name` = ? and (lower(customer.first_name) like concat('%', lower(?), '%') or lower(customer.last_name) like concat('%', lower(?), '%')) order by lower(`company.name`) asc, birthday desc")
    expectedParams.push(`["ACME","John","Smi"]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    type QueryFilterType = DynamicCondition<{
        id: 'int',
        firstName: 'string',
        lastName: 'string',
        birthday: 'localDate',
        'company.id': 'int',
        'company.name': 'string'
    }>
    
    const queryFilter: QueryFilterType = {
        'company.name': {equals: 'ACME'},
        or: [
            { firstName: { containsInsensitive: 'John' } },
            { lastName: { containsInsensitive: 'Smi' } }
        ]
    }
    
    const queryOrderBy = 'company.name asc insensitive, birthday desc'
    
    const querySelectFields = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        'company.id': tCompany.id,
        'company.name': tCompany.name
    }
    
    const queryDynamicWhere = connection.dynamicConditionFor(querySelectFields).withValues(queryFilter)
    
    const customerWithCompanyObject = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select(querySelectFields)
            .where(queryDynamicWhere)
            .orderByFromString(queryOrderBy)
            .split('company', {
                id: 'company.id',
                name: 'company.name'
            }).executeSelectOne()
    
    assertEquals(customerWithCompanyObject, result)
    
    /* *** Preparation ************************************************************/
    
    result = {
        id: 12,
        name: {
            firstName: 'John',
            lastName: 'Smith',
        },
        birthday: new Date('1990/1/14'),
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        id: 12,
        'name.firstName': 'John',
        'name.lastName': 'Smith',
        birthday: new Date('1990/1/14'),
        'company.id': 10,
        'company.name': 'ACME Inc.'
    })
    expectedQuery.push("select customer.id as id, customer.first_name as `name.firstName`, customer.last_name as `name.lastName`, customer.birthday as birthday, company.id as `company.id`, company.`name` as `company.name` from customer inner join company on company.id = customer.company_id where company.`name` = ? and (lower(customer.first_name) like concat('%', lower(?), '%') or lower(customer.last_name) like concat('%', lower(?), '%')) order by lower(`company.name`) asc, birthday desc")
    expectedParams.push(`["ACME","John","Smi"]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    type QueryFilterType2 = DynamicCondition<{
        id: 'int',
        name: {
            firstName: 'string',
            lastName: 'string',
        },
        birthday: 'localDate',
        company: {
            id: 'int',
            name: 'string'
        }
    }>
    
    const queryFilter2: QueryFilterType2 = {
        company: { name: {equals: 'ACME'} },
        name: {
            or: [
                { firstName: { containsInsensitive: 'John' } },
                { lastName: { containsInsensitive: 'Smi' } }
            ]
        }
    }
    
    const queryOrderBy2 = 'company.name asc insensitive, birthday desc'
    
    const querySelectFields2 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday,
        company: {
            id: tCompany.id,
            name: tCompany.name
        }
    }
    
    const queryDynamicWhere2 = connection.dynamicConditionFor(querySelectFields2).withValues(queryFilter2)
    
    const customerWithCompanyObject2 = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select(querySelectFields2)
            .where(queryDynamicWhere2)
            .orderByFromString(queryOrderBy2)
            .executeSelectOne()
    
    assertEquals(customerWithCompanyObject2, result)
    
    // /* *** Preparation ************************************************************/

    // result = []
    // expectedResult.push(result)
    // expectedQuery.push("with recursive recursive_select_1 as (select id as id, `name` as `name`, parent_id as parentId from company where id = ? union select company.id as id, company.`name` as `name`, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.parentId = company.id) select id as id, `name` as `name`, parentId as parentId from recursive_select_1")
    // expectedParams.push(`[10]`)
    // expectedType.push(`selectManyRows`)
    
    // /* *** Example ****************************************************************/

    // const recursiveParentCompany = await connection.selectFrom(tCompany)
    //     .where(tCompany.id.equals(10))
    //     .select({
    //         id: tCompany.id,
    //         name: tCompany.name,
    //         parentId: tCompany.parentId
    //     }).recursiveUnion((child) => {
    //         return connection.selectFrom(tCompany)
    //         .join(child).on(child.parentId.equals(tCompany.id))
    //         .select({
    //             id: tCompany.id,
    //             name: tCompany.name,
    //             parentId: tCompany.parentId
    //         })
    //     }).executeSelectMany()
    
    // assertEquals(recursiveParentCompany, result)

    /* *** Preparation ************************************************************/

    // result = []
    // expectedResult.push(result)
    // expectedQuery.push("with recursive recursive_select_1 as (select id as id, `name` as `name`, parent_id as parentId from company where id = ? union select company.id as id, company.`name` as `name`, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.parentId = company.id) select id as id, `name` as `name`, parentId as parentId from recursive_select_1")
    // expectedParams.push(`[10]`)
    // expectedType.push(`selectManyRows`)
    
    // /* *** Example ****************************************************************/

    // const recursiveOnParentCompany = await connection.selectFrom(tCompany)
    //     .where(tCompany.id.equals(10))
    //     .select({
    //         id: tCompany.id,
    //         name: tCompany.name,
    //         parentId: tCompany.parentId
    //     }).recursiveUnionOn((child) => {
    //         return child.parentId.equals(tCompany.id)
    //     }).executeSelectMany()
    
    // assertEquals(recursiveOnParentCompany, result)
    
    // /* *** Preparation ************************************************************/

    // result = []
    // expectedResult.push(result)
    // expectedQuery.push("with recursive recursive_select_1 as (select id as id, `name` as `name`, parent_id as parentId from company where id = ? union all select company.id as id, company.`name` as `name`, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.id = company.parent_id) select id as id, `name` as `name`, parentId as parentId from recursive_select_1")
    // expectedParams.push(`[10]`)
    // expectedType.push(`selectManyRows`)
    
    // /* *** Example ****************************************************************/

    // const recursiveChildrenCompany = await connection.selectFrom(tCompany)
    //     .where(tCompany.id.equals(10))
    //     .select({
    //         id: tCompany.id,
    //         name: tCompany.name,
    //         parentId: tCompany.parentId
    //     }).recursiveUnionAll((parent) => {
    //         return connection.selectFrom(tCompany)
    //         .join(parent).on(parent.id.equals(tCompany.parentId))
    //         .select({
    //             id: tCompany.id,
    //             name: tCompany.name,
    //             parentId: tCompany.parentId
    //         })
    //     }).executeSelectMany()
    
    // assertEquals(recursiveChildrenCompany, result)
    
    // /* *** Preparation ************************************************************/

    // result = []
    // expectedResult.push(result)
    // expectedQuery.push("with recursive recursive_select_1 as (select id as id, `name` as `name`, parent_id as parentId from company where id = ? union all select company.id as id, company.`name` as `name`, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.id = company.parent_id) select id as id, `name` as `name`, parentId as parentId from recursive_select_1")
    // expectedParams.push(`[10]`)
    // expectedType.push(`selectManyRows`)
    
    // /* *** Example ****************************************************************/

    // const recursiveOnChildrenCompany = await connection.selectFrom(tCompany)
    //     .where(tCompany.id.equals(10))
    //     .select({
    //         id: tCompany.id,
    //         name: tCompany.name,
    //         parentId: tCompany.parentId
    //     }).recursiveUnionAllOn((parent) => {
    //         return parent.id.equals(tCompany.parentId)
    //     }).executeSelectMany()
    
    // assertEquals(recursiveOnChildrenCompany, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parentId: 18,
        parentName: 'name'
    }])
    expectedQuery.push("select company.id as id, company.`name` as `name`, parent.id as parentId, parent.`name` as parentName from company left join company as parent on company.parent_id = parent.id")
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parent = tCompany.forUseInLeftJoinAs('parent')
    
    const leftJoinCompany = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: parent.id,
            parentName: parent.name
        }).guidedSplitOptional('parent', {
            id: 'parentId!',
            name: 'parentName!'
        }).executeSelectMany()
    
    assertEquals(leftJoinCompany, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        'parent.id': 18,
        'parent.name': 'name'
    }])
    expectedQuery.push("select company.id as id, company.`name` as `name`, parent.id as `parent.id`, parent.`name` as `parent.name` from company left join company as parent on company.parent_id = parent.id")
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    //const parent = tCompany.forUseInLeftJoinAs('parent')
    
    const leftJoinCompany2 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parent: {
                id: parent.id,
                name: parent.name
            }
        }).executeSelectMany()
    
    assertEquals(leftJoinCompany2, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName from customer`)
    expectedParams.push(`[]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const availableFields = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday
    }
    
    const fieldsToPick = {
        firstName: true,
        lastName: true
    }
    
    // include allways id field as required
    const pickedFields = dynamicPick(availableFields, fieldsToPick, ['id'])
    
    const customerWithIdPeaking = await connection.selectFrom(tCustomer)
        .select(pickedFields)
        .executeSelectOne()
    
    assertEquals(customerWithIdPeaking, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName from customer where id = ?`)
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields2 = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyId: tCompany.id,
        companyName: tCompany.name
    }
    
    const fieldsToPick2 = {
        firstName: true,
        lastName: true
    }
    
    // include allways id field as required
    const pickedFields2 = dynamicPick(availableFields2, fieldsToPick2, ['id'])
    
    const customerWithOptionalCompany = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields2)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, company.`name` as companyName from customer inner join company on company.id = customer.company_id where customer.id = ?")
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields3 = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyId: tCompany.id,
        companyName: tCompany.name
    }
    
    const fieldsToPick3 = {
        firstName: true,
        lastName: true,
        companyName: true
    }
    
    // include allways id field as required
    const pickedFields3 = dynamicPick(availableFields3, fieldsToPick3, ['id'])
    
    const customerWithOptionalCompany3 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields3)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany3, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: {
            firstName: 'First Name',
            lastName: 'Last Name'
        }
    }
    expectedResult.push({
        id: 1,
        'name.firstName': 'First Name',
        'name.lastName': 'Last Name'
    })
    expectedQuery.push("select id as id, first_name as `name.firstName`, last_name as `name.lastName` from customer")
    expectedParams.push(`[]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const availableFields4 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday
    }
    
    const fieldsToPick4 = {
        name: {
            firstName: true,
            lastName: true
        }
    }
    
    // include allways id field as required
    const pickedFields4 = dynamicPick(availableFields4, fieldsToPick4, ['id'])
    
    const customerWithIdPeaking4 = await connection.selectFrom(tCustomer)
        .select(pickedFields4)
        .executeSelectOne()
    
    assertEquals(customerWithIdPeaking4, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as id, first_name as `name.firstName`, last_name as `name.lastName` from customer where id = ?")
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields5 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday,
        company: {
            id: tCompany.id,
            name: tCompany.name
        }
    }
    
    const fieldsToPick5 = {
        name: {
            firstName: true,
            lastName: true
        }
    }
    
    // include allways id field as required
    const pickedFields5 = dynamicPick(availableFields5, fieldsToPick5, ['id'])
    
    const customerWithOptionalCompany5 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields5)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany5, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select customer.id as id, customer.first_name as `name.firstName`, customer.last_name as `name.lastName`, company.id as `company.id`, company.`name` as `company.name` from customer inner join company on company.id = customer.company_id where customer.id = ?")
    expectedParams.push(`[12]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const availableFields6 = {
        id: tCustomer.id,
        name: {
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
        },
        birthday: tCustomer.birthday,
        company: {
            id: tCompany.id,
            name: tCompany.name
        }
    }
    
    const fieldsToPick6 = {
        name: {
            firstName: true,
            lastName: true,
        },
        company: {
            name: true
        }
    }
    
    // include allways id field as required
    const pickedFields6 = dynamicPick(availableFields6, fieldsToPick6, ['id'])
    
    const customerWithOptionalCompany6 = await connection.selectFrom(tCustomer)
        .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(pickedFields6)
        .where(tCustomer.id.equals(12))
        .executeSelectMany()
    
    assertEquals(customerWithOptionalCompany6, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer for system_time between ? and ?  where id = ?`)
    expectedParams.push(`["2019-01-01T00:00:00.000Z","2020-01-01T00:00:00.000Z",10]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const customerIn2019 = connection.forSystemTimeBetween(tCustomer, 'customerIn2019', new Date('2019-01-01'), new Date('2020-01-01'))
    
    const customerInSystemTime = await connection.selectFrom(customerIn2019)
        .where(customerIn2019.id.equals(10))
        .select({
            id: customerIn2019.id,
            firstName: customerIn2019.firstName,
            lastName: customerIn2019.lastName,
            birthday: customerIn2019.birthday
        })
        .executeSelectMany()
    
    assertEquals(customerInSystemTime, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    let customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by my_column, my_id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            beforeOrderByItems: connection.rawFragment`my_column`,
            afterOrderByItems: connection.rawFragment`my_id`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by my_column for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            beforeOrderByItems: connection.rawFragment`my_column`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by my_id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        }).customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            afterOrderByItems: connection.rawFragment`my_id`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .orderBy('id')
        .customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by my_column, id, my_id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .orderBy('id')
        .customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            beforeOrderByItems: connection.rawFragment`my_column`,
            afterOrderByItems: connection.rawFragment`my_id`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by my_column, id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .orderBy('id')
        .customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            beforeOrderByItems: connection.rawFragment`my_column`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        firstName: 'First Name',
        lastName: 'Last Name'
    }
    expectedResult.push(result)
    expectedQuery.push(`select /*+ some hints */ id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = ? order by id, my_id for update`)
    expectedParams.push(`[10]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    customizedSelect = await connection.selectFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday
        })
        .orderBy('id')
        .customizeQuery({
            afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`for update`,
            afterOrderByItems: connection.rawFragment`my_id`
        })
        .executeSelectOne()
    
    assertEquals(customizedSelect, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`update /*+ some hints */ customer set first_name = ?, last_name = ? where id = ? keep plan`)
    expectedParams.push(`["John","Smith",10]`)
    expectedType.push(`update`)
    
    /* *** Example ****************************************************************/

    const customizedUpdate = await connection.update(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith'
        }).where(tCustomer.id.equals(10))
        .customizeQuery({
            afterUpdateKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`keep plan`,
        })
        .executeUpdate()
    
    assertEquals(customizedUpdate, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`delete /*+ some hints */ from customer where id = ? keep plan`)
    expectedParams.push(`[10]`)
    expectedType.push(`delete`)
    
    /* *** Example ****************************************************************/

    const customizedDelete = await connection.deleteFrom(tCustomer)
        .where(tCustomer.id.equals(10))
        .customizeQuery({
            afterDeleteKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`keep plan`,
        })
        .executeDelete()
    
    assertEquals(customizedDelete, result)
    
    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert /*+ some hints */ into customer (first_name, last_name, company_id) values (?, ?, ?) log errors reject limit unlimited`)
    expectedParams.push(`["John","Smith",1]`)
    expectedType.push(`insert`)
    
    /* *** Example ****************************************************************/

    const customizedInsert = await connection.insertInto(tCustomer).set({
            firstName: 'John',
            lastName: 'Smith',
            companyId: 1
        }).customizeQuery({
            afterInsertKeyword: connection.rawFragment`/*+ some hints */`,
            afterQuery: connection.rawFragment`log errors reject limit unlimited`
        }).executeInsert()

    assertEquals(customizedInsert, result)
    
    /* *** Preparation ************************************************************/

    result = {
        id: 9,
        firstName: 'First Name',
        lastName: 'Last Name',
        companyId: 7
    }
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer where id = ?`)
    expectedParams.push(`[9]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const selectAll = await connection.selectFrom(tCustomer)
        .select(extractColumnsFrom(tCustomer))
        .where(tCustomer.id.equals(9))
        .executeSelectOne()
    
    assertEquals(selectAll, result)
    
    /* *** Preparation ************************************************************/

    result = {
        customer: {
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14'),
        },
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        'customer.id': 12,
        'customer.firstName': 'John',
        'customer.lastName': 'Smith',
        'customer.birthday': new Date('1990/1/14'),
        'company.id': 10,
        'company.name': 'ACME Inc.'
    })
    expectedQuery.push("select customer.id as `customer.id`, customer.first_name as `customer.firstName`, customer.last_name as `customer.lastName`, customer.birthday as `customer.birthday`, company.id as `company.id`, company.`name` as `company.name` from customer inner join company on company.id = customer.company_id where customer.id = ?")
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customerColumns = {
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday
    }
    
    const companyColumns = {
        id: tCompany.id,
        name: tCompany.name
    }
    
    const customerWithCompanyPrefixed = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select({
                ...prefixDotted(customerColumns, 'customer'),
                ...prefixDotted(companyColumns, 'company')
            }).where(
                tCustomer.id.equals(12)
            )
            .split('customer', prefixMapForSplitDotted(customerColumns, 'customer'))
            .split('company', prefixMapForSplitDotted(companyColumns, 'company'))
            .executeSelectOne()
    
    assertEquals(customerWithCompanyPrefixed, result)
    
    /* *** Preparation ************************************************************/

    result = {
        customer: {
            id: 12,
            firstName: 'John',
            lastName: 'Smith',
            birthday: new Date('1990/1/14'),
        },
        company: {
            id: 10,
            name: 'ACME Inc.'
        }
    }
    expectedResult.push({
        customerId: 12,
        customerFirstName: 'John',
        customerLastName: 'Smith',
        customerBirthday: new Date('1990/1/14'),
        companyId: 10,
        companyName: 'ACME Inc.'
    })
    expectedQuery.push("select customer.id as customerId, customer.first_name as customerFirstName, customer.last_name as customerLastName, customer.birthday as customerBirthday, company.id as companyId, company.`name` as companyName from customer inner join company on company.id = customer.company_id where customer.id = ?")
    expectedParams.push(`[12]`)
    expectedType.push(`selectOneRow`)
    
    /* *** Example ****************************************************************/

    const customerWithCompanyPrefixed2 = await connection.selectFrom(tCustomer)
            .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
            .select({
                ...prefixCapitalized(customerColumns, 'customer'),
                ...prefixCapitalized(companyColumns, 'company')
            }).where(
                tCustomer.id.equals(12)
            )
            .split('customer', prefixMapForSplitCapitalized(customerColumns, 'customer'))
            .split('company', prefixMapForSplitCapitalized(companyColumns, 'company'))
            .executeSelectOne()
    
    assertEquals(customerWithCompanyPrefixed2, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parentId: 18,
        parentName: 'name',
        parentParentId: null
    }])
    expectedQuery.push("select company.id as id, company.`name` as `name`, parent.id as parentId, parent.`name` as parentName, parent.parent_id as parentParentId from company left join company as parent on company.parent_id = parent.id")
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parentCompany = tCompany.forUseInLeftJoinAs('parent')
    
    const companyFields = {
        id: tCompany.id,
        name: tCompany.name
    }
    
    const parentCompanyFields = {
        id: parentCompany.id,
        name: parentCompany.name,
        parentId: parentCompany.parentId
    }
    
    const companyPrefixed = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            ...companyFields,
            ...prefixCapitalized(parentCompanyFields, 'parent')
        }).guidedSplitOptional('parent', prefixMapForGuidedSplitCapitalized(parentCompanyFields, tCompany, 'parent'))
        .executeSelectMany()
    
    assertEquals(companyPrefixed, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name',
            parentId: 8
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        'parent.id': 18,
        'parent.name': 'name',
        'parent.parentId': 8
    }])
    expectedQuery.push("select company.id as id, company.`name` as `name`, parent.id as `parent.id`, parent.`name` as `parent.name`, parent.parent_id as `parent.parentId` from company left join company as parent on company.parent_id = parent.id")
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const companyPrefixed2 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            ...companyFields,
            ...prefixDotted(parentCompanyFields, 'parent')
        }).guidedSplitOptional('parent', prefixMapForGuidedSplitDotted(parentCompanyFields, tCompany, 'parent'))
        .executeSelectMany()
    
    assertEquals(companyPrefixed2, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            parentId: 18,
            parentName: 'name'
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parentId: 18,
        parentName: 'name'
    }])
    expectedQuery.push("select company.id as id, company.`name` as `name`, parent.id as parentId, parent.`name` as parentName, parent.parent_id as parentParentId from company left join company as parent on company.parent_id = parent.id")
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parentFields = {
        parentId: parentCompany.id,
        parentName: parentCompany.name,
        parentParentId: parentCompany.parentId
    }
    
    const companyPrefixed3 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            ...parentFields
        }).guidedSplitOptional('parent', mapForGuidedSplit(parentFields, {
            parentId: tCompany.id,
            parentName: tCompany.name,
            parentParentId: tCompany.parentId
        }))
        .executeSelectMany()
    
    assertEquals(companyPrefixed3, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name',
            parentId: 8
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        'parent.id': 18,
        'parent.name': 'name',
        'parent.parentId': 8
    }])
    expectedQuery.push("select company.id as id, company.`name` as `name`, parent.id as `parent.id`, parent.`name` as `parent.name`, parent.parent_id as `parent.parentId` from company left join company as parent on company.parent_id = parent.id")
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const companyPrefixed4 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parent: {
                id: parentCompany.id,
                name: parentCompany.name,
                parentId: parentCompany.parentId
            }
        }).executeSelectMany()
    
    assertEquals(companyPrefixed4, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }, {
        id: 20,
        name: 'name3',
        parent: {
            id: 19,
            name: 'name2',
            parent: {
                id: 18,
                name: 'name',
                parentId: 17
            }
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parentId: 18,
        parentName: 'name'
    }, {
        id: 20,
        name: 'name3',
        parentId: 19,
        parentName: 'name2',
        parentParentId: 18,
        parentParentName: 'name',
        parentParentParentId: 17
    }])
    expectedQuery.push("select company.id as id, company.`name` as `name`, parent.id as parentId, parent.`name` as parentName, parentParent.id as parentParentId, parentParent.`name` as parentParentName, parentParent.parent_id as parentParentParentId from company left join company as parent on company.parent_id = parent.id left join company as parentParent on parent.parent_id = parentParent.id")
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const parentParent = tCompany.forUseInLeftJoinAs('parentParent')
    
    const companyMultiSplit = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .leftJoin(parentParent).on(parent.parentId.equals(parentParent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: parent.id,
            parentName: parent.name,
            parentParentId: parentParent.id,
            parentParentName: parentParent.name,
            parentParentParentId: parentParent.parentId,
        }).guidedSplitOptional('parentParent', {
            id: 'parentParentId!',
            name: 'parentParentName!',
            parentId: 'parentParentParentId'
        }).guidedSplitOptional('parent', {
            id: 'parentId!',
            name: 'parentName!',
            parent: 'parentParent'
        })
        .executeSelectMany()

    assertEquals(companyMultiSplit, result)
    
    /* *** Preparation ************************************************************/

    result = [{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        parent: {
            id: 18,
            name: 'name'
        }
    }, {
        id: 20,
        name: 'name3',
        parent: {
            id: 19,
            name: 'name2',
            parent: {
                id: 18,
                name: 'name',
                parentId: 17
            }
        }
    }]
    expectedResult.push([{
        id: 18,
        name: 'name'
    }, {
        id: 19,
        name: 'name2',
        'parent.id': 18,
        'parent.name': 'name'
    }, {
        id: 20,
        name: 'name3',
        'parent.id': 19,
        'parent.name': 'name2',
        'parent.parent.id': 18,
        'parent.parent.name': 'name',
        'parent.parent.parentId': 17
    }])
    expectedQuery.push("select company.id as id, company.`name` as `name`, parent.id as `parent.id`, parent.`name` as `parent.name`, parentParent.id as `parent.parent.id`, parentParent.`name` as `parent.parent.name`, parentParent.parent_id as `parent.parent.parentId` from company left join company as parent on company.parent_id = parent.id left join company as parentParent on parent.parent_id = parentParent.id")
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    //const parentParent = tCompany.forUseInLeftJoinAs('parentParent')
    
    const companyMultiSplit2 = await connection.selectFrom(tCompany)
        .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
        .leftJoin(parentParent).on(parent.parentId.equals(parentParent.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parent: {
                id: parent.id,
                name: parent.name,
                parent: {
                    id: parentParent.id,
                    name: parentParent.name,
                    parentId: parentParent.parentId,
                }
            }
        })
        .executeSelectMany()

    assertEquals(companyMultiSplit2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as id, concat(first_name, ?, last_name) as `name` from customer where company_id = (select id as result from company where `name` = ?)")
    expectedParams.push(`[" ","ACME"]`)
    expectedType.push(`selectManyRows`)
    
    /* *** Example ****************************************************************/

    const acmeId = connection.selectFrom(tCompany)
        .where(tCompany.name.equals('ACME'))
        .selectOneColumn(tCompany.id)
        .forUseAsInlineQueryValue()

    const acmeCustomers = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.equals(acmeId))
        .select({
            id: tCustomer.id,
            name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName)
        })
        .executeSelectMany()

    assertEquals(acmeCustomers, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push("update customer, company set customer.last_name = concat(customer.last_name, ?, company.`name`) where customer.company_id = company.id and lower(company.`name`) like concat('%', lower(?), '%')")
    expectedParams.push(`[" - ","ACME"]`)
    expectedType.push(`update`)

    /* *** Example ****************************************************************/

    const addACMECompanyNameToLastName = await connection.update(tCustomer)
        .from(tCompany)
        .set({
            lastName: tCustomer.lastName.concat(' - ').concat(tCompany.name)
        })
        .where(tCustomer.companyId.equals(tCompany.id))
        .and(tCompany.name.containsInsensitive('ACME'))
        .executeUpdate()

    assertEquals(addACMECompanyNameToLastName, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push("delete from customer using customer, company where customer.company_id = company.id and lower(company.`name`) like concat('%', lower(?), '%')")
    expectedParams.push(`["ACME"]`)
    expectedType.push(`delete`)

    /* *** Example ****************************************************************/

    const deleteACMECustomers = await connection.deleteFrom(tCustomer)
        .using(tCompany)
        .where(tCustomer.companyId.equals(tCompany.id))
        .and(tCompany.name.containsInsensitive('ACME'))
        .executeDelete()

    assertEquals(deleteACMECustomers, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, (select json_arrayagg(json_object('id', id, 'firstName', first_name, 'lastName', last_name)) as result from customer where company_id = company.id) as customers from company where id = ?")
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(connection.aggregateAsArray({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        }))
        .forUseAsInlineQueryValue()

    const acmeCompanyWithCustomers = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme
        })
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push("select company.id as id, company.`name` as `name`, json_arrayagg(json_object('id', customer.id, 'firstName', customer.first_name, 'lastName', customer.last_name)) as customers from company left join customer on customer.company_id = company.id where company.id = ? group by company.id")
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const tCustomerLeftJoin = tCustomer.forUseInLeftJoin()
    const acmeCompanyWithCustomers2 = await connection.selectFrom(tCompany).leftJoin(tCustomerLeftJoin).on(tCustomerLeftJoin.companyId.equals(tCompany.id))
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: connection.aggregateAsArray({
                id: tCustomerLeftJoin.id,
                firstName: tCustomerLeftJoin.firstName,
                lastName: tCustomerLeftJoin.lastName
            }).asOptionalNonEmptyArray()
        })
        .groupBy('id')
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers2, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, (select json_arrayagg(concat(first_name, ?, last_name)) as result from customer where company_id = company.id) as customers from company where id = ?")
    expectedParams.push(`[" ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme3 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(connection.aggregateAsArrayOfOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName)))
        .forUseAsInlineQueryValue()

    const acmeCompanyWithCustomers3 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme3.useEmptyArrayForNoValue()
        })
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers3, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push("select company.id as id, company.`name` as `name`, json_arrayagg(concat(customer.first_name, ?, customer.last_name)) as customers from company left join customer on customer.company_id = company.id where company.id = ? group by company.id")
    expectedParams.push(`[" ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    // const tCustomerLeftJoin = tCustomer.forUseInLeftJoin()
    const acmeCompanyWithCustomers3_1 = await connection.selectFrom(tCompany).leftJoin(tCustomerLeftJoin).on(tCustomerLeftJoin.companyId.equals(tCompany.id))
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: connection.aggregateAsArrayOfOneColumn(tCustomerLeftJoin.firstName.concat(' ').concat(tCustomerLeftJoin.lastName))
        })
        .groupBy('id')
        .executeSelectOne()
    
    assertEquals(acmeCompanyWithCustomers3_1, result)
    
    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as customerId, first_name as customerFirstName, last_name as customerLastName from customer where company_id in (select inner2.id as result from company inner join (select id as id, `name` as `name` from custom_company where id = customer.company_id) as inner2 on company.id = inner2.id where company.`name` like concat('%', ?, '%'))")
    expectedParams.push(`["Cia."]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const inner2 = connection.subSelectUsing(tCustomer).from(tCustomCompany).where(tCustomCompany.id.equals(tCustomer.companyId)).select({id: tCustomCompany.id, name: tCustomCompany.name}).forUseInQueryAs('inner2')
    
    const customerWithSelectedCompanies2 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.in(
            connection.selectFrom(tCompany).innerJoin(inner2).on(tCompany.id.equals(inner2.id))
                .where(tCompany.name.contains('Cia.'))
                .selectOneColumn(inner2.id)
        )).select({
            customerId: tCustomer.id,
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        })
        .executeSelectMany()
    
    assertEquals(customerWithSelectedCompanies2, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select id as customerId, first_name as customerFirstName, last_name as customerLastName from customer where company_id in (select inner3.id as result from company inner join (select id as id, `name` as `name` from custom_company) as inner3 on company.id = inner3.id where company.`name` like concat('%', ?, '%'))")
    expectedParams.push(`["Cia."]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    const inner3 = connection.selectFrom(tCustomCompany).select({id: tCustomCompany.id, name: tCustomCompany.name}).forUseInQueryAs('inner3')
    
    const customerWithSelectedCompanies3 = await connection.selectFrom(tCustomer)
        .where(tCustomer.companyId.in(
            connection.selectFrom(tCompany).innerJoin(inner3).on(tCompany.id.equals(inner3.id))
                .where(tCompany.name.contains('Cia.'))
                .selectOneColumn(inner3.id)
        )).select({
            customerId: tCustomer.id,
            customerFirstName: tCustomer.firstName,
            customerLastName: tCustomer.lastName
        })
        .executeSelectMany()
    
    assertEquals(customerWithSelectedCompanies3, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, (select json_arrayagg(json_object('id', id, 'firstName', first_name, 'lastName', last_name)) from customer where company_id = company.id) as customers from company where id = ?")
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme4 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers4 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme4
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers4, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, (select json_arrayagg(json_object('id', a_1_.id, 'firstName', a_1_.firstName, 'lastName', a_1_.lastName)) from (select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id order by id limit 2147483647) as a_1_) as customers from company where id = ?")
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme5 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        })
        .orderBy('id')
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers5 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme5
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers5, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, (select json_arrayagg(concat(first_name, ?, last_name)) from customer where company_id = company.id) as customers from company where id = ?")
    expectedParams.push(`[" ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme6 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers6 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme6.useEmptyArrayForNoValue()
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers6, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, (select json_arrayagg(a_1_.result) from (select concat(first_name, ?, last_name) as result from customer where company_id = company.id order by result limit 2147483647) as a_1_) as customers from company where id = ?")
    expectedParams.push(`[" ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme7 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        .orderBy('result')
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers7 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme7.useEmptyArrayForNoValue()
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers7, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, (select json_arrayagg(json_object('id', a_1_.id, 'firstName', a_1_.firstName, 'lastName', a_1_.lastName)) from (select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id union select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id) as a_1_) as customers from company where id = ?")
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme8 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        }).union(
            connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            })
        )
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers8 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme8
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers8, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            { id: 1, firstName: 'John', lastName: 'Smith' },
            { id: 2, firstName: 'Other', lastName: 'Person' },
            { id: 3, firstName: 'Jane', lastName: 'Doe' }
        ]
    }
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, (select json_arrayagg(json_object('id', a_1_.id, 'firstName', a_1_.firstName, 'lastName', a_1_.lastName)) from (select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id union select id as id, first_name as firstName, last_name as lastName from customer where company_id = company.id order by id limit 2147483647) as a_1_) as customers from company where id = ?")
    expectedParams.push(`[1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme9 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName
        }).union(
            connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .select({
                id: tCustomer.id,
                firstName: tCustomer.firstName,
                lastName: tCustomer.lastName
            })
        ).orderBy('id')
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers9 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme9
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers9, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, (select json_arrayagg(a_1_.result) from (select concat(first_name, ?, last_name) as result from customer where company_id = company.id union select concat(first_name, ?, last_name) as result from customer where company_id = company.id) as a_1_) as customers from company where id = ?")
    expectedParams.push(`[" "," ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme10 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        .union(
            connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        )
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers10 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme10.useEmptyArrayForNoValue()
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers10, result)

    /* *** Preparation ************************************************************/

    result = {
        id: 1,
        name: 'ACME',
        customers: [
            'Jane Doe',
            'John Smith',
            'Other Person'
        ]
    }
    expectedResult.push(result)
    expectedQuery.push("select id as id, `name` as `name`, (select json_arrayagg(a_1_.result) from (select concat(first_name, ?, last_name) as result from customer where company_id = company.id union select concat(first_name, ?, last_name) as result from customer where company_id = company.id order by result limit 2147483647) as a_1_) as customers from company where id = ?")
    expectedParams.push(`[" "," ",1]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedCustomersOfAcme11 = connection.subSelectUsing(tCompany).from(tCustomer)
        .where(tCustomer.companyId.equals(tCompany.id))
        .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        .union(
            connection.subSelectUsing(tCompany).from(tCustomer)
            .where(tCustomer.companyId.equals(tCompany.id))
            .selectOneColumn(tCustomer.firstName.concat(' ').concat(tCustomer.lastName))
        ).orderBy('result')
        .forUseAsInlineAggregatedArrayValue()

    const acmeCompanyWithCustomers11 = await connection.selectFrom(tCompany)
        .where(tCompany.id.equals(1))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            customers: aggregatedCustomersOfAcme11.useEmptyArrayForNoValue()
        })
        .executeSelectOne()

    assertEquals(acmeCompanyWithCustomers11, result)

    // /* *** Preparation ************************************************************/

    // result = { 
    //     id: 10, 
    //     name: 'Low Company', 
    //     parentId: 9, 
    //     parents: [
    //         { id: 9, name: 'Mic Company', parentId: 8 }, 
    //         { id: 8, name: 'Top Company' }
    //     ]
    // }
    // expectedResult.push(result)
    // expectedQuery.push("select id as id, `name` as `name`, parent_id as parentId, (with recursive recursive_select_1 as (select parentCompany.id as id, parentCompany.`name` as `name`, parentCompany.parent_id as parentId from company as parentCompany where parentCompany.id = company.parent_id union all select parentCompany.id as id, parentCompany.`name` as `name`, parentCompany.parent_id as parentId from company as parentCompany join recursive_select_1 on recursive_select_1.parentId = parentCompany.id) select json_arrayagg(json_object('id', id, 'name', `name`, 'parentId', parentId)) from recursive_select_1) as parents from company where id = ?")
    // expectedParams.push(`[10]`)
    // expectedType.push(`selectOneRow`)

    // /* *** Example ****************************************************************/

    // const parentCompany2 = tCompany.as('parentCompany')

    // const parentCompanies = connection.subSelectUsing(tCompany)
    //     .from(parentCompany2)
    //     .select({
    //         id: parentCompany2.id,
    //         name: parentCompany2.name,
    //         parentId: parentCompany2.parentId
    //     })
    //     .where(parentCompany2.id.equals(tCompany.parentId))
    //     .recursiveUnionAllOn((child) => {
    //         return child.parentId.equals(parentCompany2.id)
    //     })
    //     .forUseAsInlineAggregatedArrayValue()

    // const lowCompany = await connection.selectFrom(tCompany)
    //     .select({
    //         id: tCompany.id,
    //         name: tCompany.name,
    //         parentId: tCompany.parentId,
    //         parents: parentCompanies
    //     })
    //     .where(tCompany.id.equals(10))
    //     .executeSelectOne()
    
    // assertEquals(lowCompany, result)

    // /* *** Preparation ************************************************************/

    // result = { 
    //     id: 10, 
    //     name: 'Low Company', 
    //     parentId: 9, 
    //     parents: [
    //         { id: 9, name: 'Mic Company', parentId: 8 }, 
    //         { id: 8, name: 'Top Company' }
    //     ]
    // }
    // expectedResult.push(result)
    // expectedQuery.push("with recursive recursive_select_1 as (select parentCompany.id as id, parentCompany.`name` as `name`, parentCompany.parent_id as parentId from company as parentCompany where parentCompany.id = ? union all select parentCompany.id as id, parentCompany.`name` as `name`, parentCompany.parent_id as parentId from company as parentCompany join recursive_select_1 on recursive_select_1.parentId = parentCompany.id) select id as id, `name` as `name`, parent_id as parentId, (select json_arrayagg(json_object('id', id, 'name', `name`, 'parentId', parentId)) from recursive_select_1) as parents from company where id = ?")
    // expectedParams.push(`[9,10]`)
    // expectedType.push(`selectOneRow`)

    // /* *** Example ****************************************************************/

    // const parentCompanies2 = connection.selectFrom(parentCompany2)
    //     .select({
    //         id: parentCompany2.id,
    //         name: parentCompany2.name,
    //         parentId: parentCompany2.parentId
    //     })
    //     .where(parentCompany2.id.equals(9))
    //     .recursiveUnionAllOn((child) => {
    //         return child.parentId.equals(parentCompany2.id)
    //     })
    //     .forUseAsInlineAggregatedArrayValue()

    // const lowCompany2 = await connection.selectFrom(tCompany)
    //     .select({
    //         id: tCompany.id,
    //         name: tCompany.name,
    //         parentId: tCompany.parentId,
    //         parents: parentCompanies2
    //     })
    //     .where(tCompany.id.equals(10))
    //     .executeSelectOne()
    
    // assertEquals(lowCompany2, result)

    // /* *** Preparation ************************************************************/

    // result = { 
    //     id: 10, 
    //     name: 'Low Company', 
    //     parentId: 9, 
    //     parents: [
    //         { id: 9, name: 'Mic Company', parentId: 8 }, 
    //         { id: 8, name: 'Top Company' }
    //     ]
    // }
    // expectedResult.push({ id: 10, name: 'Low Company', parentId: 9 })
    // expectedQuery.push("select id as id, `name` as `name`, parent_id as parentId from company where id = ?")
    // expectedParams.push(`[10]`)
    // expectedType.push(`selectOneRow`)

    // expectedResult.push([{ startId: 9, id: 9, name: 'Mic Company', parentId: 8 }, { startId: 9, id: 8, name: 'Top Company' }])
    // expectedQuery.push("with recursive recursive_select_1 as (select parentCompany.id as id, parentCompany.`name` as `name`, parentCompany.parent_id as parentId, parentCompany.id as startId from company as parentCompany where parentCompany.id in (?) union all select parentCompany.id as id, parentCompany.`name` as `name`, parentCompany.parent_id as parentId, recursive_select_1.startId as startId from company as parentCompany join recursive_select_1 on recursive_select_1.parentId = parentCompany.id) select id as id, `name` as `name`, parentId as parentId, startId as startId from recursive_select_1")
    // expectedParams.push(`[9]`)
    // expectedType.push(`selectManyRows`)

    // /* *** Example ****************************************************************/

    // const lowCompany3 = await connection.selectFrom(tCompany)
    //     .select({
    //         id: tCompany.id,
    //         name: tCompany.name,
    //         parentId: tCompany.parentId
    //     })
    //     .where(tCompany.id.equals(10))
    //     .composeDeletingInternalProperty({
    //         externalProperty: 'parentId',
    //         internalProperty: 'startId',
    //         propertyName: 'parents'
    //     }).withMany((ids) => {
    //         return connection.selectFrom(parentCompany2)
    //             .select({
    //                 id: parentCompany2.id,
    //                 name: parentCompany2.name,
    //                 parentId: parentCompany2.parentId,
    //                 startId: parentCompany2.id
    //             })
    //             .where(parentCompany2.id.in(ids))
    //             .recursiveUnionAll((child) => {
    //                 return connection.selectFrom(parentCompany2)
    //                     .join(child).on(child.parentId.equals(parentCompany2.id))
    //                     .select({
    //                         id: parentCompany2.id,
    //                         name: parentCompany2.name,
    //                         parentId: parentCompany2.parentId,
    //                         startId: child.startId
    //                     })
    //             })
    //             .executeSelectMany()
    //     })
    //     .executeSelectOne()
    
    // assertEquals(lowCompany3, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_to_bin(?), ?)`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    let insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        }).executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = { id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }
    expectedResult.push(result)
    expectedQuery.push(`select bin_to_uuid(id) as id, title as title from record where bin_to_uuid(id) like concat('%', ?, '%')`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const selectUuid = await connection.selectFrom(tRecord)
        .select({
            id: tRecord.id,
            title: tRecord.title
        })
        .where(tRecord.id.asString().contains('7002'))
        .executeSelectOne()

    assertEquals(selectUuid, result)

    // /* *** Preparation ************************************************************/

    // result = { id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }
    // expectedResult.push(result)
    // expectedQuery.push(`with with_uuit as (select id as id, title as title from record) select bin_to_uuid(id) as id, title as title from with_uuit where bin_to_uuid(id) like concat('%', ?, '%')`)
    // expectedParams.push(`["7002"]`)
    // expectedType.push(`selectOneRow`)

    // /* *** Example ****************************************************************/

    // const withSselectUuid = await connection.selectFrom(tRecord)
    //     .select({
    //         id: tRecord.id,
    //         title: tRecord.title
    //     })
    //     .forUseInQueryAs('with_uuit');

    // const selectUuid2 = await connection.selectFrom(withSselectUuid)
    //     .select({
    //         id: withSselectUuid.id,
    //         title: withSselectUuid.title
    //     })
    //     .where(withSselectUuid.id.asString().contains('7002'))
    //     .executeSelectOne()

    // assertEquals(selectUuid2, result)

    /* *** Preparation ************************************************************/

    result = { records: [{ id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }] }
    expectedResult.push(result)
    expectedQuery.push(`select (select json_arrayagg(json_object('id', bin_to_uuid(id), 'title', title)) from record where bin_to_uuid(id) like concat('%', ?, '%')) as records`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedUuid = await connection.selectFrom(tRecord)
        .select({
            id: tRecord.id,
            title: tRecord.title
        })
        .where(tRecord.id.asString().contains('7002'))
        .forUseAsInlineAggregatedArrayValue()

    const selectUuid3 = await connection.selectFromNoTable()
        .select({
            records: aggregatedUuid,
        })
        .executeSelectOne()

    assertEquals(selectUuid3, result)

    /* *** Preparation ************************************************************/

    result = { records: [{ id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }] }
    expectedResult.push(result)
    expectedQuery.push(`select (select json_arrayagg(json_object('id', bin_to_uuid(a_1_.id), 'title', a_1_.title)) from (select id as id, title as title from record where bin_to_uuid(id) like concat('%', ?, '%') order by id limit 2147483647) as a_1_) as records`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const aggregatedUuid2 = await connection.selectFrom(tRecord)
        .select({
            id: tRecord.id,
            title: tRecord.title
        })
        .where(tRecord.id.asString().contains('7002'))
        .orderBy('id')
        .forUseAsInlineAggregatedArrayValue()

    const selectUuid4 = await connection.selectFromNoTable()
        .select({
            records: aggregatedUuid2,
        })
        .executeSelectOne()

    assertEquals(selectUuid4, result)

    /* *** Preparation ************************************************************/

    result = { records: [{ id: '89bf68fc-7002-11ec-90d6-0242ac120003', title: 'My voice memo' }] }
    expectedResult.push(result)
    expectedQuery.push(`select json_arrayagg(json_object('id', bin_to_uuid(id), 'title', title)) as records from record where bin_to_uuid(id) like concat('%', ?, '%')`)
    expectedParams.push(`["7002"]`)
    expectedType.push(`selectOneRow`)

    /* *** Example ****************************************************************/

    const selectUuid5 = await connection.selectFrom(tRecord)
        .select({
            records: connection.aggregateAsArray({
                id: tRecord.id,
                title: tRecord.title
            })
        })
        .where(tRecord.id.asString().contains('7002'))
        .executeSelectOne()

    assertEquals(selectUuid5, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert ignore into record (id, title) values (uuid_to_bin(?), ?)`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictDoNothing()
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_to_bin(?), ?) on duplicate key update title = ?`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo","My voice memo 2"]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictDoUpdateSet({
            title: 'My voice memo 2'
        })
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = 1
    expectedResult.push(result)
    expectedQuery.push(`insert into record (id, title) values (uuid_to_bin(?), ?) on duplicate key update title = concat(title, ?, values(title))`)
    expectedParams.push(`["89bf68fc-7002-11ec-90d6-0242ac120003","My voice memo"," - "]`)
    expectedType.push(`insert`)

    /* *** Example ****************************************************************/

    const tRecordForInsert = tRecord.valuesForInsert()
    insertUuid = await connection.insertInto(tRecord)
        .values({
            id: '89bf68fc-7002-11ec-90d6-0242ac120003',
            title: 'My voice memo'
        })
        .onConflictDoUpdateSet({
            title: tRecord.title.concat(' - ').concat(tRecordForInsert.title)
        })
        .executeInsert()
    assertEquals(insertUuid, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push(`select id as id, first_name as firstName, last_name as lastName, birthday as birthday, company_id as companyId from customer`)
    expectedParams.push(`[]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    let companyName: string | undefined = undefined

    let customers = await connection.selectFrom(tCustomer)
        .optionalJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .where(tCompany.name.equalsIfValue(companyName))
        .select(extractColumnsFrom(tCustomer))
        .executeSelectMany()
    assertEquals(customers, result)

    /* *** Preparation ************************************************************/

    result = []
    expectedResult.push(result)
    expectedQuery.push("select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, customer.company_id as companyId from customer join company on company.id = customer.company_id where company.`name` = ?")
    expectedParams.push(`["My company name"]`)
    expectedType.push(`selectManyRows`)

    /* *** Example ****************************************************************/

    companyName = 'My company name'

    customers = await connection.selectFrom(tCustomer)
        .optionalJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .where(tCompany.name.equalsIfValue(companyName))
        .select(extractColumnsFrom(tCustomer))
        .executeSelectMany()
    assertEquals(customers, result)
}

main().then(() => {
    console.log('All ok')
    process.exit(0)
}).catch((e) => {
    console.error(e)
    process.exit(1)
})